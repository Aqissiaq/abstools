== Modules

All ABS definitions (classes, interfaces, functions data types, type aliases)
are contained in modules.  All definitions are visible in their own module
only, except when the module exports the name and it is imported in another
module or referenced by its qualified name.

NOTE: The `export` clause in a module definition exports _names_, not
definitions as such.  This means that if a module defines a class and an
interface with the same name, both definitions will be accessible if that name
is contained in the `export` clause.


=== Defining a Module


[caption=]
.Syntax
====
_ModuleDecl_  ::= `module` _QualifiedTypeIdentifier_ `;` { _Export_ } { _Import_ } { _Decl_ } [ _Block_ ] +
_Export_      ::= `export` _IdentifierList_ [ `from` _QualifiedTypeIdentifier_ ] `;` +
              | `export` `\*` [ `from` _QualifiedTypeIdentifier_ ] `;` +
_Import_      ::= `import` _IdentifierList_ [ `from` _QualifiedTypeIdentifier_ ] `;` +
              | `import` `*` `from` _QualifiedTypeIdentifier_ `;` +
_IdentifierList_ ::= _AnyIdentifier_ { `,` _AnyIdentifier_ } +
_AnyIdentifier_ ::= _Identifier_ | _TypeIdentifier_ +

_Decl_        ::= _FunDecl_ | _TypeSynDecl_ | _DataTypeDecl_ | _InterfaceDecl_ | _ClassDecl_
====

A module with name MyModule is declared by writing

    module MyModule;

This declaration introduces a new module name `MyModule` which can be used to
qualify names. All declarations which follow this statement belong to the
module `MyModule`. A module name is a type name and must always start with an
upper case letter.

The module `ABS.StdLib` contains the standard library and is automatically
imported by every module.

=== Exporting Identifiers

By default, modules do not export any names.
In order to make names of a module usable to other modules, the names have to be _exported_.
For example, to export a data type and a data constructor, one can write something like this:

[source]
----
module Drinks;
export Drink, Milk;
data Drink = Milk | Water;
----

Note that in this example, the data constructor `Water` is not exported, and
can thus not be used by other modules.  By only exporting the data type
without any of its constructors, one can realize _abstract data types_ in ABS.

A special export clause `export *;` exports all names that are _defined_ in
the module.  In particular, this means that imported names are _not_ exported (but can be re-exported via additional `export` clauses).

[source]
----
export *;
----

=== Importing Identifiers

In order to use exported names of a module in another module, the names have
to be imported.  In a module definition, an optional list of import clauses
follows the list of export clauses.  For example, to write a module that
imports the `Drink` data type of the module `Drinks` one can write:

[source]
----
module Bar;
import Drinks.Drink;  
----

After a name has been imported, it can be used inside the module in a fully
qualified way.

To use a name from another module in an unqualified way requires an
_unqualified import_.
For example, to use the `Milk` data constructor inside the
`Bar` module, without having to qualify it with the `Drinks`
module each time, the following unqualified import statement is used:

[source]
----
module Bar;
import Milk from Drinks;
----

(Note that this kind of import also imports the qualified names.)  In this
example, the names `Milk` and `Drinks.Milk` can be used inside the module
`Bar`.

To use all exported names from another module in an unqualified way one can write:

[source]
----
import * from SomeModule;
----

==== Exporting Imported Names

It is possible to export names that have been imported. For example,

[source]
----
module Bar;
export Drink;
import * from Drinks;
----

exports data type `Drink` that has been imported from `Drinks`.

To export all names imported from a certain module one can write

[source]
----
export * from SomeModule;
----

In this case, all names that have been imported from module `SomeModule` are
exported. For example,

[source]
----
module Bar;
export * from Drinks;
import * from Drinks;
----

exports all names that are exported by module `Drinks`.

However, in this example:

[source]
----
module Bar;
export * from Drinks;
import Drink from Drinks;
----

only `Drink` is exported as this is the only name imported from module
`Drinks`.  Note: only names that are visible in a module can be exported by
that module.

To only export some names from a certain module one can write, for example:

[source]
----
module Bar;
export Drink from Drinks;
import * from Drinks;
----

This only exports `Drink` from module `Drinks`.


