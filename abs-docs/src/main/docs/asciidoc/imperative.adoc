
== Statements

This chapter specifies all ABS statements.

[caption=]
.Syntax
====
_Statement_ ::= _CompoundStmt_
| _VarDeclStmt_
| _AssignStmt_
| _CaseStmt_
| _AwaitStmt_
| _SuspendStmt_
| _SkipStmt_
| _AssertStmt_
| _ThrowStmt_
| _ReturnStmt_
| _ExpStmt_ +

_CompoundStmt_ ::= _Block_
| _IfStmt_
| _WhileStmt_
| _TryCatchFinallyStmt_
====


=== Skip

The skip statement is a statement that does nothing.

[caption=]
.Syntax
====
_SkipStmt_ ::= `skip` `;`
====

=== Variable Declarations

A variable declaration statement is used to declare variables.  Variable
declarations can occur at any point in a sequence of statements; i.e., it is
not necessary to declare variables only at the beginning of methods or blocks.

Variables declared inside a block are in scope for the duration of the block.
It is an error to declare a variable with the same name of another variable in
scope.  A local variable can have the same name as an object field.

A variable declaration has an expression that defines the initial value of the
variable.  The initialization expression is mandatory except for variables of
reference types (interfaces and futures), in which case the variable is
initialized with `null` if the initialization expression is omitted.

[caption=]
.Syntax
====
_VarDeclStmt_ ::= _TypeName_ _Identifier_ [ `=` _Exp_ ] `;`
====

[source]
----
Bool b = True;
----


=== Variable Assignment

The assign statement assigns a value to a variable or a field.

Assignments to a field `f` can be written either `this.f = e;` or `f = e;`.
In case a local variable `f` is in scope at the point of the assignment
statement, the `this` prefix has to be used to assign to the field `f`; assignment
to `f` will change the value of the local variable.

[caption=]
.Syntax
====
_AssignStmt_ ::= [ `this` `.` ] _Identifier_ `=` Exp `;`
====

[source]
----
this.f = True;
x = 5;
----


=== Expressions as Statements

An expression statement is a statement that consists of a single expression.
When an expression statement is executed, the expression is evaluated and the
resulting value is discarded.

Expression statements are used for their side effects, for example issuing an
asynchronous method call without waiting for its result.

[caption=]
.Syntax
====
_ExpStmt_ ::= _Exp_ `;`
====

NOTE: Creating an object without storing a reference (and hence never invoking
a method on the new object) can be a meaningful operation, for example when
the object has a `run` method and interacts with the rest of the system by
calling methods on references passed in via the `new` expression.

[source]
----
server!operate();
new Client(server);
----


=== Assertions

An *Assert Statement* is a statement for asserting certain conditions.

[source, java]
----
assert x != null;
----



=== Process Release Point: Await

*Await Statements* suspend the current task until the given guard is true [7]. The task will not be suspended if the guard is already initially true. While the task is suspended, other tasks within the same COG can be activated. Await statements are also called scheduling points, because they are the only source positions, where a task may become suspended and other tasks of the same COG can be activated.


[source, java]
----
Fut<Bool> f = x!m();
await f?;
await this.x == True;
await f? & this.y > 5;
----



=== Unconditional Release: Suspend

A Suspend Statement causes the current task to be suspended.

[source, java]
----
suspend;
----



=== Return

A *Return Statement* defines the return value of a method. A return statement can only appear as a last statement in a method body.

[source, java]
----
return x;
----



=== Blocks of Statements

This statement is also known as a *compound statement* and consists of a group of statement grouped together defining a name scope for variables. 


[source]
----
{
	a = a + 1;
	n = n % 10;
}
----

=== Conditionals

[source, java]
----
if (5 < x) {
	y = 6;
} 
else {
	y = 7;
}
if (True)
	x = 5;
----


=== Case: Pattern Matching

The case statement, like the case expression, takes an expression as first argument, which is
matched against a series of patterns. The effect of executing the case statement is the execution of
the statement (which can be a block) of the first branch whose pattern matches the expression. An example
follows:

[source, java]

----
Pair<Int, Int> p = Pair(2, 3);
Int x = 0;
case p {
  Pair(2, y) => { x = y; skip; }
  _ => x = -1;
}
----



=== The While Loop

[source, java]
----
while (x < 5)
	x = x + 1;
----

=== Throw

The keyword-statement `throw` is used to signal exceptions (runtime errors).
It takes a single argument which is the exception-value to throw. For example:

[source, java]

----
{
 Int x = -1;
 if (x<0) {
    throw NegativeNumberException(x);
 }
 else {
   if (x==0) {
      throw ZeroNumberException;
   }
   else ...
}
----

NOTE: The 'throw' statement can only be used inside imperative code.
Throwing user-exceptions inside functional code is considered bad practice:
the user's function must be written instead to return an +Either<Exception, A>+ value,
as in the example:

----
def Either<Exception, Int> f(x,y) = if (y < 0)
                                    then Left(NegativeNumberException)
                                    else Right(...)
----

Despite this, there are certain built-in system-exceptions (see Section 3.3) that can originate
from erroneous functional code. Examples of these are
`DivisionByZeroException` and `PatternMatchFailException`, implicitly signaled
by the ABS system.

When an exception is raised (signaled), the normal flow of the program will be abrupted. In order to resume
the normal flow, the user has to explicitly *handle* the exception.



=== Handling Exceptions with Try-Catch-Finally

To handle an exception --- either explicitly signaled using the `throw` keyword or implicitly by a system exception ---
the user has to surround the offending code with a `try` block.
The statements in the try block will be executed in sequence until an exception happens.
Upon an exception, the execution of the try block will stop and the exception will be matched against the exception-patterns
defined in the `catch` block.

The catch block behaves similar to the `case statement`, with the only difference that the patterns
can only have the type `Exception`. When the exception-pattern is matched, the statements
associated with its catch clause will be executed. 

After defining the catch block, the user can _optionally_ supply a `finally` block
of statements, that will be executed regardless of an exception happening or not.

The syntax is the following:

[source]
----
try {
 stmt1;
 stmt2;
 ....
}
catch {
  exception_pattern1  => stmt_or_block;
  exception_pattern2  => ... ;
  ...
  _ => ...
}
finally {
  stmt3;
  stmt4;
}
----

If there are no matching catch-clauses,
the finally block will first be accordingly executed,
before re-throwing the exception to its parent caller.
Conversely, if the parent caller does not (correctly) handle the re-thrown exception,
the exception will be propagated to its own parent caller, and so forth and so on.
