= Getting Started

== Lexical Structure

This section describes the lexical structure of the ABS language.

=== Line Terminators and White Spaces

Line terminators and white spaces are defined as in Java.

.Syntax
[subs="verbatim,macros"]
----
pass:quotes[
_LineTerminator_ ::= \n | \r | \r\n
_WhiteSpace_ ::= _LineTerminator_ | ⍽ | \t | _Comment_
]
----

=== Comments
ABS supports the two common Java-style styles of comments: end-of-line comments and block comments.

An end-of-line comment starts with two slashes, e.g., `// text`. All text that follows `//` until the end of the line is treated as a comment.

.Example
[source]
----
// this is a comment
module A; // this is also a comment
----

A block comment is enclosed in `/{asterisk} {asterisk}/`,
e.g., `/{asterisk} this is a comment {asterisk}/`.  Block comments can span
multiple lines and do not nest.

.Example
[source]
----
/* this
is a multiline
comment */
----

.Syntax
[subs="verbatim,macros"]
----
pass:quotes[
_Comment_ ::= _LineComment_ | _BlockComment_
_LineComment_ ::= // (^ _LineTerminator_ )* _LineTerminator_
_BlockComment_ ::= /* (^ \*/ )* */
]
----
(The negation operator `^` in the above has the informal meaning “input not
satisfying the following production rule.”)

=== Identifiers

Identifiers consist of a letter followed by a sequence of letters,
numbers and underscores (`_`).

ABS distinguishes identifiers and type identifiers.  Identifiers start
with a lower-case character, type identifiers start with an upper-case
character.  Identifiers name local variables, fields, methods and functions.
Type identifiers name interfaces, classes, types, type
constructors, deltas and products.

.Syntax
[subs="verbatim,macros"]
----
pass:quotes[_Identifier_ ::= [:lower:] ([:alpha:] | [:digit:] | _)∗]
pass:quotes[_TypeIdentifier_ ::= [:upper:] ([:alpha:] | [:digit:] | _)∗]
----

=== Keywords
The following words are keywords in the ABS language and are invalid as identifiers.

// TODO check and update this list

[format="csv", "ls="7",grid="none"]
|=====
`adds`,`core`,`export`,`hasMethod`,`let`,`product`,`this`
`after`,`class`,`features`,`if`,`local`,`productline`,`type`
`assert`,`data`,`from`,`implements`,`modifies`,`removes`,`when`
`await`,`def`,`get`,`import`,`module`,`return`,`while`
`builtin`,`delta`,`hasField`,`in`,`new`,`skip`,`case`
`else`,`hasInterface`,`interface`,`null`,`suspend`
|=====

=== Literals

A literal is a textual representation of a value. ABS supports three kinds of
literals, integer literals, string literals, and the null literal.

Strings are enclosed in double quotes (`"`).  Line feed in a string is written
as `\n`, carriage return as `\r`.

ABS does not support floating point numbers currently.  Rational numbers are
written using the division operator `/`, e.g., `1/4` for one quarter.

The null literal is written as `null`.

.Syntax
[subs="verbatim,macros"]
----
pass:quotes[_Literal_ ::= _IntLiteral_ | _StringLiteral_ | _ThisLiteral_ | _NullLiteral_]
pass:quotes[_IntLiteral_] ::= 0 | [1-9][0-9]∗
pass:quotes[_StringLiteral_ ::= " _StringCharacter_∗ "
_ThisLiteral_ ::= this
_NullLiteral_ ::= null]
----
Where _StringCharacter_ is defined as in the Java language.

// .Separators
// The following characters are separators:

// [width="60%",cols="9"]
// [frame="topbot",grid="none"]
// |=====
// | ( | ) | { | } | [ | ] | ; | : | , |
// |=====

// .Operators


// The following tokens are operators:

// [format="csv",width="60%",cols="15"]
// [frame="topbot",grid="none"]
// |=====
// ||,&&,==,!=,<,>,<=,>=,+,-,*,/,%,!,&
// |=====

=== Annotations

Annotations consist of a syntactically valid pure expression, optionally
preceded by a type identifier (the “tag”) and a colon (`:`).  They can be put
in front of statements and definitions.

.Syntax
[subs="verbatim,macros"]
----
pass:quotes[_Annotation_] ::= [ [pass:quotes[_TypeIdentifier_] :] pass:quotes[PureExp] ]
----

Annotations are used to write auxiliary information that can be used by
various tools.  Unknown (user-defined) annotations are ignored by the
toolchain.  Pre-defined annotations are usually type-checked.

.Example
[source]
----
[Near] class Example { ... }
----

This is an example of an annotation with a tag:

.Example
[source]
----
[Cost: 15] skip;
----

Annotations are associated with the following language construct.  In the
examples above, the first annotation pertains to the class definition of
`Example`, the second annotation pertains to the `skip` statement.

There can be more than one annotation in one place.

In general, it is not an error to have more than one annotation with the same
tag in the same place.  However, some pre-defined annotations might forbid
this.

== Types

ABS has a static, nominal type system.  Local variables, object fields,
function parameters and method parameters are statically typed.  A type name
can refer to a algebraic data type, an interface, a type synonym.  There are a
number of pre-defined data types which are documented in Chapter <<The
Standard Library>>.

A _type name_ is a sequence of letters, digits and  underscores (`_`) starting
with an uppercase letter.  In case of a parametric data type, the type name
continues with a left angle (`<`), a list of type names separated by commas
and ends with a right angle (`>`).

New types are defined as either _interfaces_ or _algebraic data types_.
Algebraic data types can be _parametric_, which is useful for defining
“container-like” data types.  Currently only algebraic data types can be
parameterized, i.e., ABS does not currently offer class templates.

Note that classes are not types in ABS.

.Example
[source]
----
String <1>
A_s1mple_type <2>
Map<Int, List<String>> <3>
----
<1> The type name is `String`.  The string type is defined in the standard library.
<2> This is a type name containing underscores and digits.
<3> This type name denotes a map from integers to lists of strings.


=== Built-in Types

ABS offers the following built-in datatypes:

.ABS built-in types
[options="header"]
|=====
| Name | Descrition | Example
| `Unit` | The empty (void) type | `Unit`
| `Bool` | Boolean values | `True`, `False`
| `Int` | Integers of arbitrary size | `0`, `-15`
| `Rat` | Rational numbers | `1/5`, `22/58775`
| `String` | Strings | `"Hello world\n"`
| `Fut<A>` | Futures | --
|=====

`Int` type is a subtype of `Rat`; this means that `Int` values are assignable
to places of type `Rat`.  Rational values can be converted to integers via the
`truncate` function.

The future type `Fut<A>` is a special built-in type that denotes that an ABS
value of type `A` will become available in the future.  The value that a
future holds and will return can be of any concrete type.

.Example
[source]
----
Fut<String> <1>
Fut<List<Rat>> <2>
----
<1> This future will contain a value of type `String`
<2> This future will contain a list of rational numbers


=== Algebraic Data Types

Algebraic Data Types in ABS are used to implement user-defined, immutable data
values.  Because values of algebraic data types are immutable, they can be
safely passed on to other objects and cogs and make it easy to reason about
program correctness.

.Syntax
[subs="verbatim,macros"]
----
pass:quotes[_DataTypeDecl_] ::= data pass:quotes[_TypeId_] [pass:quotes[_TypeParams_]] [= pass:quotes[_DataConstrList_]] ;
pass:quotes[_TypeParams_] ::= < pass:quotes[_TypeId_] (, pass:quotes[_TypeId_])∗ >
pass:quotes[_DataConstrList_] ::= pass:quotes[_DataConstr_] (| pass:quotes[_DataConstr_])∗
pass:quotes[_DataConstr_] ::= pass:quotes[_TypeId_] [( [pass:quotes[_TypeList_]] )]
----

Data Type _Constructors_ enumerate the possible values of a data type.
Constructors can have zero or more arguments.

.Example
[source]
----
data IntList = NoInt | ConsInt(Int, IntList); <1>
data Bool = True | False; <2>
----
<1> The data type `IntList` has two constructors: `NoInt` and `ConsInt`.
<2> This is the definition of the built-in data type `Bool`.

==== Accessor Functions

Data constructor arguments can optionally have a name, which needs to be a
valid identifier.  If a name is given, it defines a function that, when passed a
value expressed with the given constructor, return the argument.

The name of an accessor function must be unique in the module it is
defined in.  It is an error to have multiple accessor functions with the same
name, or to have a function definition with the same name as an accessor
function.

.Example
[source]
----
data Person = Person(String name, Int age);
{
  Person john = Person("John", 34);
  Int age = age(john); <1>
}
----
<1> The call to `age` returns 34.


==== Parametric Data Types

Algebraic data types can carry _type parameters_.  Data types with type
parameters are called _parametric data types_.

Parametric Data Types are useful to define “container” data types, such as
lists, sets or maps. Parametric data types are declared like normal data types
but have an additional type parameter section inside broken brackets (`<` `>`)
after the data type name.

.Example
[source]
----
data List<A> = Nil | Cons(A, List<A>);
----

When using a parametric data type, concrete types are given for the type parameters.

.Example
[source]
----
List<Int> l = Cons(1, Cons(2, Nil));
----


==== N-ary Constructors

Literal values of recursive data types like lists and sets can be arbitrarily
long, and nested constructor expressions can become unwieldy.  ABS provides a
special syntax for n-ary constructors, which are transformed into constructor
expressions via a user-supplied function.

.Example
[source]
----
def Set<A> set<A>(List<A> l) = <1>
    case l {
       Nil => EmptySet;
       Cons(x,xs) => insertElement(set(xs), x);
    };

{
  Set<Int> s1 = set(Cons(1, Cons(2, Cons(3, Nil)))); <2>
  Set<Int> s = set[1, 2, 3]; <3>
}
----
<1> The parametric function `set` is defined to take a list of elements and return a set.
<2> `set` is called with a literal list constructed as normal.
<3> `set` is called with the special n-ary constructor syntax.  The two calls return the same value.

The constructor function usually has the same name as the type it is
constructing.  For example, a value of type `Set` is constructed via the
function `set`.


==== Fully Abstract Data Types

Using the module system it is possible to define abstract data types.  For an
abstract data type, only the functions that operate on them are known to the
client, but not its constructors.  This can be easily realized in ABS by
putting such a data type in its own module and by only exporting the data type
and its functions, without exporting the constructors.


=== The Exception Type

In higher-level programming languages, exceptions are generally used to signal an _erroneous_ or _abnormal_
runtime behaviour of the program, that should be treated (handled) separately compared to normal values.

The Exception type is a special built-in data type that looks similar to an Algebraic Data Type (immutable, no identity) 
but with a notable difference: the exception data type *can* be extended
with new (user-provided) data constructors. Based on this fact,
the user has the ability to, besides using the predefined exceptions of the ABS standard library,
write arbitrary exceptions specific to the user's program.

To define a new exception (data constructor) the user has to write:

.Example
[source, java]
----
exception MyException;
----

An exception can also take any number of arguments as:

.Example
[source, java]
----
exception AnotherException(Int, String, Bool);
----

In ABS, exceptions are first-class citizens of the language;
the user can construct exception-values, assign them to variables or pass them in expressions.
All these exception-values are typed by the type +Exception+ . 
However, an exception-value can only acquire the special meaning of abnormal behaviour
when the user explicitly says so with a +throw+ keyword. We will visit the +throw+ keyword
together with how to recover from exceptions (+catch+ keyword) in a later section.

==== Predefined exceptions in the Standard Library

DivisionByZeroException::
    Raised in arithmetic expressions when the divisor (denominator) is equal to 0, as in +3/0+
AssertionFaiException::
    The assert keyword was called with +False+ as argument
PatternMatchFailException::
    The pattern matching was not complete. In other words all c catch-all clause
NullPointerException::
    A method was called on a null object
StackOverflowException::
    The calling stack has reached its limit (system error)
HeapOverflowException::
    The memory heap is full (system error)
KeyboardInterruptException::
    The user pressed a key sequence to interrupt the running ABS program


=== Interface Types

Interfaces in ABS describe the functionality of objects.  Thus, Interfaces in
ABS are similar to interfaces in Java.  Unlike Java, objects are only typed by
interfaces and not by their class.

The syntax of interfaces is explained in <<Interfaces>>.

=== Type Synonyms

A _Type Synonym_ is an alternative type name for a type.  Type synonyms are
introduced with the keyword `type`.  Parametric type synonyms are not
currently supported.

.Syntax
[subs="verbatim,macros"]
----
pass:quotes[
_TypeSynDecl_ ::= type _TypeIdentifier_ = _TypeName_ ;]
----

.Example
[source]
----
type Filename = String;
type Filenames = Set<Filename>;
type Servername = String;
type Packet = String;
type File = List<Packet>;
type Catalog = List<Pair<Servername,Filenames>>;
----
