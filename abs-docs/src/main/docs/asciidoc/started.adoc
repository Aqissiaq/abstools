= Getting Started

== Lexical Structure

This section describes the lexical structure of the ABS language. ABS programs are written in Unicode.

.Line Terminators and White Spaces

Line terminators and white spaces are defined as in Java.

.Comments
Comments are code fragments that are completely ignored and have no semantics in the ABS language. ABS supports two styles of comments: end-of-line comments and traditional comments.

.End-Of-Line Comments

An end-of-line comment is a code fragment that starts with two slashes, e.g., `//` text. All text that follows `//` until the end of the line is treated as a comment.

.Syntax

[source]
----
// this is a comment
module A; // this is also a comment
----

.Traditional Comments
A traditional comment is a code fragment that is enclosed in `/{asterisk} {asterisk}/`, e.g., `/{asterisk} this is a comment {asterisk}/`. Nested traditional comments are not possible.

[source]
----
/* this
is a multiline
comment */

----

.Identifiers

Identifiers consist of a letter followed by a sequence of letters,
numbers and underscores (`_`).

ABS distinguishes identifiers and type identifiers.  Identifiers start
with a lower-case character, type identifiers start with an upper-case
character.  Identifiers name local variables, fields and functions.
Type identifiers name interfaces, classes, types and type
constructors.

.Keywords
The following words are keywords in the ABS language and are not regarded as identifiers.

[options= "header, footer",format="csv", "ls="7",grid="none"]
|=====

adds,core,export,hasMethod,let,product,this
after,class,features,if,local,productline,type
assert,data,from,implements,modifies,removes,when
await,def,get,import,module,return,while
builtin,delta,hasField,in,new,skip,case
else,hasInterface,interface,null,suspend

|=====

.Literals
A literal is a textual representation of a value. ABS supports three kinds of literals, integer literals, string literals, and the null literal.

.Separators
The following characters are separators:

[format="csv",width="60%",cols="9"]
[frame="topbot",grid="none"]
|=====
(,),{,},[,],\,,\;,:
|=====

.Operators


The following tokens are operators:

[format="csv",width="60%",cols="15"]
[frame="topbot",grid="none"]
|=====
||,&&,==,!=,<,>,<=,>=,+,-,*,/,%,!,&
|=====

.Annotations

Annotations consist of a type identifier, optionally followed by a
colon (`:`) and a syntactically valid pure expression.  They can be
put in front of statements and definitions.

Unknown annotations are ignored by the toolchain.

[source]
----
[Near] class Example { ... }
----

This is an example of an annotation with an expression:

[source]
----
[Cost: 15] skip;
----


== Names and Types

.Names
A name in ABS can either be a simple identifier as described above, or can be qualified with a type name, which represents a module. Examples for syntactically valid names are: head, x, ABS.StdLib.tail. Examples for type names are: Unit, X, ABS.StdLib.Map.

.Types
Types in ABS are either plain type names or can have type arguments. A type name can refer to a data type, an interface, a type synonym, and a type parameter. Note that classes cannot be used as types in ABS. In addition, only parametric data types can have type arguments. Examples for syntactically valid types are: Bool, ABS.StdLib.Int, List<Bool>, ABS.StdLib.Map<Int,Bool>.

.Type Synonyms
Type Synonyms define synonyms for otherwise defined types. Type synonyms start with an uppercase letter.

.Syntax

[source]
----
type Filename = String;
type Filenames = Set<Filename>;
type Servername = String;
type Packet = String;
type File = List<Packet>;
type Catalog = List<Pair<Servername,Filenames>>;

----

=== Built-in Types

The most basic of built-in types is the +Int+ type, which represents integers of arbitrary size.
Values of type +Int+ can be constructed by using integer
literals or arithmetic expressions: 

----
0  has type Int
1  has type Int
3  has type Int
3+1  has type Int
----

A related type is the +Rat+ for representing rational numbers.
Rational values are obtained via the division (/) operator and have arbitrary precision.
An example of such values:

----
1/4   has type Rat
5/2/4 has type Rat
----

The +Int+ type is a subtype of +Rat+; this means that
+Int+ expressions are automatically converted to +Rat+ expressions,
whenever a +Rat+ type is expected. Some examples of +Rat+ expressions:

----
0 can also have type Rat
1 can also have type Rat
4+3 can also have the Rat
----

[NOTE]
The adverse does not work. Users that want to convert from
+Rat+ to +Int+ types have to explicitly use the +truncate(number)+ function.


The +String+ built-in type represents String values, constructed either by string literals
or by string-specific operators coming from the ABS standard library. Examples
of Strings:

----
"hello world\n"  is a string literal
"standard" + "library" is a string expression (concatenation)
----

[NOTE]
According to other functional languages, Strings in ABS are immutable data.
Dissimilar to other function languages, ABS Strings are not represented as list of
characters; instead they have a hidden-to-the-user, efficient, internal representation.


The +Fut+ type is a special built-in type to signal an ABS value that will become
available (evaluated) in the future. +Fut+ is a so-called parameterized type, 
written as +Fut<T>+, where T is its type parameter. The value that a future
holds and will return can be of any concrete type, as in the example: 

----
Fut<String> is the type that will return a string
Fut<List<Rat>> is the type that will return a list of rational numbers
----

=== Algebraic Data Types

Algebraic Data Types make it possible to describe data in an immutable way. In contrast to objects, data types do not have an identity and cannot be mutated. This makes reasoning about data types much simpler than about objects. Data types are built by using Data Type Constructors (or constructors for short), which describe the possible values of a data type.

.Syntax
[source]
----
data IntList = NoInt | Cons(Int, IntList);
data Bool = True | False;
----

.Parametric Data Types
Parametric Data Types are useful to define general-purpose data types, such as lists, sets or maps. Parametric data types are declared like normal data types but have an additional type parameter section inside broken brackets (< >) after the data type name.

----
data List<A> = Nil | Cons(A, List<A>);
----

.Predefined Algebraic Data Types

The following Algebraic Data Types are predefined and come bundled with the ABS standard library:

* `data Bool = True | False;` The boolean type with constructors True and False and the usual Boolean infix and prefix operators. 
* `data Unit = Unit;` The unit type with only one constructor Unit (for methods without return values).
* `data Int;` An arbitrary integer (Z) for which values are constructed by using integer literals and arithmetic expressions.
* `data Rat;`. A rational number (Q). Rational values are obtained via the division (/) operator and have arbitrary precision. Assigning rational values to variables of type Int, either explicitly or implicitly by passing them to a function or method expecting an integer, rounds towards zero.
* `data String;`. A string for which values are constructed by using string literals and operators.
* `data Fut<T>;`. Representing a future. A future cannot be explicitly constructed, but it is the result of an asynchronous method call. The value of a future can only be obtained by using the get expression.
* `data List<A> = Nil | Cons(A, List<A>)` where Nil is the empty list, and Cons appends an element of type A in the front of the list.

.N-ary Constructors
For data types of arbitrary size, like lists, maps and sets, it is undesirable having to write them down in the form of nested constructor expressions. For this purpose, ABS provides a special syntax for nary constructors, which are transformed into constructor expressions via a user-supplied function.Â·

.Syntax
[source]
----
def Set<A> set<A>(List<A> l) = case l {
    Nil => EmptySet;
    Cons(hd, tl) => Insert(hd, set(tl));
    };

{
Set<Int> s = set[1, 2, 3];
}
----

An expression type[parameters*] is transformed into a literal by handing it to a function named type which takes one parameter of type List and returns an expression of type Type. (It is desirable, although not currently enforced, that type and Type are the same word, just with different capitalization.)


.Abstract Data Types
Using the module system it is possible to define abstract data types. For an abstract data type, only the functions that operate on them are known to the client, but not its constructors.
This can be easily realized in ABS by putting such a data type in its own module and by only exporting the data type and its functions, without exporting the constructors.


=== The Exception Type

In higher-level programming languages, exceptions are generally used to signal an _erroneous_ or _abnormal_
runtime behaviour of the program, that should be treated (handled) separately compared to normal values.

The Exception type is a special built-in data type that looks similar to an Algebraic Data Type (immutable, no identity) 
but with a notable difference: the exception data type *can* be extended
with new (user-provided) data constructors. Based on this fact,
the user has the ability to, besides using the predefined exceptions of the ABS standard library,
write arbitrary exceptions specific to the user's program.

To define a new exception (data constructor) the user has to write:

[source, java]

----
exception MyException;
----

An exception can also take any number of arguments as:

[source, java]

----
exception AnotherException(Int, String, Bool);
----

In ABS, exceptions are first-class citizens of the language;
the user can construct exception-values, assign them to variables or pass them in expressions.
All these exception-values are typed by the type +Exception+ . 
However, an exception-value can only acquire the special meaning of abnormal behaviour
when the user explicitly says so with a +throw+ keyword. We will visit the +throw+ keyword
together with how to recover from exceptions (+catch+ keyword) in a later section.

.Predefined exceptions in the Standard Library

DivisionByZeroException::
    Raised in arithmetic expressions when the divisor (denominator) is equal to 0, as in +3/0+
AssertionFaiException::
    The assert keyword was called with +False+ as argument
PatternMatchFailException::
    The pattern matching was not complete. In other words all c catch-all clause
NullPointerException::
    A method was called on a null object
StackOverflowException::
    The calling stack has reached its limit (system error)
HeapOverflowException::
    The memory heap is full (system error)
KeyboardInterruptException::
    The user pressed a key sequence to interrupt the running ABS program


=== Interface Types

Interfaces in ABS are similar to interfaces in Java. Unlike Java,
objects in ABS are typed exclusively by interfaces, and *not* classes.

To introduce an interface:

[source, java]

----
interface Animal {
...
}
----

Interfaces can be extended from (multiple) base interfaces: 

[source, java]

----
interface Bird extends Animal, Flying {
...
}
----

Let's consider the example of an object that represents a "seagull". Such
_seagull_ object can have either the type of a +Bird+, +Animal+ or +Flying+,
depending on the object's particular usage in the program. In terms of type theory, this feature is called 
__nominal subtyping__. An example of well-typed expressions that make use of Interface types:

----
seagull                     can be typed by: Bird or Animal or Flying
list[seagull, bee]          can be typed by: Animal or Flying
set[seagull, bee, boeing]   can be typed by: Flying
----


