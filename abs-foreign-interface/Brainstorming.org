* Preamble
** Authors
  - Jan Schaefer <jschaefer@cs.uni-kl.de>
** Summary
  This document contains first ideas of how to
  connect ABS to foreign languages.

* Introcuction
ABS should be able to interact with other foreign languages (FLs) like
Java to be able to write critical components of a system
in ABS. 

As FLs we mainly consider Java, but further
options are:
 
 - Maude, Scala, and Erlang

** Main questions
There are essentially two questions to answer:

 1. How to use FLs from ABS
 2. How to use ABS from Fls

* Possible Solutions
** Deep Integration (the Scala way)
   one would do a deep integration of Java and treat
   Java packages as Modules. For example:
   
   import * from java.lang;

   {
      Double d = new Double();
   }

   
*** Advantages
    Easy use for ABS to access the Java libraries

*** Disadvantages
    - Tightly coupled to Java
    - Not possible to extend this approach to other languages, e.g. Erlang/C ...
    - Difficult to implement (type-checking)

** Loose Integration (the JNI way)
   Use an approach that is similar to JNI.
   I.e., define interfaces/methods/classes as *foreign*
   Provide an implementation for these interfaces
   in the target language
*** Advantages
    - loose coupling
    - independent of actual language


*** Foreign ABS Classes/Functions
    Idea: classes and functions can be declared to be
    Foreign, either by using an annotations, or by using
    some keyword.

    module Test;

    def Int random() = foreign;

    interface Output {
       Unit println();
    }

    [Foreign]
    class OuputImpl implements Output { }

*** How to link Java code to ABS interfaces/classes/functions

**** Use Conventions
     For example, by having a special naming theme,
     e.g. a Java class with the same name as the corresponding
     ABS class.

     Example:
     
     ABS:

     module Foo;
     interface Baz { }
     [Foreign] class Bar implements Baz { }

     Java:

     package Foo;
     public class Bar {
     
     }

***** Discussion
      Using conventions has the disadvantage that it is
      not very flexible. In particular, if classes have to be put
      in the same package as the generated ABS classes this could
      lead to name clashes.
      
**** Use Annotations
     Use annotations on the Java level to connect
     Java code to ABS.

     Example:
     
     ABS:

     module Foo;
     interface Baz { 
        Unit print(String s);
     }
     
     [Foreign] 
     class Bar implements Baz { }

     Java:

     package foo;

     @AbsClass{"Foo.Bar"}
     public class Bar {
        ABSUnit print(ABSString s2) {
	   System.out.println(s2.toString());
	}
     }


*** Possible Java Code

    package Test;
    import abs.backend.java.afi.*;

    // function definitions are put in a 
    // class named "Def" and must be static
    @AbsDef{"Test.random"}
    public static ABSInt random() {
       return new Random().nextInt();
     }

    public class OutputImpl {
       public ABSUnit println(ABSString s) {
	  System.out.println(s.toString());
       }
    }

