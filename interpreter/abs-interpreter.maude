***
*** An ABS interpreter on the Maude platform
***
*** Copyright (c) 2010 Rudolf Schlatte
*** 
*** Based upon `creol-interpreter.maude' by Marcel Kyas, Olaf Owe, Einar Broch
*** Johnsen, which was generated from interpreter.m4, Copyright (c) 2007, 2008
*** Marcel Kyas
***
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 3 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program.  If not, see <http://www.gnu.org/licenses/>.
***



*** The basic concepts of Abs's data type.
***
fmod ABS-DATA-SIG is

  sorts Expr Data .
  subsort Data < Expr .

  op null : -> Data [ctor format (! o)] .

  sorts   NeExprList ExprList NeDataList DataList .
  subsort Expr < NeExprList < ExprList .
  subsort Data < NeDataList < DataList .
  subsort DataList < ExprList .
  subsort NeDataList < NeExprList .

  op emp : -> DataList [ctor] .

  op _::_ : ExprList ExprList -> ExprList
    [ctor assoc id: emp prec 27 format (d r os d)] .
  op _::_ : NeExprList ExprList -> NeExprList [ctor ditto] .
  op _::_ : ExprList NeExprList -> NeExprList [ctor ditto] .
  op _::_ : DataList DataList  -> DataList [ctor ditto] .
  op _::_ : NeDataList DataList  -> NeDataList [ctor ditto] .
  op _::_ : DataList NeDataList  -> NeDataList [ctor ditto] .

endfm

view Data from TRIV to ABS-DATA-SIG is
  sort Elt to Data .
endv

view Expr from TRIV to ABS-DATA-SIG is
  sort Elt to Expr .
endv


fmod ABS-DATA-VID is
  extending ABS-DATA-SIG .
  protecting STRING .

  sort Vid .
  subsort Vid < Expr .

  *** Variable references
  op @_ : String -> Vid [ctor] .
  *** Instance variable references

  op @@_ : String -> Vid [ctor] .
endfm

view Vid from TRIV to ABS-DATA-VID is
  sort Elt to Vid .
endv

fmod ABS-DATA-VIDLIST is
  protecting LIST{Vid} * (sort List{Vid} to VidList,
                          sort NeList{Vid} to NeVidList,
                          op nil : -> List{Vid} to noVid,
                          op __ : List{Vid} List{Vid} -> List{Vid} to _`,_ [format (d r os d)]) .
endfm


*** The interpreter should extend this module with his own definition
*** of label values.  For example, the model checker uses his own version
*** of labels.  This definition is the one used in the interpreter.
*** op label : Nat -> Label [ctor] .
fmod ABS-DATA-LABEL is

  extending ABS-DATA-SIG .

  sort Label .
  subsort Label < Data .

  --- Needed in the model checker for tail recursion.
  op tag : Label -> Label [ctor format (c o)] .
  var L : Label .
  eq tag(tag(L)) = L .

endfm

view Label from TRIV to ABS-DATA-LABEL is
  sort Elt to Label .
endv



*** Specification of all Abs expressions.  This is the abstract syntax.
*** Semantics will be provided by the different modules.
***
fmod ABS-EXPRESSION is

  protecting ABS-DATA-VIDLIST .
  protecting ABS-DATA-SIG .
  protecting STRING .

  sorts CaseBranch CaseBranchList .
  subsort CaseBranch < CaseBranchList .
  *** KLUDGE (rs 2010-04-20) Only certain kinds of expressions can be used as
  *** pattern: literals and variable references.  We should introduce a sort
  *** `Pattern' and use it.  For now, we rely on the compiler to only produce
  *** valid pattern expressions.
  op _=>_ : Expr Expr -> CaseBranch [prec 39] .
  op _;_ : CaseBranchList CaseBranchList -> CaseBranchList
    [ctor assoc id: noBranch format (d b os d)] .
  op noBranch : -> CaseBranch .

  *** function application
  op _(_) : String ExprList -> Expr [ctor prec 12 format (! o d d d)] .
  op _(_) : String DataList -> Data [ctor prec 12 format (! o d d d)] .
  *** constructor terms
  op _[_] : String ExprList -> Expr [ctor prec 12 format (! o d d d)] .
  op _[_] : String DataList -> Data [ctor prec 12 format (! o d d d)] .
  *** conditional
  op if_th_el_fi : Expr Expr Expr -> Expr [ctor] .
  *** case expression
  op case_of {_} : Expr CaseBranchList -> Expr [ctor] .
  *** let expression
  op let_=_in_ : VidList ExprList Expr -> Expr [ctor] .
  *** guard expression
  op ?(_)  : Expr -> Expr [ctor format (! o d d d)] .

endfm

*** Specification of the Bool datatype.
***
fmod ABS-DATA-BOOL is

  protecting ABS-EXPRESSION .

  vars B B' : Bool .
  vars D D' : Data .
  vars E : Expr .

  
  op _asBool : Data -> Bool .
  eq "True"[ emp ] asBool = true .
  eq "False"[ emp] asBool = false .
  op _asAbsBool : Bool -> Data .
  eq true asAbsBool = "True"[ emp ] .
  eq false asAbsBool = "False"[ emp ] .

  eq "=" (D :: D') = (D == D') asAbsBool .
  eq "/=" (D :: D') = (D =/= D') asAbsBool .

  eq "~"(D) = (not (D asBool)) asAbsBool .
  eq "&&"("False"[ emp ] :: E) = "False"[ emp ] .
  eq "&&"("True"[ emp ] ::  E) = E .
  eq "||"("True"[ emp ] :: E) = "True"[ emp ] .
  eq "||"("False"[ emp ] :: E) = E .
  eq "=>"("True"[ emp ] :: E) = E .
  eq "=>"("False"[ emp ] :: E) = "True"[ emp ] .
  eq "^"(D :: D') = ((D asBool) xor (D' asBool)) asAbsBool .
  eq "<=>"(D :: D') = ((D asBool) == (D' asBool)) asAbsBool .

endfm



*** Specification of floats and functions on floats.
***
fmod ABS-DATA-FLOAT is
  extending ABS-DATA-BOOL .
  protecting FLOAT .

  op _[_] : String Float -> Data [ctor prec 12 format (! o d d d)] .

  vars F F' : Float .

  op _asFloat : Data -> Float .
  eq "float"[F] asFloat = F .

  eq "-" ("float"[F]) = "float"[-(F)] .
  eq "+" ("float"[F] :: "float"[F']) = "float"[F + F'] .
  eq "-" ("float"[F] :: "float"[F']) = "float"[ _-_(F, F')] .
  eq "*" ("float"[F] :: "float"[F']) = "float"[F * F'] .
  eq "/" ("float"[F] :: "float"[F']) = "float"[F / F'] .
  eq "%" ("float"[F] :: "float"[F']) = "float"[F rem F'] .
  eq "**" ("float"[F] :: "float"[F']) = "float"[F ^ F'] .

  eq "<"  ("float"[F] :: "float"[F']) = (F < F') asAbsBool .
  eq "<=" ("float"[F] :: "float"[F']) = (F <= F') asAbsBool .
  eq ">"  ("float"[F] :: "float"[F']) = (F > F') asAbsBool .
  eq ">=" ("float"[F] :: "float"[F']) = (F >= F') asAbsBool .

endfm



*** Specification of integers and functions on integers.
***
fmod ABS-DATA-INT is
  extending ABS-DATA-FLOAT .

  protecting INT .
  protecting RANDOM .
  protecting CONVERSION .

  op _[_] : String Int -> Data [ctor prec 12 format (! o d d d)] .

  vars I I' : Int .
  var N : Nat .

  op _asInt : Data -> Int .
  eq "int"[I] asInt = I .

  op _asNat : Data -> Nat .
  eq "int"[N] asNat = N .

  eq "-" ("int"[I]) = "int"[-(I)] .
  eq "+" ("int"[I] :: "int"[I']) = "int"[I + I'] .
  eq "-" ("int"[I] :: "int"[I']) = "int"[ _-_(I, I')] .
  eq "*" ("int"[I] :: "int"[I']) = "int"[I * I'] .
  eq "/" ("int"[I] :: "int"[I']) = "int"[I quo I'] .
  eq "div" ("int"[I] :: "int"[I']) = "int"[I quo I'] .
  eq "%" ("int"[I] :: "int"[I']) = "int"[I rem I'] .
  eq "**" ("int"[I] :: "int"[I']) = "int"[I ^ I'] .
  eq "random" ("int"[I]) = "int"[random(I)] .
  eq "real_of_int" ("int"[I]) = "float"[float(I)] .

  eq "<"  ("int"[I] :: "int"[I']) = (I < I') asAbsBool .
  eq "<=" ("int"[I] :: "int"[I']) = (I <= I') asAbsBool .
  eq ">"  ("int"[I] :: "int"[I']) = (I > I') asAbsBool .
  eq ">=" ("int"[I] :: "int"[I']) = (I >= I') asAbsBool .

endfm



*** Specification of strings and functions on strings.
***
fmod ABS-DATA-STRING is
  extending ABS-DATA-INT .

  protecting STRING .

  op _[_] : String String -> Data [ctor prec 12 format (! o d d d)] .

  vars S S' : String .
  vars M N : Nat .

  op _asString : Data -> String .
  eq "str"[S] asString = S .

  eq "|-" ("str"[S] :: "str"[S']) = "str"[S + S'] .
  eq "-|" ("str"[S] :: "str"[S']) = "str"[S + S'] .
  eq "|-|" ("str"[S] :: "str"[S']) = "str"[S + S'] .
  eq "#" ("str"[S]) = "int"[length(S)] .
  eq "ascii" ("str"[S]) = "int"[ascii(S)] .
  eq "char" ("int"[N]) = "str"[char(N)] .
  eq "substr" ("str"[S] :: "int"[M] :: "int"[N]) = "str"[substr(S, M, N)] .
  eq "find" ("str"[S] :: "str"[S'] :: "int"[N]) = "int"[find(S, S', N)] .
  eq "rfind" ("str"[S] :: "str"[S'] :: "int"[N]) = "int"[rfind(S, S', N)] .

  eq "<" ("str"[S]:: "str"[S']) = (S < S') asAbsBool .
  eq "<=" ("str"[S]:: "str"[S']) = (S <= S') asAbsBool .
  eq ">" ("str"[S]:: "str"[S']) = (S > S') asAbsBool .
  eq ">=" ("str"[S]:: "str"[S']) = (S >= S') asAbsBool .


  --- Conversions.  Since Abs does not support rational numbers yet,
  --- we may have failures here which will remain unchecked.
  protecting CONVERSION .
  var I : Int .
  var F : Float .

  eq "string_of_int" ("int"[I]) = "str"[string(I, 10)] .
  eq "int_of_string" ("str"[S]) = "int"[rat(S, 10)] .
  eq "string_of_real" ("float"[F]) = "str"[string(F)] .
  eq "real_of_string" ("str"[S]) = "float"[float(S)] .

endfm



*** Specification of lists and functions on lists.
***
fmod ABS-DATA-LIST is
  extending ABS-DATA-INT .

  op list(_) : ExprList -> Expr [ctor format (o d ! o d)] .
  op list(_) : DataList -> Data [ctor ditto] .

  vars M N : Nat .
  vars I J K : Int .
  vars D D' : Data .
  vars L L' : DataList .

  --- list-functions
  eq "head" (list(emp)) = null .
  eq "head" (list(D :: L)) = D .

  eq "tail" (list(emp)) = null .
  eq "tail" (list(D :: L)) = list(L) .

  eq "last" (list(emp)) = null .
  eq "last" (list(L :: D)) = D .

  eq "rest" (list(emp)) = null .
  eq "rest" (list(L :: D)) = list(L) .

  eq "nth" ((list(L)) :: "int"[0]) = null .
  eq "nth" ((list(emp)) :: "int"[N]) = null .
  eq "nth" ((list(D :: L)) :: "int"[N]) =
  if (N == 1) then D else "nth" (list(L) :: "int"[_-_(N, 1)]) fi .

  eq "rnth" (list(L) :: "int"[N]) = "nth" ("reverse" (list(L)) :: "int"[N]) .

  eq "in" (D :: list(emp)) = "False"[ emp ] .
  eq "in" (D' :: list(D :: L)) =
  if D == D' then "True"[ emp ] else "in" (D' :: list(L)) fi .

  eq "remove" (list(emp) :: D) = list(emp) .
  eq "remove" (list(D :: L) :: D') =
    if D == D'
    then "remove" ((list(L)):: D') 
    else "|-|" (list(D) :: ("remove" (list(L) :: D'))) fi .

  eq "-|" (D :: list(L)) = list(D :: L) .
  eq "|-" (list(L) :: D) = list(L :: D) .
  eq "|-|" (list(L) :: list(L'))   = list(L :: L') .

  eq "#" (list(emp)) = "int"[0] .
  eq "#" (list(D :: L)) = "+" ("#" (list(L)) :: "int"[1]) .
  
  eq "isempty" (list(emp)) = "True"[ emp ] .
  eq "isempty" (list(L :: D)) = "False"[ emp ] .

  --- Reverse a list
  eq "reverse" (list(emp)) = list (emp) .
  eq "reverse" (list(D :: L)) = "|-" ("reverse" (list(L)) :: D) .

  --- index starts at 1
  eq "after" (list(emp) :: "int"[N]) = null . 
  eq "after" (list(L) :: "int"[0]) = list(L) .
  eq "after" (list(D :: L) :: "int"[N]) = "after" (list(L) :: "int"[_-_(N, 1)]) .

  --- Compute a slice of a sequence.
  eq "sub" (list(L) :: "int"[N] :: "int"[M]) =
    ".sub" (list(L) :: "int"[N] :: "int"[M] :: list(emp)) .
  ceq ".sub" (list(D :: L) :: "int"[N] :: "int"[M] :: list(L')) =
    ".sub" (list(L) :: "int"[_-_(N, 1)] :: "int"[_-_(M, 1)] :: list(L'))
  if N > 1 .
  ceq ".sub" (list(D :: L) :: "int"[1] :: "int"[M] :: list(L')) =
    ".sub" (list(L) :: "int"[1] :: "int"[_-_(M, 1)] :: list(L' :: D))
  if M >= 1 .
  eq ".sub" (list(L) :: "int"[1] :: "int"[0] :: list(L')) = list(L') .

  eq "begwith" (list(emp) :: list(L :: D)) = "False"[ emp ] .
  eq "begwith" (list(L) :: list(emp)) = "True"[ emp ] .
  eq "begwith" (list(D :: L) :: list(D' :: L')) =
    if D == D' then "begwith" (list(L) :: list(L')) else "False"[ emp ] fi .

  eq "endswith" (list(emp) :: list(L :: D)) = "False"[ emp ] .
  eq "endswith" (list(L) :: list(emp)) = "True"[ emp ] .
  eq "endswith" (list(L :: D) :: list(L' :: D')) =
    if D == D' then "endswith" (list(L) :: list(L')) else "False"[ emp ] fi .

  --- If E is not in the list, these will fail with the term
  --- "+" ("int"[N] :: null)
  eq "index" (list(emp) :: D) = null .
  eq "index" (list(D :: L) :: D') =
    if D == D' then "int"[1] else "+" ("int"[1] :: "index" (list(L) :: D')) fi .

  --- If E is not in the list, these will fail with the term
  --- "-" ("int"[N] :: null)
  eq "rindex" (list(L) :: D) =
    "-" ("#" (list(L)) :: ".rindex" (list(L) :: D)) .
  eq ".rindex" (list(emp) :: D') = null .
  eq ".rindex" (list(L :: D) :: D') =
    if D == D' then "int"[1] else "+" ("int"[1] :: "rindex" (list(L) :: D')) fi .

  eq "replace" (list(emp) :: D :: "int"[N]) = null .
  eq "replace" (list(L) :: D :: "int"[0]) = null .
  eq "replace" (list(D :: L) :: D' :: "int"[1]) = list(D' :: L) .
  ceq "replace" (list(D :: L) :: D' :: "int"[N]) =
    "-|"(D :: "replace" (list(L) :: D' :: "int"[_-_(N, 1)])) if N > 1 .

  eq "make_list" (D :: "int"[0]) = list(emp) .
  ceq "make_list" (D :: "int"[N]) = "|-"("make_list" (D :: "int"[_-_(N, 1)]) :: D)
  if N > 0 .

  eq "make_range" ("int"[I]) = "make_range" ("int"[1] :: "int"[I]) .

  eq "make_range" ("int"[I] :: "int"[J]) =
    if I < J then "make_range" ("int"[I] :: "int"[J] :: "int"[1])
    else  "make_range" ("int"[I] :: "int"[J] :: "int"[-1])
    fi .

  eq "make_range" ("int"[I] :: "int"[J] :: "int"[K]) =
    if K > 0 and I <= J then
      "-|"("int"[I] :: "make_range" ("int"[I + K] :: "int"[J] :: "int"[K]))
    else
    if K < 0 and I >= J  then
        "-|"("int"[I] :: "make_range" ("int"[I + K] :: "int"[J] :: "int"[K]))
      else
        list(emp)
      fi
    fi .

endfm

*** Specification of times and functions on times.
***
fmod ABS-DATA-TIME is
  extending ABS-DATA-SIG .
  extending ABS-DATA-INT .

  *** The central problem is to evaluate this "expression", since the clock is
  *** floating around in the global state.
  op now : -> Expr [ctor] .

  vars T T' D D' S : Int .
  var I : Int .

  op _asTime : Data -> Int .
  eq "time"[I] asTime = I .
  op _asDuration : Data -> Int .
  eq "duration"[I] asDuration = I .


  *** Define the usual predicates on time.
  eq "<" ( "time"[T] :: "time"[T'] ) = (T < T') asAbsBool .
  eq "<=" ( "time"[T] :: "time"[T'] ) = (T <= T') asAbsBool .
  eq ">" ( "time"[T] :: "time"[T'] ) = (T > T') asAbsBool .
  eq ">=" ( "time"[T] :: "time"[T'] ) = (T >= T') asAbsBool .

  eq "+" ( "time"[T] :: "duration"[D] ) = "time"[T + D] .
  eq "-" ( "time"[T] :: "duration"[D] ) = "time"[_-_(T, D)] .
  eq "+" ( "duration"[D] :: "duration"[D'] ) = "duration"[D * D'] .
  eq "-" ( "duration"[D] :: "duration"[D'] ) = "duration"[_-_(D, D')] .
  eq "*" ( "duration"[D] :: "int"[S]) = "duration"[D * S] .
  eq "*" ( "int"[S] :: "duration"[D] ) = "duration"[S * D] .
  eq "/" ( "duration"[D] :: "int"[S]) = "duration"[S / D] .
  eq "<" ( "duration"[D] :: "duration"[D'] ) = (D < D') asAbsBool .
  eq "<=" ( "duration"[D] :: "duration"[D'] ) = (D <= D') asAbsBool .
  eq ">" ( "duration"[D] :: "duration"[D'] ) = (D > D') asAbsBool .
  eq ">=" ( "duration"[D] :: "duration"[D'] ) = (D >= D') asAbsBool .

  --- Arithmetic on time
  eq "-" ( "time"[T] :: "time"[T'] ) = "duration"[_-_(T, T')] .

endfm



*** The DATATYPES module collects all predefined data types into one module.
fmod ABS-DATATYPES is
    extending ABS-DATA-SIG .
    extending ABS-EXPRESSION .
    extending ABS-DATA-BOOL .
    extending ABS-DATA-LABEL .
    extending ABS-DATA-FLOAT .
    extending ABS-DATA-INT .
    extending ABS-DATA-STRING .
    extending ABS-DATA-LIST .
    extending ABS-DATA-TIME .
endfm


***************************************************************************
***
*** Signature of programs and states.
***
***************************************************************************

***
*** Binding variables to values.
***
*** Uses MAP from prelude.
***
fmod ABS-SUBST is
  protecting ABS-DATATYPES .
  extending MAP{Vid, Data} * (sort Map{Vid,Data} to SSubst,
                              sort Entry{Vid,Data} to Binding,
                              op empty : -> Map{Vid,Data} to noSubst,
                              op insert : Vid Data Map{Vid,Data} -> Map{Vid,Data} to $insert ) .

  sort Subst .
  subsort SSubst < Subst .
  vars A A' : Vid .
  var AL : VidList .
  vars D D' : Data .
  var DL : DataList .
  var S1 : Subst . 
  var S2 : SSubst .

  *** Lazy composition operator for substitutions
  *** FIXME: make this operator have less precedence than |->
  op _::_ : Subst Subst -> Subst [assoc] .
  eq (S1 :: S2)[A] = if $hasMapping(S2, A) then S2[A] else S1[A] fi .

  op hasMapping : Subst Vid -> Bool .
  eq hasMapping(S2, A) = $hasMapping(S2, A) .
  eq hasMapping(S1 :: S2, A) = $hasMapping(S2, A) or hasMapping(S1, A) .

  op insert : Vid Data Subst -> Subst .
  eq insert(A, D, S2) = $insert(A, D, S2) .
  eq insert(A, D, S1 :: S2) = S1 :: $insert(A, D, S2) .

  *** Replace an existing binding even in the middle of the SSubst stack.
  op update : Vid Data Subst -> Subst .
  eq update(A, D, S1 :: S2) = if $hasMapping(S2, A) then S1 :: $insert(A, D, S2)
      else update(A, D, S1) :: S2 fi .
  ceq update(A, D, S2) = $insert(A, D, S2)
  if $hasMapping(S2, A) .       *** Block if no mapping exists.

  --- Create a substitution from a list of identifiers and data values.
  op createSubst : VidList DataList -> SSubst .
  eq createSubst(AL, DL) = $createSubst(noSubst, AL, DL) .
  op $createSubst : SSubst VidList DataList -> SSubst .
  eq $createSubst(S2, noVid, emp) = S2 .
  eq $createSubst(S2, (A, AL), (D :: DL)) = 
    $createSubst($insert(A, D, S2), AL, DL) .
endfm


*** The sort of a class identifier.
***
fmod ABS-CID is
  protecting STRING .
  sort Cid .

  subsort String < Cid .

  op Class : -> Cid [ctor] .
  op Start : -> Cid [ctor] .
  op None : -> Cid [ctor] .
endfm

view Cid from TRIV to ABS-CID is
  sort Elt to Cid .
endv


*** The sort of an object identifier.
***
fmod ABS-OID is
  protecting NAT .
  protecting STRING .
  protecting CONVERSION .
  extending ABS-DATA-SIG .
  sort Oid .

  subsort Oid < Data .

  --- Constructor of object names
  op ob(_) : String -> Oid [ctor format (d d ! o d)] .

  var B : String .
  var F : Nat .

  --- Create a new fresh name for an object
  op newId : String Nat -> Oid .
  eq newId(B, F)  = ob(B + "-" + string(F,10)) .

endfm

view Oid from TRIV to ABS-OID is
  sort Elt to Oid .
endv



*** Abs Statements
***
*** The following module defines all elementary statements of Abs.
***
*** Colouring rules: Statements from the programmer syntax are displayed
*** in blue.  Statements inserted by the compiler only are displayed in
*** cyan.  Statements inserted by the run-time system are displayed in
*** red.  It may indicate a problem if a red term appears in a
*** configuration.

fmod ABS-STATEMENT is

  protecting ABS-DATA-VIDLIST .
  protecting ABS-EXPRESSION .
  protecting ABS-SUBST .
  protecting ABS-CID .

  sort Stmt .

  op skip : -> Stmt [ctor format (b o)] .
  op suspend : -> Stmt [ctor format (b o)] .
  op await_ : Expr -> Stmt [ctor format (b o d)] .
  op assert_ : Expr -> Stmt [ctor format (b o d)] .
  op assign(_;_) : Vid Expr -> Stmt [ctor format (b d o b o b o)] .
  op new(_;_;_) : Vid String ExprList -> Stmt [ctor format (b d o b o b o b o)] .
  op call(_;_;_;_) : Vid Expr String ExprList -> Stmt [ctor format (b d o b o b o b o b o)] . 
  op get(_;_)  : Vid Vid -> Stmt [ctor format (b d o b o b o)] .
  op get(_;_)  : Label Vid -> Stmt [ctor ditto] .

  op return(_) : Expr -> Stmt [ctor format (c d o c o)] .
  op $mark(_) : Vid -> Stmt [ctor format (c d o c o)] .
  op $free(_) : Vid -> Stmt [ctor format (c d o c o)] .
  op tailcall(_;_;_) : Expr String ExprList -> Stmt [ctor format (c d o c o c o c o)] .
  op selftailcall(_;_) : String ExprList -> Stmt [ctor format (c d o c o c o)] .

  op $cont_ : Label -> Stmt [ctor format (r o d)] .

  op $push_ : SSubst -> Stmt [ctor format (r o d)] .
  op $pop : -> Stmt [ctor format(r o)] .

  --- Assertion Failure.
  --- This `statement' represents an assertion failure.  It 
  --- stops evaluation of the executing object at that point.
  op failure_ : Expr -> [Stmt] [ctor format (r! o d)] .

endfm

view Stmt from TRIV to ABS-STATEMENT is
  sort Elt to Stmt .
endv



*** Specification of compound statements.
***
fmod ABS-STM-LIST is
  protecting ABS-STATEMENT .                
  protecting LIST{Stmt} * (sort List{Stmt} to StmtList,
                           sort NeList{Stmt} to NeStmtList,
                           op nil : -> List{Stmt} to noStmt,
                           op __ : List{Stmt} List{Stmt} -> List{Stmt} to _;_ [format (d r o d)]) .

  op if_th_el_fi : Expr StmtList StmtList -> Stmt [ctor format (b o b o b o b o)] . 
  op while_do_od : Expr StmtList -> Stmt [ctor format (b o b o b o)] .

  var SL : StmtList .
  var E : Expr .

endfm


fmod ABS-PROCESS is

  protecting ABS-STM-LIST .

  sort Process .

  op idle : -> Process [ctor format (!b o)] .  
  op notFound : -> Process [ctor format (!b o)] .  
  op {_|_} : Subst StmtList -> Process [ctor format (r o r o r o)] . 

  var L : Subst .
  eq { L | noStmt } = idle . --- if ".label" is needed this is dangerous!
  eq idle = { noSubst | noStmt } [nonexec metadata "Causes infinite loops."] .

endfm

view Process from TRIV to ABS-PROCESS is
  sort Elt to Process .
endv


*** Specifies a process pool, here a multiset of Processes
***
fmod ABS-PROCESS-POOL is
  protecting ABS-PROCESS .

  sort MProc .
  subsort Process < MProc .
  op noProc : -> MProc [ctor] .
  op _,_ : MProc MProc -> MProc
    [ctor assoc comm id: noProc prec 41 format (d r os d)] .

endfm


*** A method declaration
***
fmod ABS-METHOD is
  protecting ABS-STM-LIST .

  sort Method .

  op <_: Method | Param:_, Att:_, Code:_> : 
    String VidList Subst StmtList -> Method
    [ctor format (c ! oc o d sc o d sc o d sc o c o)] .

endfm

view Method from TRIV to ABS-METHOD is
  sort Elt to Method .
endv


*** Abs's state configuration.
***
*** Modeled after the CONFIGURATION module in "prelude.maude"
***
fmod ABS-CONFIGURATION is
  protecting ABS-DATA-LABEL .
  protecting ABS-PROCESS-POOL .
  protecting ABS-CID .
  protecting ABS-OID .
  protecting SET{Method} * (sort Set{Method} to MMtd,
                            op empty : -> Set{Method} to noMethod) .
 
  --- Define object identifiers.
  protecting CONVERSION .

  sorts Msg Class Future Object Configuration .
  subsorts Msg Class Future Object < Configuration .

  vars B M : String .
  var C : Cid .
  vars O O' : Oid .
  vars L S S1 : Subst .
  vars P P' : Process .
  vars MS MS1 : MMtd .
  var W : MProc .
  var AL : VidList .
  vars SL SL1 : StmtList .
  var EL : ExprList .
  var D : Data .
  var DL : DataList .
  var N : Label .
  vars F F' : Nat .

  --- Invocation message.
  ---
  --- invoc(S,R,N,M,DL)
  --- S: The sender.
  --- R: The receiver.
  --- N: The label.
  --- M: The called method.
  --- DL: The actual arguments.
  op invoc(_,_,_,_,_) : Oid Oid Label String DataList -> Msg
    [ctor format (b d o  b so  b so  b so  b so b on)] .

  --- Error and warning messages are intended to stop the machine.
  --- For now, nothing is emitting these.
  --- op error(_) : String -> [Msg] [ctor format (nnr r o! or onn)] .
  op warning(_) : String -> [Msg] [ctor format (nnr! r! r! or onn)] .

  --- Fetch pair { code |  vars } to bind call to process.
  ---
  --- M   represents the name of the method.
  --- MS  represents the methods we search through.
  --- N   represents the label used to return the value computed by the
  ---     method.
  --- DL  represents the list of actual arguments.
  op makeProcess : String MMtd Label DataList -> Process .

  eq makeProcess(M, (MS, < M : Method | Param: AL, Att: S, Code: SL >), N, DL) =
    { @ ".label" |-> N, S, createSubst(AL, DL) | SL } .
  eq makeProcess(M, MS, N, DL) = notFound [owise] .

  --- Terms of sort Object represent objects in the run-time configuration.
  ---
  op <_:_ | Att:_, Pr:_, PrQ:_, Lcnt:_> : 
    Oid Cid Subst Process MProc Nat -> Object 
    [ctor format (nr d d g ++r nir o  r ni o  r ni o  r ni o--  r on)] .

  --- Terms that represent futures.
  ---
  op <_: Future | Name:_, Completed:_, References:_, Value:_> :
    Label String Bool Nat Data -> Future
    [ctor format (nr d d g ++r ir o  r i o  r i o  r i o--  r on)] .

  --- Completed futures without references can be removed.
  ---
  eq < N : Future | Name: M, Completed: true, References: 0, Value: D > = none .

  --- Define Classes.
  --- Class declaration.
  ---
  op <_: Class | Param:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid VidList Subst MMtd Nat -> Class 
    [ctor format (ng ! og o d  sg o d  sg o d  sg++ oni o  gni o-- g on)] .

  --- Define a configuration
  op none : -> Configuration [ctor] .
  op __ : Configuration Configuration -> Configuration
    [ctor assoc comm id: none] .

  *** Useful for real-time maude and some other tricks.
  *** We should not provide sort State, since this is used in LOOP-MODE.
  *** For now, we do.
  sort State .

  op {_} : Configuration -> State [ctor] .

  var CN : Configuration .

  --- Insert a warning into the current state.
  op warn : State String -> State .
  eq warn({ CN }, M) = { warning(M) CN } .

  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.
  op main : Configuration String DataList -> State .
  eq main(CN, B, DL) =
    { CN < ob("main") : Start | Att: noSubst, 
      Pr: { @ "var" |-> null | new(@ "var" ; B ; DL) },
      PrQ: noProc, Lcnt: 0 > } .

  --- The initial object commits suicide after it did its job.
  eq < ob("main") : Start | Att: noSubst, Pr: idle, PrQ: noProc, Lcnt: 1 > =
    none .

endfm


*** Definition of the family of evaluation functions.
***
fmod ABS-EVAL is
  protecting ABS-CONFIGURATION .
  protecting ABS-DATA-VID .

  vars L L' : Label .
  vars E E' E'' : Expr .
  vars D D' : Data .
  var DL : DataList .
  var EL : ExprList .
  var NeEL : NeExprList .
  var CBL : CaseBranchList .
  vars A A' : Vid .
  var AL : VidList .
  vars Q C : String .
  vars S S' : Subst .
  var SS : SSubst .
  vars ST ST' : Stmt . 
  vars SL SL1 SL2 : StmtList .
  var CN : Configuration .
  var CL : Class .
  var OB : Object .
  var MS : Msg .
  var N : Nat .
  var B : Bool .

  --- Check if a message is in the queue.
  op completed : Label Configuration -> Bool .
  eq completed(L, < L : Future | Name: Q, Completed: B, References: N, Value: D > CN) = B .
  eq completed(L, CN) = false [owise] .

  op eval : Expr Subst Configuration -> Data .
  op evalList : ExprList Subst Configuration -> DataList [strat (1 0 0 0)] .
  op enabled : StmtList Subst Configuration -> Bool .
  op ready : StmtList Subst Configuration -> Bool .

  eq eval(D, S, CN) = D .

  *** Normal variable lookup.  Can be either instance or local variable.
  eq eval(@ Q, S, CN) =  S [@ Q] .
  *** Instance variable lookup.  The distinction between @@ and @ needs to be
  *** made in all lookup operations.
  eq eval(@@ Q, (SS :: S), CN) =  SS [@ Q] .
  *** Function expansions are expressions, subject to further evaluation
  eq eval(Q (EL), S, CN) = eval(Q ( evalList(EL, S, CN) ), S, CN) .
  eq eval(Q [EL], S, CN) = Q [ evalList(EL, S, CN) ] .
  eq eval(?(@ Q), S, CN) = completed(S[@ Q], CN) asAbsBool .
  eq eval(?(@@ Q), (SS :: S), CN) = completed(SS[@ Q], CN) asAbsBool .
  eq eval(?(L), S, CN) = completed(L, CN) asAbsBool .
  eq eval(now, S, CN) = "time"[0] . *** time is constant in the untimed version
  eq eval(list(EL), S, CN) = list(evalList(EL, S, CN)) .
  eq eval(if E th E' el E'' fi, S, CN) =
    if eval(E, S, CN) asBool
    then eval(E', S, CN)
    else eval(E'', S, CN) fi .
  eq eval(let AL = EL in E, S, CN) = 
    eval(E, S :: createSubst(AL, evalList(EL, S, CN)), CN) .

  *** evaluate a case statement.  If the pattern matches, augment environment
  *** with the resulting bindings.
  sort MatchResult .
  subsort Subst < MatchResult .
  op noMatch : -> MatchResult [ctor] .
  op match : Data Expr -> MatchResult .
  eq match(D, E) = $match(D, E, noSubst) .
  op $match : Data Expr MatchResult -> MatchResult .
  eq $match(Q[emp], Q[emp], S) = S . *** base case
  eq $match(D, D, S) = S .           *** matching two literals
  eq $match(D, @ "_", S) = S .       *** "Don't care" placeholder
  eq $match(D, A, S) =               *** Create / check variable binding
    if S[A] == undefined
    then insert(A, D, S)             *** Generate new binding
    else                             *** Match against existing binding
      if S[A] == D then S else noMatch fi
    fi .
  eq $match(Q[D :: DL], Q[E :: EL], S) = *** Destructure constructor pattern
    $match(Q[DL], Q[EL], $match(D, E, S)) .
  eq $match(D, E, noMatch) = noMatch .
  eq $match(D, E, S) = noMatch [owise] .

  *** internal operator $case avoids endless loop between "case D of" and
  *** "case E of" when first case branch doesn't match
  op $case : Data CaseBranchList -> Expr .
  ceq eval($case(D, (E => E') ; CBL), S, CN) = 
    if M:MatchResult == noMatch
    then eval($case(D, CBL), S, CN)
    else eval(E', S :: M:MatchResult, CN) fi
  if M:MatchResult := match(D, E) .

  eq eval(case E of { CBL }, S, CN) = 
    eval($case(eval(E, S, CN), CBL), S, CN) .


  --- Evaluate lists of expressions.
  eq evalList(emp, S, CN) = emp .
  eq evalList(DL, S, CN) = DL .
  eq evalList(E, S, CN) = eval(E, S, CN) .
  eq evalList(E :: NeEL, S, CN) =
    eval(E, S, CN) :: evalList(NeEL, S, CN) .

  --- Enabledness
  eq enabled(await E ; SL, S, CN) = eval(E, S, CN) asBool .
  eq enabled(SL, S, CN) = true [owise] .

  --- The ready predicate holds, if a statement is ready for execution,
  --- i.e., the corresponding process may be waken up.
  eq ready(get(@ Q ; A') ; SL , S, CN) = completed(S[@ Q], CN) . 
  eq ready(get(@@ Q ; A') ; SL , (SS :: S), CN) = completed(SS[@ Q], CN) . 
  eq ready(get(L ; A') ; SL , S, CN) = completed(L, CN) . 
  eq ready(SL, S, CN) = enabled(SL, S, CN) [owise] .

endfm


fmod ABS-EVAL-TIMED is
  protecting ABS-EVAL .

  var D : Data .
  var DL : DataList .
  vars E E' E'' : Expr .
  var EL : ExprList .
  var NeEL : NeExprList .
  vars A A' : Vid .
  var AL : VidList .
  vars SL SL1 SL2 : StmtList .
  var L : Label .
  var S : Subst .
  var CN : Configuration .
  var N : Nat .
  var Q : String .
  var CBL : CaseBranchList .

  op eval : Expr Subst Configuration Nat -> Data .
  op evalList : ExprList Subst Configuration Nat -> DataList [strat (1 0 0 0)] .
  op enabled : StmtList Subst Configuration Nat -> Bool .
  op ready : StmtList Subst Configuration Nat -> Bool .

  eq eval(now, S, CN, N) = "time"[N] .
  eq eval(Q (EL), S, CN, N) = Q ( evalList(EL, S, CN, N) ) .
  eq eval(Q [EL], S, CN, N) = Q [ evalList(EL, S, CN, N) ] .
  eq eval(list(EL), S, CN, N) = list(evalList(EL, S, CN, N)) .
  eq eval(if E th E' el E'' fi, S, CN, N) =
    if eval(E, S, CN, N) asBool
    then eval(E', S, CN, N)
    else eval(E'', S, CN, N) fi .
  eq eval(let AL = EL in E, S, CN, N) = 
    eval(E, S :: createSubst(AL, evalList(EL, S, CN, N)), CN, N) .

  ceq eval($case(D, (E => E') ; CBL), S, CN, N) = 
    if M:MatchResult == noMatch
    then eval($case(D, CBL), S, CN, N)
    else eval(E', S :: M:MatchResult, CN, N) fi
  if M:MatchResult := match(D, E) .

  eq eval(case E of { CBL }, S, CN, N) = 
    eval($case(eval(E, S, CN), CBL), S, CN, N) .

  eq eval(E, S, CN, N) = eval(E, S, CN) [owise] . *** Defer to untimed eval

  --- Evaluate lists of expressions.
  eq evalList(emp, S, CN, N) = emp .
  eq evalList(DL, S, CN, N) = DL .
  eq evalList(E, S, CN, N) = eval(E, S, CN, N) .
  eq evalList(E :: NeEL, S, CN, N) =
    eval(E, S, CN, N) :: evalList(NeEL, S, CN, N) .
  
  --- Enabledness
  eq enabled(await E ; SL, S, CN, N) = eval(E, S, CN, N) asBool .
  eq enabled(SL, S, CN, N) = true [owise] .

  --- The ready predicate holds, if a statement is ready for execution,
  --- i.e., the corresponding process may be waken up.
  eq ready(get(A ; A') ; SL , S, CN, N) = completed(S[A], CN) . 
  eq ready(get(L ; A') ; SL , S, CN, N) = completed(L, CN) . 
  eq ready(SL, S, CN, N) = enabled(SL, S, CN, N) [owise] .

endfm

*** The machine.
***
*** We have one module per statement per evaluation strategy, and combine them
*** in the end.

mod ABS-STMT-SKIP-RL is
  protecting ABS-EVAL .
  --- skip as rewrite rule.
  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .

  rl
    < O : C | Att: S, Pr: { L | skip ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label skip] .
endm

mod ABS-STMT-ASSIGN-RL is
  protecting ABS-EVAL .
  --- assign as rewrite rule.
  ---
  --- Execute an assignment.  The expression on the right hand side of the
  --- assignment is evaluated and stored as new value for the left hand side
  --- identifier.
  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var Q : String .

  crl
    < O : C | Att: S, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W, Lcnt: F > 
  =>
    if hasMapping(L, @ Q) then
      < O : C | Att: S, Pr: { update(@ Q, D, L) |  SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Att: insert(@ Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F > 
    fi
    if D := eval(E, (S :: L), none)
    [label assignment] .

  crl
    < O : C | Att: S, Pr: { L | assign(@@ Q ; E) ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: insert(@ Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F >
  if D := eval(E, (S :: L), none)
    [label field-assignment] .
endm

mod ABS-STMT-COND-RL is
  protecting ABS-EVAL .
  --- if_then_else as rewrite rule.
  ---
  var O : Oid .                 var C : Cid .    vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .

  rl
    < O : C | Att: S, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W, Lcnt: F >
  =>
    if eval(E, (S :: L), none) asBool then
      < O : C | Att: S, Pr: { L | SL1 ; SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Att: S, Pr: { L | SL2 ; SL }, PrQ: W, Lcnt: F >
    fi
    [label if-then-else] .
endm

mod ABS-STMT-WHILE-RL is
  protecting ABS-EVAL .
  --- while as rewrite rule.
  ---
  --- During model checking we want to be able to observe infinite loops.
  --- Therefore, while should always be a rule.
  ---
  var O : Oid .             var C : Cid .    vars S L : Subst .
  vars SL SL1 : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .

  rl
    < O : C | Att: S, Pr: { L | while E do SL1 od ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: S,
              Pr: { L | if E th (SL1 ; while E do SL1 od) el skip fi ; SL },
              PrQ: W, Lcnt: F >
    [label while] .
endm

mod ABS-STMT-SUSPEND-RL is
  protecting ABS-EVAL .
  --- suspend as rewrite rule.
  ---
  --- The suspend statement is an unconditional processor release point.
  ---
  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .

  rl
    < O : C | Att: S, Pr: { L | suspend ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F >
    [label suspend] .
endm

mod ABS-STMT-AWAIT-RL is
  protecting ABS-EVAL .
  --- await as rewrite rule.
  ---
  --- We capture the entire state here since the condition E can depend on the
  --- state of Futures contained in CN.
  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   var Q : String .

  rl
    { < O : C | Att: S, Pr: { L | await E ; SL }, PrQ: W, Lcnt: F > CN  }
  =>
    if enabled(await E, (S :: L), CN) then
      { < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > CN  }
    else
      { < O : C | Att: S, Pr: idle, PrQ: W , { L | await E ; SL}, Lcnt: F > CN  }
    fi
      [label await] .
endm


mod ABS-SIMULATOR-RL is

  --- A machine using rewrite rules.
  protecting ABS-EVAL .
  protecting ABS-STMT-SKIP-RL .
  protecting ABS-STMT-ASSIGN-RL .
  protecting ABS-STMT-COND-RL .
  protecting ABS-STMT-WHILE-RL .
  protecting ABS-STMT-SUSPEND-RL .
  protecting ABS-STMT-AWAIT-RL .

  vars F G : Nat .                     --- Counters for generating fresh names
  vars O O1 : Oid .                    --- Object identifiers
  vars C CC : Cid .                    --- Class names
  var Q : String .                     --- Generic names (attribute and method)
  vars A A' : Vid .                        --- Generic attribute names
  var AL : VidList .                   --- List of LHS
  var N : Label .                      --- Call label
  var D : Data .                       --- Value
  vars DL DL2 : DataList .             --- List of values
  var E : Expr .                       --- Expression
  var EL : ExprList .                  --- List of Expressions
  var ST : Stmt .                      --- Statement
  vars S S1 L L1 : Subst .             --- Object and process states
  var S2 : SSubst .
  vars SL SL1 SL2 : StmtList .         --- List of statements
  var P : Process .
  var W : MProc .
  var MS : MMtd .
  var CN : Configuration .
  var CO : Bool .                      --- Whether a future completed
  var B : Cid .

  op label : Oid Nat -> Label [ctor format (o o)] .

  --- Schedule a new process for execution, if it is ready.
  ---
  --- Must be a rule to preserve confluence.
  ---
  --- We capture the entire state here since the condition E can depend on the
  --- state of Futures contained in CN.
  crl
    { < O : C | Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F > CN  }
  =>
    { < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > CN  }
  if ready(SL, (S :: L), CN)
      [label PrQ-ready] .



  --- OPTIMISATION: Optimize label access in await statements.  We cannot do
  --- this for instance variables because another process might change the
  --- binding.
  ceq
    < O : C | Att: S, Pr: { L | await ?(@ Q) ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L | await ?(L[@ Q]) ; SL }, PrQ: W, Lcnt: F >
  if hasMapping(L, @ Q) .


  --- METHOD CALLS
  ---

  --- OPTIMISATION: Reduce the value of a label in a process to avoid constant
  --- re-evaluation.  Cannot be done for instance variables because another
  --- process might change the binding.
  ceq < O : C | Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L | get(L[A] ; A') ; SL }, PrQ: W, Lcnt: F >
  if hasMapping(L, A) .


  --- receive-comp
  ---
  --- Must be a rule even in the model checker, because there might be
  --- multiple completion messages with the same label but different return
  --- values in the queue.
  ---
  rl
    < O : C |  Att: S, Pr: { L | get(N ; A) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
  =>
    < O : C |  Att: S, Pr: { L | assign(A ; D) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
    [label receive-comp-label] .

  crl
    < O : C |  Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
  =>
    < O : C |  Att: S, Pr: { L | assign(A' ; D) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
  if N = (S :: L)[A]
    [label receive-comp-var] .


  --- local-reply
  ---
  crl
    < O : C | Att: S, Pr: { L | get(N ; A) ; SL }, PrQ: W , { L1 | SL1 }, Lcnt: F >
  =>
    < O : C | Att: S, Pr:  { L1 | SL1 ; $cont N },
              PrQ: W , { L | get(N ; A) ; SL }, Lcnt: F >
  if L1[@ ".label"] == N
      [label local-reply] .


  --- continue
  ---
  --- Continue after executing the code of a local reply.  This is
  --- always a rule.  We want it to be a rule in the interpreter.
  --- 
  --- If we support shared futures, this must be a rule in the model
  --- checker, because there might be two processes in PrQ which await a
  --- reply to the label.
  rl
    < O : C | Att: S, Pr: { L | $cont N }, PrQ: W , { L1 | get(N ; A) ; SL1},
              Lcnt: F >
  =>
    < O : C | Att: S, Pr: { L1 | get(N ; A) ; SL1 }, PrQ: W,
              Lcnt: F >
    [label continue] .


  --- remote-async-call
  ---
  crl
    < O : C | Att: S, Pr: { L | call(A ; E ; Q ; EL); SL }, PrQ: W, Lcnt: F > 
  =>
    < O : C | Att: S, Pr: { L | assign(A ; N) ; SL }, PrQ: W, Lcnt: (s F) > 
    invoc(O, O1, N, Q , DL)
  if DL :=  evalList(EL, (S :: L), none)
      /\ O1 := eval(E, (S :: L), none)
      /\ N := label(O, F)
      /\ O =/= O1
      [label remote-async-call] .

  --- remote-async-self-call
  ---
  crl
    < O : C | Att: S, Pr: { L | call(A ; E ; Q ; EL); SL }, PrQ: W, Lcnt: F > 
    < C : Class | Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  =>
    < O : C | Att: S, Pr: { L | assign(A ; N) ; SL }, PrQ: (W, makeProcess(Q, MS, N, evalList(EL, (S :: L), none))), Lcnt: (s F) > 
    < C : Class | Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
    < N : Future | Name: Q, Completed: false, References: 1, Value: null >
  if N := label(O, F) /\ O = eval(E, (S :: L), none)
      [label remote-async-self-call] .


  --- return
  ---
  crl
    < O : C |  Att: S, Pr: { L | return(E); SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: false, References: G, Value: null >
  =>
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process.  We cannot return immediately since there might be
    *** `release' or `$pop' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < O : C |  Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: true, References: G, Value: eval(E, (S :: L), none) >
  if N == L[@ ".label"]
      [label return] .


  --- transport
  ---
  --- Receive an invocation message to bind the method body.
  ---
  eq
    < O : C | Att: S, Pr: P, PrQ: W, Lcnt: F >
    < C : Class | Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
    invoc(O1, O, N, Q, DL)
  =
    < O : C | Att: S, Pr: P, PrQ: (W, makeProcess(Q, MS, N, DL)), Lcnt: F >
    < C : Class | Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
    < N : Future | Name: Q, Completed: false, References: 1, Value: null >
    [label transport-imsg] .

  --- mark
  ---
  --- Mark a label in use.
  crl
    < O : C | Att: S, Pr: { L | $mark(A) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
  =>
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G + 1, Value: D >
  if N = (S :: L)[A]
      [label mark] .


  --- free
  ---
  --- Free a label.  Make sure that the use of labels is linear.
  ---
  --- sd(G,1) works, because G is always positive. Maude does not have a
  --- nice decrement operator.
  crl
    < O : C | Att: S, Pr: { L | $free(A) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
  =>
    < O : C | Att: S, Pr: { insert(A, null, L) | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: sd(G, 1), Value: D >
  if N = (S :: L)[A]
      [label free] .


  --- TAIL CALLS
  ---
  --- "pass on" our return label to the new process.
  ---
  ---  FIXME (rs 2010-06-15): `invoc' creates a new Future - this is not what
  --- we want in this case.  Not so urgent since the `tailcall' statement is
  --- not emitted in the code generator currently.
  ---
  rl
    < O : C | Att: S, Pr: { L | tailcall(E ; Q ; EL) ; SL }, PrQ: W, Lcnt: F > 
  =>
    < O : C | Att: S, Pr: { update(@ ".label", null, L) | SL }, PrQ: W, Lcnt: F >
    invoc(O, eval(E, (S :: L), none), L[@ ".label"], Q, evalList(EL, (S :: L), none))
    [label tailcall] .

  --- STATIC TAIL CALLS
  ---
  --- Block if the `selftailcall' statement is followed by any more
  --- statements.  If necessary, this could be replaced by putting `$cont' at
  --- the end of the current process.
  rl
    < O : C | Att: S, Pr: { L | selftailcall(Q ; EL) }, PrQ: W, Lcnt: F > 
    < C : Class | Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  =>
    < O : C | Att: S, Pr: makeProcess(Q, MS, L[@ ".label"], evalList(EL, (S :: L), none)), PrQ: W, Lcnt: F >
    < C : Class | Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  [label selftailcall] .


  --- OBJECT CREATION
  ---
  --- Set up an init process, which is essentially init(;); !run()
  ---
  --- It is smarter to invoke the run method asynchronously from the
  --- initialisation process, to make sure that the initialisation
  --- process will terminate instead of waiting for the return of run in
  --- ill-behaved programs.  We cannot use a tail-call here, because
  --- there is no caller the initialisation will return to.
  ---
  rl
    < O : C | Att: S, Pr: { L | new(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =>
    < O : C | Att: S, Pr: { L | assign(A ; newId(B, G)); SL }, PrQ: W,
              Lcnt: (s F) >
    < B : Class | Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < newId(B, G) :  B | Att: (@ "this" |-> newId(B, G), S1,
                               createSubst(AL, evalList(EL, S :: L, none))),
                         Pr: makeProcess(".init", MS, label(O, F), emp), 
                         PrQ: noProc, Lcnt: 0 >
    [label new-object] .

  rl
    < O : C | Att: S, Pr: { L | $push S2 ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: S, Pr: { L :: S2 | SL }, PrQ: W, Lcnt: F >
    [label $push] .

  rl
    < O : C | Att: S, Pr: { L :: S2 | $pop ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label $pop] .


  --- assert
  ---
  rl
    { < O : C | Att: S, Pr: { L | assert(E) ; SL }, PrQ: W, Lcnt: F > CN  }
  =>
    { if eval(E, (S :: L), CN) asBool then
        < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      else
        < O : C | Att: S, Pr: { L | failure(E) ; SL }, PrQ: W, Lcnt: F >
      fi CN  }
    [label assert] .

endm

eof

*** Local Variables:
*** maude-indent: 2
*** fill-column: 78
*** End:
