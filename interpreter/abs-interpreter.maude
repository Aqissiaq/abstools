***
*** An ABS interpreter on the Maude platform
***
*** Copyright (c) 2010 Rudolf Schlatte
*** 
*** Based upon `creol-interpreter.maude' by Marcel Kyas, Olaf Owe, Einar Broch
*** Johnsen, which was generated from interpreter.m4, Copyright (c) 2007, 2008
*** Marcel Kyas
***
***
*** This program is free software; you can redistribute it and/or
*** modify it under the terms of the GNU General Public License as
*** published by the Free Software Foundation; either version 3 of the
*** License, or (at your option) any later version.
***
*** This program is distributed in the hope that it will be useful, but
*** WITHOUT ANY WARRANTY; without even the implied warranty of
*** MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
*** General Public License for more details.
***
*** You should have received a copy of the GNU General Public License
*** along with this program.  If not, see <http://www.gnu.org/licenses/>.
***



*** The basic concepts of Abs's data type.
***
fmod ABS-DATA-SIG is

  sorts Expr Data .
  subsort Data < Expr .

  op null : -> Data [ctor format (! o)] .

  sorts   NeExprList ExprList NeDataList DataList .
  subsort Expr < NeExprList < ExprList .
  subsort Data < NeDataList < DataList .
  subsort DataList < ExprList .
  subsort NeDataList < NeExprList .

  op emp : -> DataList [ctor] .

  op _::_ : ExprList ExprList -> ExprList
    [ctor assoc id: emp prec 27 format (d r os d)] .
  op _::_ : NeExprList ExprList -> NeExprList [ctor ditto] .
  op _::_ : ExprList NeExprList -> NeExprList [ctor ditto] .
  op _::_ : DataList DataList  -> DataList [ctor ditto] .
  op _::_ : NeDataList DataList  -> NeDataList [ctor ditto] .
  op _::_ : DataList NeDataList  -> NeDataList [ctor ditto] .

endfm

view Data from TRIV to ABS-DATA-SIG is
  sort Elt to Data .
endv

view Expr from TRIV to ABS-DATA-SIG is
  sort Elt to Expr .
endv


fmod ABS-DATA-VID is
  extending ABS-DATA-SIG .
  protecting STRING .

  sort Vid .
  subsort Vid < Expr .

  *** Variable references
  op @_ : String -> Vid [ctor] .
  *** Instance variable references

  op @@_ : String -> Vid [ctor] .
endfm

view Vid from TRIV to ABS-DATA-VID is
  sort Elt to Vid .
endv

fmod ABS-DATA-VIDLIST is
  protecting LIST{Vid} * (sort List{Vid} to VidList,
                          sort NeList{Vid} to NeVidList,
                          op nil : -> List{Vid} to noVid,
                          op __ : List{Vid} List{Vid} -> List{Vid} to _`,_ [format (d r os d)]) .
endfm



*** Specification of all Abs expressions.  This is the abstract syntax.
*** Semantics will be provided by the different modules.
***
fmod ABS-EXPRESSION is

  protecting ABS-DATA-VIDLIST .
  protecting ABS-DATA-SIG .
  protecting STRING .

  sorts CaseBranch CaseBranchList .
  subsort CaseBranch < CaseBranchList .
  *** KLUDGE (rs 2010-04-20) Only certain kinds of expressions can be used as
  *** pattern: literals and variable references.  We should introduce a sort
  *** `Pattern' and use it.  For now, we rely on the compiler to only produce
  *** valid pattern expressions.
  op _=>_ : Expr Expr -> CaseBranch [ctor prec 39] .
  op _;_ : CaseBranchList CaseBranchList -> CaseBranchList
    [ctor assoc id: noBranch format (d b os d)] .
  op noBranch : -> CaseBranch .

  *** function application
  op _(_) : String ExprList -> Expr [ctor prec 12 format (! o d d d)] .
  *** Helpers for function application, generated for each function.
  op fparams : String -> VidList .
  op fdefn : String -> Expr .
  *** Translation from Abs to Maude expressions for basic datatypes (Int,
  *** Bool, String etc).
  op $builtin : String -> Expr .
  *** constructor terms
  op _[_] : String ExprList -> Expr [ctor prec 12 format (! o d d d)] .
  op _[_] : String DataList -> Data [ctor prec 12 format (! o d d d)] .
  *** conditional
  op if_th_el_fi : Expr Expr Expr -> Expr [ctor] .
  *** case expression
  op case_of {_} : Expr CaseBranchList -> Expr [ctor] .
  *** let expression
  op let_=_in_ : VidList ExprList Expr -> Expr [ctor] .
  *** guard expression
  op ?(_)  : Expr -> Expr [ctor format (! o d d d)] .
  *** Error terms
  op $error : String -> Expr [ctor] .

endfm

*** Specification of the Bool datatype.
***
fmod ABS-DATA-BOOL is

  protecting ABS-EXPRESSION .

  vars B B' : Bool .
  vars D D' : Data .
  vars E : Expr .

  
  op _asBool : Data -> Bool .
  eq "True"[ emp ] asBool = true .
  eq "False"[ emp] asBool = false .
  op _asAbsBool : Bool -> Data .
  eq true asAbsBool = "True"[ emp ] .
  eq false asAbsBool = "False"[ emp ] .

  eq fparams("==") = @ "D1", @ "D2" .
  eq fdefn("==") = $builtin("==") .
  eq fparams("/=") = @ "D1", @ "D2" .
  eq fdefn("/=") = $builtin("/=") .

  eq fparams("~") = @ "D" .
  eq fdefn("~") = $builtin("~") .
  eq fparams("&&") = @ "D1", @ "D2" .
  eq fdefn("&&") = $builtin("&&") .
  eq fparams("||") = @ "D1", @ "D2" .
  eq fdefn("||") = $builtin("||") .
  
endfm



*** Specification of floats and functions on floats.
***
fmod ABS-DATA-FLOAT is
  extending ABS-DATA-BOOL .
  protecting FLOAT .

  op _[_] : String Float -> Data [ctor prec 12 format (! o d d d)] .

  vars F F' : Float .

  op _asFloat : Data -> Float .
  eq "float"[F] asFloat = F .

  eq "-" ("float"[F]) = "float"[-(F)] .
  eq "+" ("float"[F] :: "float"[F']) = "float"[F + F'] .
  eq "-" ("float"[F] :: "float"[F']) = "float"[ _-_(F, F')] .
  eq "*" ("float"[F] :: "float"[F']) = "float"[F * F'] .
  eq "/" ("float"[F] :: "float"[F']) = "float"[F / F'] .
  eq "%" ("float"[F] :: "float"[F']) = "float"[F rem F'] .
  eq "**" ("float"[F] :: "float"[F']) = "float"[F ^ F'] .

  eq "<"  ("float"[F] :: "float"[F']) = (F < F') asAbsBool .
  eq "<=" ("float"[F] :: "float"[F']) = (F <= F') asAbsBool .
  eq ">"  ("float"[F] :: "float"[F']) = (F > F') asAbsBool .
  eq ">=" ("float"[F] :: "float"[F']) = (F >= F') asAbsBool .

endfm



*** Specification of integers and functions on integers.
***
fmod ABS-DATA-INT is
  extending ABS-DATA-FLOAT .

  protecting INT .
  protecting RANDOM .
  protecting CONVERSION .

  op _[_] : String Int -> Data [ctor prec 12 format (! o d d d)] .

  vars I I' : Int .
  var N : Nat .

  op _asInt : Data -> Int .
  eq "int"[I] asInt = I .

  op _asNat : Data -> Nat .
  eq "int"[N] asNat = N .

  eq fparams("--") = @ "I" .
  eq fdefn("--") = $builtin("--") .
  eq fparams("+") = @ "I1", @ "I2" .
  eq fdefn("+") = $builtin("+") .
  eq fparams("-") = @ "I1", @ "I2" .
  eq fdefn("-") = $builtin("-") .
  eq fparams("*") = @ "I1", @ "I2" .
  eq fdefn("*") = $builtin("*") .
  eq fparams("/") = @ "I1", @ "I2" .
  eq fdefn("/") = $builtin("/") .
  eq fparams("%") = @ "I1", @ "I2" .
  eq fdefn("%") = $builtin("%") .
  
  *** eq "**" ("int"[I] :: "int"[I']) = "int"[I ^ I'] .
  *** eq "random" ("int"[I]) = "int"[random(I)] .
  *** eq "real_of_int" ("int"[I]) = "float"[float(I)] .

  eq fparams("<") = @ "I1", @ "I2" .
  eq fdefn("<") = $builtin("<") .
  eq fparams("<=") = @ "I1", @ "I2" .
  eq fdefn("<=") = $builtin("<=") .
  eq fparams(">") = @ "I1", @ "I2" .
  eq fdefn(">") = $builtin(">") .
  eq fparams(">=") = @ "I1", @ "I2" .
  eq fdefn(">=") = $builtin(">=") .

endfm



*** Specification of strings and functions on strings.
***
fmod ABS-DATA-STRING is
  extending ABS-DATA-INT .

  protecting STRING .

  op _[_] : String String -> Data [ctor prec 12 format (! o d d d)] .

  vars S S' : String .
  vars M N : Nat .

  op _asString : Data -> String .
  eq "str"[S] asString = S .

  eq "+" ("str"[S] :: "str"[S']) = "str"[S + S'] .
  eq "#" ("str"[S]) = "int"[length(S)] .
  eq "ascii" ("str"[S]) = "int"[ascii(S)] .
  eq "char" ("int"[N]) = "str"[char(N)] .
  eq fparams("substr") = @ "S", @ "L", @ "R" .
  eq fdefn("substr") = $builtin("substr") .
  eq fparams("strlen") = @ "S" .
  eq fdefn("strlen") = $builtin("strlen") .
  eq "find" ("str"[S] :: "str"[S'] :: "int"[N]) = "int"[find(S, S', N)] .
  eq "rfind" ("str"[S] :: "str"[S'] :: "int"[N]) = "int"[rfind(S, S', N)] .

  eq "<" ("str"[S]:: "str"[S']) = (S < S') asAbsBool .
  eq "<=" ("str"[S]:: "str"[S']) = (S <= S') asAbsBool .
  eq ">" ("str"[S]:: "str"[S']) = (S > S') asAbsBool .
  eq ">=" ("str"[S]:: "str"[S']) = (S >= S') asAbsBool .


  --- Conversions.  Since Abs does not support rational numbers yet,
  --- we may have failures here which will remain unchecked.
  protecting CONVERSION .
  var I : Int .
  var F : Float .

  eq "string_of_int" ("int"[I]) = "str"[string(I, 10)] .
  eq "int_of_string" ("str"[S]) = "int"[rat(S, 10)] .
  eq "string_of_real" ("float"[F]) = "str"[string(F)] .
  eq "real_of_string" ("str"[S]) = "float"[float(S)] .

endfm


*** Specification of times and functions on times.
***
fmod ABS-DATA-TIME is
  extending ABS-DATA-SIG .
  extending ABS-DATA-INT .

  *** The central problem is to evaluate this function, since the clock is
  *** floating around in the global state.
  eq fparams("currentms") = noVid .
  eq fdefn("currentms") = $builtin("currentms") .
endfm



***************************************************************************
***
*** Signature of programs and states.
***
***************************************************************************

*** The sort of a class identifier.
***
mod ABS-CID is
  protecting CONFIGURATION .
  protecting STRING .
  subsort String < Cid .

  op Class : -> Cid [ctor] .
  op Start : -> Cid [ctor] .
  op None : -> Cid [ctor] .
endm

view Cid from TRIV to ABS-CID is
  sort Elt to Cid .
endv


*** The sort of an object identifier.
***
mod ABS-OID is
  protecting ABS-CID .
  protecting NAT .
  protecting CONVERSION .
  extending ABS-DATA-SIG .

  subsort Oid < Data .

  --- Constructor of object names
  op ob(_) : String -> Oid [ctor format (d d ! o d)] .

  var B : String .
  var F : Nat .

  --- Create a new fresh name for an object
  op newId : String Nat -> Oid .
  eq newId(B, F)  = ob(B + "-" + string(F,10)) .

endm

view Oid from TRIV to ABS-OID is
  sort Elt to Oid .
endv

mod ABS-DID is
  protecting STRING .
  sort Did .
  subsort String < Did .
endm

view Did from TRIV to ABS-DID is
  sort Elt to Did .
endv

*** The interpreter could extend this module with his own definition
*** of label values.  For example, the model checker uses his own version
*** of labels.  This definition is the one used in the interpreter.
mod ABS-DATA-LABEL is

  extending ABS-DATA-SIG .
  protecting ABS-OID .

  sort Label .
  subsort Label < Data .

  op label : Oid Nat -> Label [ctor format (o o)] .
endm

view Label from TRIV to ABS-DATA-LABEL is
  sort Elt to Label .
endv


*** The DATATYPES module collects all predefined data types into one module.
mod ABS-DATATYPES is
    extending ABS-DATA-SIG .
    extending ABS-EXPRESSION .
    extending ABS-DATA-BOOL .
    extending ABS-DATA-LABEL .
    extending ABS-DATA-FLOAT .
    extending ABS-DATA-INT .
    extending ABS-DATA-STRING .
    extending ABS-DATA-TIME .
    extending ABS-OID .
endm


***
*** Binding variables to values.
***
*** Uses MAP from prelude.
***
mod ABS-SUBST is
  protecting ABS-DATATYPES .
  extending MAP{Vid, Data} * (sort Map{Vid,Data} to SSubst,
                              sort Entry{Vid,Data} to Binding,
                              op empty : -> Map{Vid,Data} to noSubst,
                              op insert : Vid Data Map{Vid,Data} -> Map{Vid,Data} to $insert ) .

  sort Subst .
  subsort SSubst < Subst .
  vars A A' : Vid .
  var AL : VidList .
  vars D D' : Data .
  var DL : DataList .
  var S1 : Subst . 
  var S2 : SSubst .

  *** Lazy composition operator for substitutions
  *** FIXME: make this operator have less precedence than |->

  op _::_ : Subst Subst -> Subst [assoc] .
  eq (S1 :: S2)[A] = if $hasMapping(S2, A) then S2[A] else S1[A] fi .

  op hasMapping : Subst Vid -> Bool .
  eq hasMapping(S2, A) = $hasMapping(S2, A) .
  eq hasMapping(S1 :: S2, A) = $hasMapping(S2, A) or hasMapping(S1, A) .

  op insert : Vid Data Subst -> Subst .
  eq insert(A, D, S2) = $insert(A, D, S2) .
  eq insert(A, D, S1 :: S2) = S1 :: $insert(A, D, S2) .

  *** Replace an existing binding even in the middle of the SSubst stack.
  op update : Vid Data Subst -> Subst .
  eq update(A, D, S1 :: S2) = if $hasMapping(S2, A) then S1 :: $insert(A, D, S2)
      else update(A, D, S1) :: S2 fi .
  ceq update(A, D, S2) = $insert(A, D, S2)
  if $hasMapping(S2, A) .       *** Block if no mapping exists.

  --- Create a substitution from a list of identifiers and data values.
  op createSubst : VidList DataList -> SSubst .
  eq createSubst(AL, DL) = $createSubst(noSubst, AL, DL) .
  op $createSubst : SSubst VidList DataList -> SSubst .
  eq $createSubst(S2, noVid, emp) = S2 .
  eq $createSubst(S2, (A, AL), (D :: DL)) = 
    $createSubst($insert(A, D, S2), AL, DL) .
endm



*** Abs Statements
***
*** The following module defines all elementary statements of Abs.
***
*** Colouring rules: Statements from the programmer syntax are displayed
*** in blue.  Statements inserted by the compiler only are displayed in
*** cyan.  Statements inserted by the run-time system are displayed in
*** red.  It may indicate a problem if a red term appears in a
*** configuration.

mod ABS-STATEMENT is

  protecting ABS-DATA-VIDLIST .
  protecting ABS-EXPRESSION .
  protecting ABS-SUBST .
  protecting ABS-CID .

  sort Stmt .

  op skip : -> Stmt [ctor format (b o)] .
  op suspend : -> Stmt [ctor format (b o)] .
  op await_ : Expr -> Stmt [ctor format (b o d)] .
  op assert_ : Expr -> Stmt [ctor format (b o d)] .
  op assign(_;_) : Vid Expr -> Stmt [ctor format (b d o b o b o)] .
  op new(_;_;_) : Vid String ExprList -> Stmt [ctor format (b d o b o b o b o)] .
  op call(_;_;_;_) : Vid Expr String ExprList -> Stmt [ctor format (b d o b o b o b o b o)] . 
  op get(_;_)  : Vid Vid -> Stmt [ctor format (b d o b o b o)] .
  op get(_;_)  : Label Vid -> Stmt [ctor ditto] .

  op return(_) : Expr -> Stmt [ctor format (c d o c o)] .
  op $mark(_) : Expr -> Stmt [ctor format (c d o c o)] .
  op $free(_) : Expr -> Stmt [ctor format (c d o c o)] .
  op tailcall(_;_;_) : Expr String ExprList -> Stmt [ctor format (c d o c o c o c o)] .
  op selftailcall(_;_) : String ExprList -> Stmt [ctor format (c d o c o c o)] .

  op $cont_ : Label -> Stmt [ctor format (r o d)] .

  op $beginscope : -> Stmt [ctor format (r o)] .
  op $vardecl(_;_) : Vid Expr -> Stmt [ctor format (r d o c o c o) ] .
  op $endscope : -> Stmt [ctor format(r o)] .

  --- Assertion Failure.
  --- This `statement' represents an assertion failure.  It 
  --- stops evaluation of the executing object at that point.
  op failure_ : Expr -> [Stmt] [ctor format (r! o d)] .

endm

view Stmt from TRIV to ABS-STATEMENT is
  sort Elt to Stmt .
endv



*** Specification of compound statements.
***
mod ABS-STM-LIST is
  protecting ABS-STATEMENT .                
  protecting LIST{Stmt} * (sort List{Stmt} to StmtList,
                           sort NeList{Stmt} to NeStmtList,
                           op nil : -> List{Stmt} to noStmt,
                           op __ : List{Stmt} List{Stmt} -> List{Stmt} to _;_ [format (d r o d)]) .

  op if_th_el_fi : Expr StmtList StmtList -> Stmt [ctor format (b o b o b o b o)] . 
  op while_do_od : Expr StmtList -> Stmt [ctor format (b o b o b o)] .

  var SL : StmtList .
  var E : Expr .

endm


mod ABS-PROCESS is

  protecting ABS-STM-LIST .

  sort Process .

  op idle : -> Process [ctor format (!b o)] .  
  op notFound : -> Process [ctor format (!b o)] .  
  op {_|_} : Subst StmtList -> Process [ctor format (r o rni o r o)] . 

  var L : Subst .
  eq { L | noStmt } = idle . --- if ".label" is needed this is dangerous!
  eq idle = { noSubst | noStmt } [nonexec metadata "Causes infinite loops."] .

endm

view Process from TRIV to ABS-PROCESS is
  sort Elt to Process .
endv


*** Specifies a process pool, here a multiset of Processes
***
mod ABS-PROCESS-POOL is
  protecting ABS-PROCESS .

  sort MProc .
  subsort Process < MProc .
  op noProc : -> MProc [ctor] .
  op _,_ : MProc MProc -> MProc
    [ctor assoc comm id: noProc prec 41 format (d r os d)] .

endm


*** A method declaration
***
mod ABS-METHOD is
  protecting ABS-STM-LIST .

  sort Method .
  op <_: Method | Param:_, Code:_> : 
    String VidList StmtList -> Method
    [ctor format (nic ! oc o d sc o d sc o c o)] .

endm

view Method from TRIV to ABS-METHOD is
  sort Elt to Method .
endv


*** Abs's state configuration.
***
*** Modeled after the CONFIGURATION module in "prelude.maude"
***
mod ABS-CONFIGURATION is
  protecting ABS-DATA-LABEL .
  protecting ABS-PROCESS-POOL .
  protecting ABS-OID .
  protecting ABS-DID .
  protecting SET{Method} * (sort Set{Method} to MMtd,
                            op empty : -> Set{Method} to noMethod) .
  protecting SET{String} * (sort Set{String} to StringSet) .
  protecting LIST{Did} * (sort List{Did} to DeltaList,
                         op nil : -> List{Did} to noDelta) .
 
  --- Define object identifiers.
  protecting CONVERSION .

  sorts Future Class Clock Delta .
  subsorts Class Future Clock Delta < Configuration .
  vars B M : String .
  var C : Cid .
  vars O O' : Oid .
  vars L S S1 : Subst .
  vars P P' : Process .
  vars MS MS1 : MMtd .
  var W : MProc .
  var AL : VidList .
  vars SL SL1 : StmtList .
  var EL : ExprList .
  var D : Data .
  var DL : DataList .
  var N : Label .
  vars F F' : Nat .
  var CN : Configuration .

  --- Invocation message.
  ---
  --- invoc(S,R,N,M,DL)
  --- S: The sender.
  --- R: The receiver.
  --- N: The label.
  --- M: The called method.
  --- DL: The actual arguments.
  op invoc(_,_,_,_,_) : Oid Oid Label String DataList -> Msg
    [ctor format (b d o  b so  b so  b so  b so b on)] .

  --- Error and warning messages are intended to stop the machine.
  --- For now, nothing is emitting these.
  --- op error(_) : String -> [Msg] [ctor format (nnr r o! or onn)] .
  op warning(_) : String -> [Msg] [ctor format (nnr! r! r! or onn)] .

  --- Terms of sort Object represent objects in the run-time configuration.
  ---
  op <_:_ | Att:_, Pr:_, PrQ:_, Lcnt:_> : 
    Oid Cid Subst Process MProc Nat -> Object 
    [ctor format (nr d d g ++r nir o  r ni o  r ni o  r ni o--  r on)] .

  --- Terms that represent futures.
  ---
  op <_: Future | Name:_, Completed:_, References:_, Value:_> :
    Label String Bool Nat Data -> Future
    [ctor format (nr d d g ++r ir o  r i o  r i o  r i o--  r on)] .

  --- Define Classes.
  --- Class declaration.
  ---
  op <_: Class | Deltas:_, Param:_, Att:_, Mtds:_, Ocnt:_> : 
    Cid DeltaList VidList Subst MMtd Nat -> Class 
    [ctor format (ng ! og o d  sg o d  sg o d  sg o d  sg++ o o  gni o-- g on)] .

  op <_: Clock | Limit:_> : Nat Nat -> Clock
    [ctor format(nb m! ob b b b m! b n)] .

  *** Define Deltas.

  op <_: Delta | AddedM:_, RemovedM:_ > : Did MMtd StringSet -> Delta
    [ctor format (nm ! om o d  sm++ o n  sm o-- m  on)] .

  *** Useful for real-time maude and some other tricks.
  *** We should not provide sort State, since this is used in LOOP-MODE.
  *** For now, we do.
  sort State .

  op {_} : Configuration -> State [ctor] .

endm


*** Definition of the family of evaluation functions.
***
mod ABS-EVAL is
  protecting ABS-CONFIGURATION .
  protecting ABS-DATA-VID .

  vars L L' : Label .
  vars E E' E'' : Expr .
  vars D D' : Data .
  var DL : DataList .
  var EL : ExprList .
  var NeEL : NeExprList .
  var CBL : CaseBranchList .
  vars A A' : Vid .
  var AL : VidList .
  vars Q C : String .
  vars S S' : Subst .
  var R : MatchResult .
  var SS : SSubst .
  vars ST ST' : Stmt . 
  vars SL SL1 SL2 : StmtList .
  var CN : Configuration .
  var CL : Class .
  var OB : Object .
  var MS : Msg .
  var N : Nat .
  var B : Bool .

  --- Check if a message is in the queue.
  op completed : Label Configuration -> Bool .
  eq completed(L, < L : Future | Name: Q, Completed: B, References: N, Value: D > CN) = B .
  eq completed(L, CN) = false [owise] .

  *** evaluate `Expr' with variable bindings `Subst', configuration
  *** `Configuration' and time `Nat' (constant 0 in the untimed case).
  op eval : Expr Subst Configuration Nat -> Data .
  op evalList : ExprList Subst Configuration Nat -> DataList [strat (1 0 0 0)] .
  op enabled : StmtList Subst Configuration Nat -> Bool .
  op ready : StmtList Subst Configuration Nat -> Bool .

  eq eval(D, S, CN, N) = D .

  *** Normal variable lookup.  Can be either instance or local variable.
  eq eval(@ Q, S, CN, N) =  S [@ Q] .
  *** Instance variable lookup.  The distinction between @@ and @ needs to be
  *** made in all lookup operations.
  eq eval(@@ Q, (SS :: S), CN, N) =  SS [@ Q] .
  *** Function expansions are expressions, subject to further evaluation.
  *** They are not evaluated in the current environment but in the environment
  *** in which they are defined (which is currently always empty).
  eq eval(Q(EL), S, CN, N) = eval(fdefn(Q), 
      createSubst(fparams(Q), evalList(EL, S, CN, N)), CN, N) .
  eq eval(Q [EL], S, CN, N) = Q [ evalList(EL, S, CN, N) ] .
  eq eval(?(@ Q), S, CN, N) = completed(S[@ Q], CN) asAbsBool .
  eq eval(?(@@ Q), (SS :: S), CN, N) = completed(SS[@ Q], CN) asAbsBool .
  eq eval(?(L), S, CN, N) = completed(L, CN) asAbsBool .
  eq eval(if E th E' el E'' fi, S, CN, N) =
    if eval(E, S, CN, N) asBool
    then eval(E', S, CN, N)
    else eval(E'', S, CN, N) fi .
  eq eval(let AL = EL in E, S, CN, N) = 
    eval(E, S :: createSubst(AL, evalList(EL, S, CN, N)), CN, N) .

  *** evaluate a case statement.  If the pattern matches, augment environment
  *** with the resulting bindings.
  sort MatchResult .
  subsort Subst < MatchResult .
  op noMatch : -> MatchResult [ctor] .
  op match : Data Expr Subst -> MatchResult .
  eq match(D, E, S) = $match(D, E, S, noSubst) .
  op $match : Data Expr Subst MatchResult -> MatchResult .
  eq $match(D, E, S, noMatch) = noMatch .
  eq $match(D, D, S, R) = R .           *** matching two literals
  eq $match(D, @ "_", S, R) = R .       *** "Don't care" placeholder
  eq $match(D, A, S, R) =               *** Create / check variable binding
    if hasMapping(S, A)
    then
      $match(D, S[A], S, R)
    else
      if hasMapping(R, A)
      then $match(D, R[A], S, R)       *** Match against existing binding
      else insert(A, D, R)             *** Generate new binding
      fi
    fi .
  eq $match(Q[D :: DL], Q[E :: EL], S, R) = *** Destructure constructor pattern
    $match(Q[DL], Q[EL], S, $match(D, E, S, R)) .
  eq $match(D, E, S, R) = noMatch [owise] .

  *** internal operator $case avoids endless loop between "case D of" and
  *** "case E of" when first case branch doesn't match
  op $case : Data CaseBranchList -> Expr .
  ceq eval($case(D, (E => E') ; CBL), S, CN, N) = 
    if R == noMatch
    then eval($case(D, CBL), S, CN, N)
    else eval(E', S :: R, CN, N) fi
  if R := match(D, E, S) .
  *** eq eval($case(D, noBranch), S, CN) = $error("No match in case expression") .

  eq eval(case E of { CBL }, S, CN, N) = 
    eval($case(eval(E, S, CN, N), CBL), S, CN, N) .

  --- Evaluate lists of expressions.
  eq evalList(emp, S, CN, N) = emp .
  eq evalList(DL, S, CN, N) = DL .
  eq evalList(E, S, CN, N) = eval(E, S, CN, N) .
  eq evalList(E :: NeEL, S, CN, N) =
    eval(E, S, CN, N) :: evalList(NeEL, S, CN, N) .

  --- Enabledness
  eq enabled(await E ; SL, S, CN, N) = eval(E, S, CN, N) asBool .
  eq enabled(SL, S, CN, N) = true [owise] .

  --- The ready predicate holds, if a statement is ready for execution,
  --- i.e., the corresponding process may be waken up.
  eq ready(get(@ Q ; A') ; SL , S, CN, N) = completed(S[@ Q], CN) . 
  eq ready(get(@@ Q ; A') ; SL , (SS :: S), CN, N) = completed(SS[@ Q], CN) . 
  eq ready(get(L ; A') ; SL , S, CN, N) = completed(L, CN) . 
  eq ready(SL, S, CN, N) = enabled(SL, S, CN, N) [owise] .

  *** Evaluate various builtin functions.

  *** ABS-DATA-BOOL
  eq eval($builtin("=="), S, CN, N) = (S[@ "D1"] == S[@ "D2"]) asAbsBool .
  eq eval($builtin("/="), S, CN, N) = (S[@ "D1"] =/= S[@ "D2"]) asAbsBool .
  eq eval($builtin("~"), S, CN, N) = (not ((S[@ "D"]) asBool)) asAbsBool .
  eq eval($builtin("&&"), S, CN, N) = ((S[@ "D1"]) asBool and (S[@ "D2"]) asBool) asAbsBool .
  eq eval($builtin("||"), S, CN, N) = ((S[@ "D1"]) asBool or (S[@ "D2"]) asBool) asAbsBool .
  
  *** ABS-DATA-INT
  eq eval($builtin("--"), S, CN, N) = "int"[-(S[@ "I"]) asInt] .
  ceq eval($builtin("+"), S, CN, N) = "int"[I1:Int + I2:Int]
  if "int"[I1:Int] := S[@ "I1"] /\ "int"[I2:Int] := S[@ "I2"] .
  eq eval($builtin("-"), S, CN, N) = "int"[(S[@ "I1"]) asInt - (S[@ "I2"]) asInt] .
  eq eval($builtin("*"), S, CN, N) = "int"[(S[@ "I1"]) asInt * (S[@ "I2"]) asInt] .
  eq eval($builtin("/"), S, CN, N) = "int"[(S[@ "I1"]) asInt quo (S[@ "I2"]) asInt] .
  eq eval($builtin("%"), S, CN, N) = "int"[(S[@ "I1"]) asInt rem (S[@ "I2"]) asInt] .
  eq eval($builtin("<"), S, CN, N) = ((S[@ "I1"]) asInt < (S[@ "I2"]) asInt) asAbsBool .
  eq eval($builtin("<="), S, CN, N) = ((S[@ "I1"]) asInt <= (S[@ "I2"]) asInt) asAbsBool .
  eq eval($builtin(">"), S, CN, N) = ((S[@ "I1"]) asInt > (S[@ "I2"]) asInt) asAbsBool .
  eq eval($builtin(">="), S, CN, N) = ((S[@ "I1"]) asInt >= (S[@ "I2"]) asInt) asAbsBool .
  *** ABS-DATA-STRING
  ceq eval($builtin("+"), S, CN, N) = "str"[I1:String + I2:String]
  if "str"[I1:String] := S[@ "I1"] /\ "str"[I2:String] := S[@ "I2"] .
  eq eval($builtin("substr"), S, CN, N) =
    "str"[substr((S[@ "S"]) asString, (S[@ "L"]) asInt, (S[@ "R"]) asInt)] .
  eq eval($builtin("strlen"), S, CN, N) =
    "int"[length((S[@ "S"]) asString)] .
  *** ABS-DATA-TIME
  --- N will be 0 in the untimed case.
  eq eval($builtin("currentms"), S, CN, N) = "int"[N] .

endm

mod ABS-MSG-TRANSPORT is
  protecting ABS-CONFIGURATION .

  var M : String .      var MIS : MMtd .     vars AL AL' : VidList .
  vars S S1 : Subst .   var SL : StmtList .  var N : Label .
  var DL : DataList .   var C : Cid .        var DeL : DeltaList .
  vars F G : Nat .      vars O O1 : Oid .    var P : Process .
  var W : MProc .       var MI : Method .    var D : Did .
  var MS : StringSet .


  op findMethod : String Cid DeltaList Label Oid DataList -> Msg .
  op foundMethod : Method Label Oid DataList -> Msg .

  eq
    findMethod(M, C, noDelta, N, O, DL)
    < C : Class | Deltas: DeL, Param: AL', Att: S1 , 
                  Mtds: (MIS, < M : Method | Param: AL, Code: SL >),
                  Ocnt: G >
  =
    foundMethod(< M : Method | Param: AL, Code: SL >, N, O, DL)
    < C : Class | Deltas: DeL, Param: AL', Att: S1, 
                  Mtds: (MIS, < M : Method | Param: AL, Code: SL >),
                  Ocnt: G > .

  eq
    findMethod(M, C, (DeL D), N, O, DL)
    < D : Delta | AddedM: (MIS, < M : Method | Param: AL, Code: SL >), 
                  RemovedM: MS >
  =
    foundMethod(< M : Method | Param: AL, Code: SL >, N, O, DL)
    < D : Delta | AddedM: < M : Method | Param: AL, Code: SL >, 
                  RemovedM: MS > .

  eq
    findMethod(M, C, (DeL D), N, O, DL)
    < D : Delta | AddedM: MIS, RemovedM: (MS, M) >
  =
    foundMethod(noMethod, N, O, DL)
    < D : Delta | AddedM: MIS, RemovedM: (MS, M) > .

  eq
    findMethod(M, C, (DeL D), N, O, DL)
    < D : Delta | AddedM: MIS, RemovedM: MS >
  =
    findMethod(M, C, DeL, N, O, DL)
    < D : Delta | AddedM: MIS, RemovedM: MS > [owise] . 



  --- transport
  ---
  --- Receive an invocation message to bind the method body.  We never make
  --- this a rule -- scheduling is done elsewhere.
  ---
  eq
    < O : C | Att: S, Pr: P, PrQ: W, Lcnt: F >
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS , Ocnt: G >
    invoc(O1, O, N, M, DL)
  =
    findMethod(M, C, DeL, N, O, DL)
    < O : C | Att: S, Pr: P, PrQ: W, Lcnt: F >
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MIS , Ocnt: G >
    [label transport-imsg] .

  eq
    < O : C | Att: S1, Pr: P, PrQ: W, Lcnt: F >
    foundMethod(< M : Method | Param: AL, Code: SL >, N, O, DL)
  =
    < O : C | Att: S1, Pr: P, PrQ: (W, makeProcess(< M : Method | Param: AL, Code: SL >, N, DL)), Lcnt: F >
    < N : Future | Name: M, Completed: false, References: 1, Value: null >
    [label transport-imsg-2] .

  op makeProcess : Method Label DataList -> Process .
  eq makeProcess(< M : Method | Param: AL, Code: SL >, N, DL)
  =
    { @ ".label" |-> N, @ ".method" |-> "str"[ M ], @ ".staticfuture" |-> null, @ "_" |-> null, createSubst(AL, DL) | SL } .


  --- Fetch pair { code |  vars } to bind call to process.
  ---
  --- M   represents the name of the method.
  --- MIS  represents the methods we search through.
  --- N   represents the label used to return the value computed by the
  ---     method.
  --- DL  represents the list of actual arguments.
  op makeProcessOLD : String MMtd Label DataList -> Process .

  eq makeProcessOLD(M, (MIS, < M : Method | Param: AL, Code: SL >), N, DL) =
    { @ ".label" |-> N, @ ".method" |-> "str"[ M ], @ ".staticfuture" |-> null, @ "_" |-> null, createSubst(AL, DL) | SL } .
  eq makeProcessOLD(M, MIS, N, DL) = notFound [owise] .
endm


*** The machine.
***
*** We have one module per statement per evaluation strategy, and combine them
*** in the end.


*** Some common functionality: scheduling, trivial statements that are always
*** equations, etc.
mod ABS-MACHINE-BASICS is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .         var C : Cid .        vars S S1 L : Subst .
  var SL : StmtList .       var W : MProc .      vars F G : Nat .
  var CN : Configuration .  var P : Process .    var A : Vid .
  var E : Expr .            var AL : VidList .   var N : Label .
  var Q : String .          var MS : MMtd .      var CO : Bool .
  var D : Data .            var DL : DataList .  var S2 : SSubst .
  var DeL : DeltaList .

  --- Schedule a new process for execution, if it is ready.
  ---
  --- Must be a rule to preserve confluence.
  ---
  --- We capture the entire state here since the condition E can depend on the
  --- state of Futures contained in CN.
  crl
    { < O : C | Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F > CN  }
  =>
    { < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > CN  }
  if ready(SL, (S :: L), CN, 0)
      [label PrQ-ready] .

  --- mark
  ---
  --- Mark a label in use.  We don't bother to make this a rule until we need
  --- it.
  ceq
    < O : C | Att: S, Pr: { L | $mark(E) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G + 1, Value: D >
  if N := eval(E, (S :: L), none, 0)
      [label mark] .

  --- free
  ---
  --- Free a Future.
  ---
  ceq
    < O : C | Att: S, Pr: { L | $free(E) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, 
                   References: if G == 0 then 0 else sd(G, 1) fi,
                   Value: D >
  if N := eval(E, (S :: L), none, 0)
      [label free] .

  --- Skip the $free instruction if the variable is uninitialized.  This helps
  --- the code generator.
  ceq
    < O : C | Att: S, Pr: { L | $free(A) ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
  if null = (S :: L)[A]
      [label free-uninitialized] .

  --- Completed futures without references can be removed.
  ---
  eq < N : Future | Name: Q, Completed: true, References: 0, Value: D > = none .

  --- Create a new environment.  This is for supporting local declarations in
  --- blocks etc.
  eq
    < O : C | Att: S, Pr: { L | $beginscope ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L :: noSubst | SL }, PrQ: W, Lcnt: F >
    [label $beginscope] .

  --- Introduce a new variable into the local scope.
  eq
    < O : C | Att: S, Pr: { L | $vardecl( A ; E ) ; SL}, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { insert(A, eval(E, (S :: L), none, 0), L) | SL }, PrQ: W, Lcnt: F >
    [label $vardecl] .

  eq
    < O : C | Att: S, Pr: { L :: S2 | $endscope ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label $endscope-1] .
  eq
    < O : C | Att: S, Pr: { S2 | $endscope ; SL }, PrQ: W, Lcnt: F >
  =
    *** Shouldn't happen, but can't harm
    < O : C | Att: S, Pr: { S2 | SL }, PrQ: W, Lcnt: F >
    [label $endscope-2] .


  --- assert
  ---
  eq
    { < O : C | Att: S, Pr: { L | assert(E) ; SL }, PrQ: W, Lcnt: F > CN  }
  =
    { if eval(E, (S :: L), CN, 0) asBool then
        < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      else
        < O : C | Att: S, Pr: { L | failure(E) ; SL }, PrQ: W, Lcnt: F >
      fi CN  }
    [label assert] .
endm
mod ABS-MACHINE-BASICS-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .         var C : Cid .        vars S S1 L : Subst .
  var SL : StmtList .       var W : MProc .      vars F G : Nat .
  var CN : Configuration .  var P : Process .    var A : Vid .
  var E : Expr .            var AL : VidList .   var N : Label .
  var Q : String .          var MS : MMtd .      var CO : Bool .
  var D : Data .            var DL : DataList .  var S2 : SSubst .
  vars T LIM : Nat .        var DeL : DeltaList .

  --- Schedule a new process for execution, if it is ready.
  ---
  --- Must be a rule to preserve confluence.
  ---
  --- We capture the entire state here since the condition E can depend on the
  --- state of Futures contained in CN.
  crl
    { < O : C | Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  =>
    { < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  if ready(SL, (S :: L), CN, T)
      [label PrQ-ready] .

  --- mark
  ---
  --- Mark a label in use.  We don't bother to make this a rule until we need
  --- it.
  ceq
    < O : C | Att: S, Pr: { L | $mark(E) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
    < T : Clock | Limit: LIM >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G + 1, Value: D >
    < T : Clock | Limit: LIM >
  if N := eval(E, (S :: L), none, T)
      [label mark] .

  --- free
  ---
  --- Free a Future.
  ---
  ceq
    < O : C | Att: S, Pr: { L | $free(E) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, References: G, Value: D >
    < T : Clock | Limit: LIM >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: CO, 
                   References: if G == 0 then 0 else sd(G, 1) fi,
                   Value: D >
    < T : Clock | Limit: LIM >
  if N := eval(E, (S :: L), none, T)
      [label free] .

  --- Skip the $free instruction if the variable is uninitialized.  This helps
  --- the code generator.
  ceq
    < O : C | Att: S, Pr: { L | $free(A) ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
  if null = (S :: L)[A]
      [label free-uninitialized] .

  --- Completed futures without references can be removed.
  ---
  eq < N : Future | Name: Q, Completed: true, References: 0, Value: D > = none .

  --- Create a new environment.  This is for supporting local declarations in
  --- blocks etc.
  eq
    < O : C | Att: S, Pr: { L | $beginscope ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L :: noSubst | SL }, PrQ: W, Lcnt: F >
    [label $beginscope] .

  --- Introduce a new variable into the local scope.
  eq
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | $vardecl( A ; E ) ; SL}, PrQ: W, Lcnt: F >
  =
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { insert(A, eval(E, (S :: L), none, T), L) | SL }, PrQ: W, Lcnt: F >
    [label $vardecl] .

  *** TODO: release labels that are going out of scope here.
  eq
    < O : C | Att: S, Pr: { L :: S2 | $endscope ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label $endscope-1] .
  eq
    < O : C | Att: S, Pr: { S2 | $endscope ; SL }, PrQ: W, Lcnt: F >
  =
    *** Shouldn't happen, but can't harm
    < O : C | Att: S, Pr: { S2 | SL }, PrQ: W, Lcnt: F >
    [label $endscope-2] .


  --- assert
  ---
  eq
    { < O : C | Att: S, Pr: { L | assert(E) ; SL }, PrQ: W, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  =
    { if eval(E, (S :: L), CN, T) asBool then
        < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      else
        < O : C | Att: S, Pr: { L | failure(E) ; SL }, PrQ: W, Lcnt: F >
      fi
      < T : Clock | Limit: LIM >
      CN  }
    [label assert] .

  *** Clock advancement.

  op noneready : MProc Subst Configuration Nat -> Bool .
  eq noneready((W, { L | SL }), S, CN, T) =
    not ready(SL, (S :: L), CN, T) and noneready(W, S, CN, T) .
  eq noneready(noProc, S, CN, T) = true .

  op canAdvance : Configuration Nat -> Bool .
  *** Block clock if a method invocation is on its way.
  eq canAdvance (m:Msg CN, T) = false .
  *** Block clock if object is idle but has processes that can be scheduled.
  eq canAdvance (
      < O : C | Att: S, Pr: idle, PrQ: W, Lcnt: F > 
      CN, T) =
    noneready(W, S, CN, T) and canAdvance (CN, T) .
  *** Block clock if process is executing and can execute.
  eq canAdvance (
      < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
      CN, T)
  =
    not(enabled(SL, (S :: L), CN, T)) and canAdvance(CN, T) .
  eq canAdvance(CN, T) = true [owise] .


  *** Now advance the clock.
  crl
    { CN < T : Clock | Limit: LIM > }
  =>
    { CN
      < T + 1 : Clock | Limit: LIM >  }
  if canAdvance (CN, T) and T < LIM
      [label tick] .

endm



*** The Skip statement.
mod ABS-STMT-SKIP-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .

  rl
    < O : C | Att: S, Pr: { L | skip ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label skip] .
endm
mod ABS-STMT-SKIP-EQ is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .

  eq
    < O : C | Att: S, Pr: { L | skip ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
    [label skip] .
endm

*** The Assign statement.
  
*** Execute an assignment.  The expression on the right hand side of the
*** assignment is evaluated and stored as new value for the left hand side
*** identifier.
mod ABS-STMT-ASSIGN-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var Q : String .

  *** Variable or field assignment
  crl
    < O : C | Att: S, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W, Lcnt: F > 
  =>
    if hasMapping(L, @ Q) then
      < O : C | Att: S, Pr: { update(@ Q, D, L) |  SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Att: insert(@ Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F > 
    fi
    if D := eval(E, (S :: L), none, 0)
    [label assignment] .

  *** Field assignment
  crl
    < O : C | Att: S, Pr: { L | assign(@@ Q ; E) ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: insert(@ Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F >
  if D := eval(E, (S :: L), none, 0)
    [label field-assignment] .
endm
mod ABS-STMT-ASSIGN-EQ is
  protecting ABS-EVAL .
  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var Q : String .

  *** Variable or field assignment.
  ceq
    < O : C | Att: S, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W, Lcnt: F > 
  =
    if hasMapping(L, @ Q) then
      < O : C | Att: S, Pr: { update(@ Q, D, L) |  SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Att: insert(@ Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F > 
    fi
    if D := eval(E, (S :: L), none, 0)
    [label assignment] .

  *** Field assignment.
  ceq
    < O : C | Att: S, Pr: { L | assign(@@ Q ; E) ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: insert(@ Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F >
  if D := eval(E, (S :: L), none, 0)
    [label field-assignment] .
endm
mod ABS-STMT-ASSIGN-EQ-TIMED is
  protecting ABS-EVAL .
  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .       var D : Data .   var Q : String .
  vars T LIM : Nat .

  *** Variable or field assignment.
  ceq
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | assign(@ Q ; E) ; SL }, PrQ: W, Lcnt: F > 
  =
    < T : Clock | Limit: LIM >
    if hasMapping(L, @ Q) then
      < O : C | Att: S, Pr: { update(@ Q, D, L) |  SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Att: insert(@ Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F > 
    fi
    if D := eval(E, (S :: L), none, T)
    [label assignment] .

  *** Field assignment.
  ceq
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | assign(@@ Q ; E) ; SL }, PrQ: W, Lcnt: F >
  =
    < T : Clock | Limit: LIM >
    < O : C | Att: insert(@ Q, D, S), Pr: { L | SL }, PrQ: W, Lcnt: F >
  if D := eval(E, (S :: L), none, T)
    [label field-assignment] .
endm

*** The conditional (if_then_else) statement.
mod ABS-STMT-COND-RL is
  protecting ABS-EVAL .

  var O : Oid .                 var C : Cid .    vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .

  rl
    < O : C | Att: S, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W, Lcnt: F >
  =>
    if eval(E, (S :: L), none, 0) asBool then
      < O : C | Att: S, Pr: { L | SL1 ; SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Att: S, Pr: { L | SL2 ; SL }, PrQ: W, Lcnt: F >
    fi
    [label if-then-else] .
endm
mod ABS-STMT-COND-EQ is
  protecting ABS-EVAL .

  var O : Oid .                 var C : Cid .    vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .

  eq
    < O : C | Att: S, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W, Lcnt: F >
  =
    if eval(E, (S :: L), none, 0) asBool then
      < O : C | Att: S, Pr: { L | SL1 ; SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Att: S, Pr: { L | SL2 ; SL }, PrQ: W, Lcnt: F >
    fi
    [label if-then-else] .
endm
mod ABS-STMT-COND-EQ-TIMED is
  protecting ABS-EVAL .

  var O : Oid .                 var C : Cid .    vars S L : Subst .
  vars SL SL1 SL2 : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .                vars T LIM : Nat .

  eq
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | if E th SL1 el SL2 fi ; SL }, PrQ: W, Lcnt: F >
  =
    < T : Clock | Limit: LIM >
    if eval(E, (S :: L), none, T) asBool then
      < O : C | Att: S, Pr: { L | SL1 ; SL }, PrQ: W, Lcnt: F >
    else
      < O : C | Att: S, Pr: { L | SL2 ; SL }, PrQ: W, Lcnt: F >
    fi
    [label if-then-else] .
endm

*** The looping (while) statement.
mod ABS-STMT-WHILE-RL is
  protecting ABS-EVAL .
  var O : Oid .             var C : Cid .    vars S L : Subst .
  vars SL SL1 : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .

  rl
    < O : C | Att: S, Pr: { L | while E do SL1 od ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: S,
              Pr: { L | if E th (SL1 ; while E do SL1 od) el noStmt fi ; SL },
              PrQ: W, Lcnt: F >
    [label while] .
endm
mod ABS-STMT-WHILE-EQ is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  vars SL SL1 : StmtList .  var W : MProc .  var F : Nat .
  var E : Expr .

  eq
    < O : C | Att: S, Pr: { L | while E do SL1 od ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S,
              Pr: { L | if E th (SL1 ; while E do SL1 od) el skip fi ; SL },
              PrQ: W, Lcnt: F >
    [label while] .
endm

*** The Suspend statement.
***
*** The suspend statement is an unconditional processor release point.
mod ABS-STMT-SUSPEND-RL is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .

  rl
    < O : C | Att: S, Pr: { L | suspend ; SL }, PrQ: W, Lcnt: F >
  =>
    < O : C | Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F >
    [label suspend] .
endm
mod ABS-STMT-SUSPEND-EQ is
  protecting ABS-EVAL .

  var O : Oid .        var C : Cid .    vars S L : Subst .
  var SL : StmtList .  var W : MProc .  var F : Nat .

  eq
    < O : C | Att: S, Pr: { L | suspend ; SL }, PrQ: W, Lcnt: F >
  =
    < O : C | Att: S, Pr: idle, PrQ: W , { L | SL }, Lcnt: F >
    [label suspend] .
endm

*** The Await statement.
  
*** These rules capture the entire state CN since the condition E can depend
*** on the state of Futures (and therefore CN needs to be passed to
*** "enabled").
mod ABS-STMT-AWAIT-RL is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   var Q : String .

  rl
    { < O : C | Att: S, Pr: { L | await E ; SL }, PrQ: W, Lcnt: F > CN  }
  =>
    if enabled(await E, (S :: L), CN, 0) then
      { < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > CN  }
    else
      { < O : C | Att: S, Pr: idle, PrQ: W , { L | await E ; SL}, Lcnt: F > CN  }
    fi
      [label await] .
endm
mod ABS-STMT-AWAIT-EQ is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   var Q : String .

  eq
    { < O : C | Att: S, Pr: { L | await E ; SL }, PrQ: W, Lcnt: F > CN  }
  =
    if enabled(await E, (S :: L), CN, 0) then
      { < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > CN  }
    else
      { < O : C | Att: S, Pr: idle, PrQ: W , { L | await E ; SL}, Lcnt: F > CN  }
    fi
      [label await] .
endm
mod ABS-STMT-AWAIT-EQ-TIMED is
  protecting ABS-EVAL .

  var O : Oid .             var C : Cid .    vars S L : Subst .
  var SL : StmtList .       var W : MProc .  var F : Nat .
  var CN : Configuration .  var E : Expr .   var Q : String .
  vars T LIM : Nat .

  eq
    { < O : C | Att: S, Pr: { L | await E ; SL }, PrQ: W, Lcnt: F >
      < T : Clock | Limit: LIM >
      CN  }
  =
    if enabled(await E, (S :: L), CN, T) then
      { < O : C | Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F >
        < T : Clock | Limit: LIM >
        CN  }
    else
      { < O : C | Att: S, Pr: idle, PrQ: W , { L | await E ; SL}, Lcnt: F > 
        < T : Clock | Limit: LIM >
        CN  }
    fi
      [label await] .
endm

*** METHOD CALLS
mod ABS-CALLSTMTS-RL is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .         var C : Cid .        vars S S1 L : Subst .
  var SL : StmtList .       var W : MProc .      vars F G : Nat .
  var CN : Configuration .  var E : Expr .       var Q : String .
  var A : Vid .             var EL : ExprList .  var AL : VidList .
  var N : Label .           var DL : DataList .  var MS : MMtd .
  var DeL : DeltaList .

  --- remote-async-call
  ---
  crl
    < O : C | Att: S, Pr: { L | call(A ; E ; Q ; EL); SL }, PrQ: W, Lcnt: F > 
  =>
    < O : C | Att: S, Pr: { L | assign(A ; N) ; SL }, PrQ: W, Lcnt: (s F) > 
    invoc(O, O1, N, Q , DL)
  if DL :=  evalList(EL, (S :: L), none, 0)
      /\ O1 := eval(E, (S :: L), none, 0)
      /\ N := label(O, F)
      [label remote-async-call] .

  --- TAIL CALLS
  ---
  --- "pass on" our return label to the new process.
  ---
  ---  FIXME (rs 2010-06-15): `invoc' creates a new Future - this is not what
  --- we want in this case.  Not so urgent since the `tailcall' statement is
  --- not emitted in the code generator currently.
  ---
  rl
    < O : C | Att: S, Pr: { L | tailcall(E ; Q ; EL) ; SL }, PrQ: W, Lcnt: F > 
  =>
    < O : C | Att: S, Pr: { update(@ ".label", null, L) | SL }, PrQ: W, Lcnt: F >
    invoc(O, eval(E, (S :: L), none, 0), L[@ ".label"], Q, evalList(EL, (S :: L), none, 0))
    [label tailcall] .

  --- STATIC TAIL CALLS
  ---
  --- Block if the `selftailcall' statement is followed by any more
  --- statements.  If necessary, this could be replaced by putting `$cont' at
  --- the end of the current process.
  rl
    < O : C | Att: S, Pr: { L | selftailcall(Q ; EL) }, PrQ: W, Lcnt: F > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  =>
    < O : C | Att: S, Pr: makeProcessOLD(Q, MS, L[@ ".label"], evalList(EL, (S :: L), none, 0)), PrQ: W, Lcnt: F >
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  [label selftailcall] .

endm  
mod ABS-CALLSTMTS-EQ is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .         var C : Cid .        vars S S1 L : Subst .
  var SL : StmtList .       var W : MProc .      vars F G : Nat .
  var CN : Configuration .  var E : Expr .       var Q : String .
  var A : Vid .             var EL : ExprList .  var AL : VidList .
  var N : Label .           var DL : DataList .  var MS : MMtd .
  var DeL : DeltaList .

  --- remote-async-call
  ---
  ceq
    < O : C | Att: S, Pr: { L | call(A ; E ; Q ; EL); SL }, PrQ: W, Lcnt: F > 
  =
    < O : C | Att: S, Pr: { L | assign(A ; N) ; SL }, PrQ: W, Lcnt: (s F) > 
    invoc(O, O1, N, Q , DL)
  if DL :=  evalList(EL, (S :: L), none, 0)
      /\ O1 := eval(E, (S :: L), none, 0)
      /\ N := label(O, F)
      [label remote-async-call] .

  --- TAIL CALLS
  ---
  --- "pass on" our return label to the new process.
  ---
  ---  FIXME (rs 2010-06-15): `invoc' creates a new Future - this is not what
  --- we want in this case.  Not so urgent since the `tailcall' statement is
  --- not emitted in the code generator currently.
  ---
  eq
    < O : C | Att: S, Pr: { L | tailcall(E ; Q ; EL) ; SL }, PrQ: W, Lcnt: F > 
  =
    < O : C | Att: S, Pr: { update(@ ".label", null, L) | SL }, PrQ: W, Lcnt: F >
    invoc(O, eval(E, (S :: L), none, 0), L[@ ".label"], Q, evalList(EL, (S :: L), none, 0))
    [label tailcall] .

  --- STATIC TAIL CALLS
  ---
  --- Currently block if the `selftailcall' statement is followed by any more
  --- statements.
  eq
    < O : C | Att: S, Pr: { L | selftailcall(Q ; EL) }, PrQ: W, Lcnt: F > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  =
    < O : C | Att: S, Pr: makeProcessOLD(Q, MS, L[@ ".label"], evalList(EL, (S :: L), none, 0)), PrQ: W, Lcnt: F >
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  [label selftailcall] .
endm
mod ABS-CALLSTMTS-EQ-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  vars O O1 : Oid .         var C : Cid .         vars S S1 L : Subst .
  var SL : StmtList .       var W : MProc .       vars F G : Nat .
  var CN : Configuration .  var E : Expr .        var Q : String .
  var A : Vid .             var EL : ExprList .   var AL : VidList .
  var N : Label .           var DL : DataList .   var MS : MMtd .
  vars T LIM : Nat .        var DeL : DeltaList .

  --- remote-async-call
  ---
  ceq
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | call(A ; E ; Q ; EL); SL }, PrQ: W, Lcnt: F > 
  =
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | assign(A ; N) ; SL }, PrQ: W, Lcnt: (s F) > 
    invoc(O, O1, N, Q , DL)
  if DL :=  evalList(EL, (S :: L), none, T)
      /\ O1 := eval(E, (S :: L), none, T)
      /\ N := label(O, F)
      [label remote-async-call] .

  --- TAIL CALLS
  ---
  --- "pass on" our return label to the new process.
  ---
  ---  FIXME (rs 2010-06-15): `invoc' creates a new Future - this is not what
  --- we want in this case.  Not so urgent since the `tailcall' statement is
  --- not emitted in the code generator currently.
  ---
  eq
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | tailcall(E ; Q ; EL) ; SL }, PrQ: W, Lcnt: F > 
  =
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { update(@ ".label", null, L) | SL }, PrQ: W, Lcnt: F >
    invoc(O, eval(E, (S :: L), none, T), L[@ ".label"], Q, evalList(EL, (S :: L), none, T))
    [label tailcall] .

  --- STATIC TAIL CALLS
  ---
  --- Currently block if the `selftailcall' statement is followed by any more
  --- statements.
  eq
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | selftailcall(Q ; EL) }, PrQ: W, Lcnt: F > 
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  =
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: makeProcessOLD(Q, MS, L[@ ".label"], evalList(EL, (S :: L), none, T)), PrQ: W, Lcnt: F >
    < C : Class | Deltas: DeL, Param: AL, Att: S1 , Mtds: MS , Ocnt: G >
  [label selftailcall] .
endm


*** OBJECT CREATION
  
*** Also start the ".init" method.
mod ABS-NEW-RL is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  var O : Oid .        vars B C : Cid .  vars S S1 L : Subst .
  var SL : StmtList .  var W : MProc .   vars F G : Nat .
  var E : Expr .       var A : Vid .     var EL : ExprList .
  var AL : VidList .   var MS : MMtd .   var DeL : DeltaList .

  rl
    < O : C | Att: S, Pr: { L | new(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =>
    < O : C | Att: S, Pr: { L | assign(A ; newId(B, G)); SL }, PrQ: W,
              Lcnt: (s F) >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < newId(B, G) :  B | Att: (@ "this" |-> newId(B, G), S1,
                               createSubst(AL, evalList(EL, S :: L, none, 0))),
                         Pr: makeProcessOLD(".init", MS, label(O, F), emp), 
                         PrQ: noProc, Lcnt: 0 >
    [label new-object] .
endm
mod ABS-NEW-EQ is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  var O : Oid .        vars B C : Cid .  vars S S1 L : Subst .
  var SL : StmtList .  var W : MProc .   vars F G : Nat .
  var E : Expr .       var A : Vid .     var EL : ExprList .
  var AL : VidList .   var MS : MMtd .   var DeL : DeltaList .

  eq
    < O : C | Att: S, Pr: { L | new(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =
    < O : C | Att: S, Pr: { L | assign(A ; newId(B, G)); SL }, PrQ: W,
              Lcnt: (s F) >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < newId(B, G) :  B | Att: (@ "this" |-> newId(B, G), S1,
                               createSubst(AL, evalList(EL, S :: L, none, 0))),
                         Pr: makeProcessOLD(".init", MS, label(O, F), emp), 
                         PrQ: noProc, Lcnt: 0 >
    [label new-object] .
endm
mod ABS-NEW-EQ-TIMED is
  protecting ABS-EVAL .
  protecting ABS-MSG-TRANSPORT .

  var O : Oid .        vars B C : Cid .  vars S S1 L : Subst .
  var SL : StmtList .  var W : MProc .   vars F G : Nat .
  var E : Expr .       var A : Vid .     var EL : ExprList .
  var AL : VidList .   var MS : MMtd .   var DeL : DeltaList .
  vars T LIM : Nat .

  eq
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | new(A ; B ; EL); SL }, PrQ: W, Lcnt: F >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: G >
  =
    < T : Clock | Limit: LIM >
    < O : C | Att: S, Pr: { L | assign(A ; newId(B, G)); SL }, PrQ: W,
              Lcnt: (s F) >
    < B : Class | Deltas: DeL, Param: AL, Att: S1, Mtds: MS, Ocnt: (s G) >
    < newId(B, G) :  B | Att: (@ "this" |-> newId(B, G), S1,
                               createSubst(AL, evalList(EL, S :: L, none, T))),
                         Pr: makeProcessOLD(".init", MS, label(O, F), emp), 
                         PrQ: noProc, Lcnt: 0 >
    [label new-object] .
endm


*** The Return statement.
mod ABS-STMT-RETURN-RL is
  protecting ABS-EVAL .

  vars O : Oid .        var C : Cid .    vars S L : Subst .
  vars SL : StmtList .  var W : MProc .  vars F G : Nat .
  var Q : String .      var N : Label .  var E : Expr .

  crl
    < O : C |  Att: S, Pr: { L | return(E); SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: false, References: G, Value: null >
   =>
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process.  We cannot return immediately since there might be
    *** `release' or `$endscope' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < O : C |  Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: true, References: G, Value: eval(E, (S :: L), none, 0) >
  if N == L[@ ".label"]
      [label return] .
endm
mod ABS-STMT-RETURN-EQ is
  protecting ABS-EVAL .

  vars O : Oid .        var C : Cid .    vars S L : Subst .
  vars SL : StmtList .  var W : MProc .  vars F G : Nat .
  var Q : String .      var N : Label .  var E : Expr .

  ceq
    < O : C |  Att: S, Pr: { L | return(E); SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: false, References: G, Value: null >
   =
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process.  We cannot return immediately since there might be
    *** `release' or `$endscope' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < O : C |  Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: true, References: G, Value: eval(E, (S :: L), none, 0) >
  if N == L[@ ".label"]
      [label return] .
endm
mod ABS-STMT-RETURN-EQ-TIMED is
  protecting ABS-EVAL .

  vars O : Oid .        var C : Cid .    vars S L : Subst .
  vars SL : StmtList .  var W : MProc .  vars F G : Nat .
  var Q : String .      var N : Label .  var E : Expr .
  vars T LIM : Nat .

  ceq
    < T : Clock | Limit: LIM >
    < O : C |  Att: S, Pr: { L | return(E); SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: false, References: G, Value: null >
   =
    *** NOTE (rs 2010-06-15) Note that a second return statement will deadlock
    *** the process.  We cannot return immediately since there might be
    *** `release' or `$endscope' statements after this, so we must rely on the
    *** compiler / type-checker to ascertain that there's one and only one
    *** return statement in each code branch.
    < T : Clock | Limit: LIM >
    < O : C |  Att: S, Pr: { L | SL }, PrQ: W, Lcnt: F > 
    < N : Future | Name: Q, Completed: true, References: G, Value: eval(E, (S :: L), none, T) >
  if N == L[@ ".label"]
      [label return] .
endm


*** Receiving results from Futures.
***
*** Major source of nondeterminism and non-confluence if carelessly made into
*** equations, according to Creol interpreter.  We leave them as rules for
*** now.
mod ABS-RECEIVE-RESULT is
  protecting ABS-EVAL .

  vars O : Oid .            var C : Cid .      vars S L L1 : Subst .
  vars SL SL1 : StmtList .  var W : MProc .    vars F G : Nat .
  var Q : String .          vars A A' : Vid .  var N : Label .
  var D : Data .

  --- receive-comp
  ---
  --- Must be a rule even in the model checker, because there might be
  --- multiple completion messages with the same label but different return
  --- values in the queue.
  ---
  rl
    < O : C |  Att: S, Pr: { L | get(N ; A) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
  =>
    < O : C |  Att: S, Pr: { L | assign(A ; D) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
    [label receive-comp-label] .

  crl
    < O : C |  Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
  =>
    < O : C |  Att: S, Pr: { L | assign(A' ; D) ; SL }, PrQ: W, Lcnt: F >
    < N : Future | Name: Q, Completed: true, References: G, Value: D >
  if N = (S :: L)[A]
    [label receive-comp-var] .


  --- local-reply
  ---
  --- This avoids deadlocks from synchronous self-calls by manually scheduling
  --- the process that is waited for, and afterwards manually scheduling the
  --- waiting process again (see `continue' rule below).
  crl
    < O : C | Att: S, Pr: { L | get(A ; A') ; SL }, PrQ: W , { L1 | SL1 }, Lcnt: F >
  =>
    < O : C | Att: S, Pr:  { L1 | SL1 ; $cont N },
              PrQ: W , { L | get(A ; A') ; SL }, Lcnt: F >
  if N := L[A] /\ L1[@ ".label"] == N
      [label local-reply] .


  --- continue
  ---
  --- Continue after executing the code of a local reply.  This is always a
  --- rule.  We want it to be a rule in the interpreter.  (RS 2010-07-12:
  --- why?)
  --- 
  --- If we support shared futures, this must be a rule in the model
  --- checker, because there might be two processes in PrQ which await a
  --- reply to the label.
  crl
    < O : C | Att: S, Pr: { L | $cont N }, PrQ: W , { L1 | get(A ; A') ; SL1},
              Lcnt: F >
  =>
    < O : C | Att: S, Pr: { L1 | get(A ; A') ; SL1 }, PrQ: W,
              Lcnt: F >
  if N == L1[A]
    [label continue] .
endm

mod ABS-SIMULATOR-RL is
  --- A machine using rewrite rules.
  protecting ABS-MACHINE-BASICS .
  protecting ABS-STMT-SKIP-RL .
  protecting ABS-STMT-ASSIGN-RL .
  protecting ABS-STMT-COND-RL .
  protecting ABS-STMT-WHILE-RL .
  protecting ABS-STMT-SUSPEND-RL .
  protecting ABS-STMT-AWAIT-RL .
  protecting ABS-CALLSTMTS-RL .
  protecting ABS-NEW-RL .
  protecting ABS-STMT-RETURN-RL .
  protecting ABS-RECEIVE-RESULT .

  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.
  op main : Configuration String DataList -> State .
  eq main(CN:Configuration, B:String, DL:DataList) =
    { CN:Configuration < ob("main") : Start | Att: noSubst, 
      Pr: { @ "var" |-> null | new(@ "var" ; B:String ; DL:DataList) },
      PrQ: noProc, Lcnt: 0 > } .

  --- The initial object commits suicide after it did its job.
  eq < ob("main") : Start | Att: noSubst, Pr: idle, PrQ: noProc, Lcnt: 1 > =
    none .
endm

mod ABS-SIMULATOR-EQ is
  --- A machine using equations.
  protecting ABS-MACHINE-BASICS .
  protecting ABS-STMT-SKIP-EQ .
  protecting ABS-STMT-ASSIGN-EQ .
  protecting ABS-STMT-COND-EQ .
  protecting ABS-STMT-WHILE-EQ .
  protecting ABS-STMT-SUSPEND-EQ .
  protecting ABS-STMT-AWAIT-EQ .
  protecting ABS-CALLSTMTS-EQ .
  protecting ABS-NEW-EQ .
  protecting ABS-STMT-RETURN-EQ .
  protecting ABS-RECEIVE-RESULT .

  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.
  op main : Configuration String DataList -> State .
  eq main(CN:Configuration, B:String, DL:DataList) =
    { CN:Configuration < ob("main") : Start | Att: noSubst, 
      Pr: { @ "var" |-> null | new(@ "var" ; B:String ; DL:DataList) },
      PrQ: noProc, Lcnt: 0 > } .

  --- The initial object commits suicide after it did its job.
  eq < ob("main") : Start | Att: noSubst, Pr: idle, PrQ: noProc, Lcnt: 1 > =
    none .
endm

mod ABS-SIMULATOR-EQ-TIMED is
  --- A machine using equations, with an auto-advancing clock.
  protecting ABS-MACHINE-BASICS-TIMED .
  protecting ABS-STMT-SKIP-EQ .
  protecting ABS-STMT-ASSIGN-EQ-TIMED .
  protecting ABS-STMT-COND-EQ-TIMED .
  protecting ABS-STMT-WHILE-EQ .
  protecting ABS-STMT-SUSPEND-EQ .
  protecting ABS-STMT-AWAIT-EQ-TIMED .
  protecting ABS-CALLSTMTS-EQ-TIMED .
  protecting ABS-NEW-EQ-TIMED .
  protecting ABS-STMT-RETURN-EQ-TIMED .
  protecting ABS-RECEIVE-RESULT .

  --- System initialisation with arbitrary class.  In Abs, the compiler will
  --- generate an operator "start" in the generated module that reduces to
  --- this, with an instantiation of the anonymous class implementing the
  --- block.  Still, this operator is useful by itself to create any active
  --- object by itself.  This version also creates the global clock, with a
  --- limit arbitrarily chosen to be 100.
  op main : Configuration String DataList -> State .
  eq main(CN:Configuration, B:String, DL:DataList) =
    { CN:Configuration
      < 0 : Clock | Limit: 100 >
      < ob("main") : Start | Att: noSubst, 
      Pr: { @ "var" |-> null | new(@ "var" ; B:String ; DL:DataList) },
      PrQ: noProc, Lcnt: 0 > } .

  --- The initial object commits suicide after it did its job.
  eq < ob("main") : Start | Att: noSubst, Pr: idle, PrQ: noProc, Lcnt: 1 > =
    none .
endm

eof

*** Local Variables:
*** maude-indent: 2
*** fill-column: 78
*** End:
