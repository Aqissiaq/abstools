import java.util.HashSet;

aspect TypeResolution {
  
    // Find the type declaration for a type use.
  
    syn boolean TypeDecl.isInterface();
    syn boolean TypeDecl.isDataType();
    syn boolean TypeDecl.isTypeSyn();
    syn boolean TypeDecl.isTypeParameter();
  
    eq TypeDecl.isInterface() = false;
    eq TypeDecl.isDataType() = false;
    eq TypeDecl.isTypeSyn() = false;
    eq TypeDecl.isTypeParameter() = false;

    eq InterfaceDecl.isInterface() = true;
    eq DataTypeDecl.isDataType() = true;
    eq TypeSynDecl.isTypeSyn() = true;
    eq TypeParameterDecl.isTypeParameter() = true;
  
    // Declaration of *decl*

    // *decl* refers to the appropriate declaration of the TypeUse or to
    // UnknownDecl if the declaration is missing
    syn lazy TypeDecl TypeUse.declaration();  

    // Declaration of *lookup*
    // Finds a declaration (TypeDecl) based on a name, or attribute
    // UnknownDecl if not found
    syn lazy TypeDecl Model.lookup(String name);
  
    // ***Implementation***
  
    //   Definitions of *decl*
    eq TypeUse.declaration() = lookup(getName());
  
    //   Definitions of *lookup*
    eq Model.getDecl().lookup(String name) = localLookup(name);
    eq Model.getBlock().lookup(String name) = localLookup(name); // Model's main block
    eq Model.lookup(String name) = localLookup(name);
  
    
    // Expose *lookup* at various places in the AST
    // Technically, this re-uses definition from Model.InterfaceDecl
    inh TypeDecl TypeUse.lookup(String name); 
    // FIXME: inh TypeDecl UnresolvedTypeUse.lookup(String name);

    // *localLookup* - looks through the local declarations in a block

    syn lazy TypeDecl Model.localLookup(String name) {
        for (Decl d : getDecls())
            if (d instanceof TypeDecl && d.getName().equals(name))
                return (TypeDecl)d;
        return unknownDecl();
    }
    
    rewrite UnresolvedTypeUse {
        when (declaration().isInterface())
            to InterfaceTypeUse new InterfaceTypeUse(getName());
        when (declaration().isDataType())
            to DataTypeUse new DataTypeUse(getName());
        when (declaration().isTypeSyn())
            to DataTypeUse new DataTypeUse(((TypeSynDecl)declaration()).getValue().getName());
        when (declaration().isTypeParameter())
        	to TypeParameterUse new TypeParameterUse(getName());
    }
    
    syn lazy TypeDecl Model.localLookupDataConstructor(DataConstructorExp e) {
        for (Decl d : getDecls()) {
            if (d instanceof DataTypeDecl) {
                DataTypeDecl dataDecl = (DataTypeDecl)d;
                for (DataConstructor c : dataDecl.getDataConstructors()) {
                    if (c.getName().equals(e.getConstructor())) {
                        // FIXME: check argument types
                        return dataDecl;
                    }
                }
            }
        }
        return unknownDecl();
    }
    
    syn lazy TypeDecl Model.lookupDataConstructor(DataConstructorExp c);
    eq Model.lookupDataConstructor(DataConstructorExp c) = localLookupDataConstructor(c);
    eq Model.getDecl().lookupDataConstructor(DataConstructorExp c) = localLookupDataConstructor(c);
    eq Model.getBlock().lookupDataConstructor(DataConstructorExp c) = localLookupDataConstructor(c);
    
    inh TypeDecl DataConstructorExp.lookupDataConstructor(DataConstructorExp c);
    
    syn lazy TypeDecl DataConstructorExp.declaration() {
        return lookupDataConstructor(this);
    }
    
}

// Local Variables:
// mode: java
// End:
