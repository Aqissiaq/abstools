aspect VarResolution {

    // Resolve variable use to their reference place and rewrite
    // according to the definition (local variable reference, field
    // reference, function parameter reference)

    syn boolean Pattern.hasVariable(String name);
    eq PatternVar.hasVariable(String name) = name.equals(getVar().getName());
    eq ConstructorPattern.hasVariable(String name) {
        for (Pattern param : getParams())
            if (param.hasVariable(name)) return true;
        return false;   
    }
    eq LiteralPattern.hasVariable(String name) = false;
    eq UnderscorePattern.hasVariable(String name) = false;

    // Differentiate between function parameters and other variables.
    // FIXME: this does not consider shadowing rebinding of variables
    // inside the function body, e.g. via `case' expressions.
    eq FunctionDecl.getFunDef().functionParameters() {
        List<VarOrFieldDecl> result = new List<VarOrFieldDecl>();
        for (ParamDecl v : getParams()) {
            result.add((VarOrFieldDecl)v.copy());
        }
        return result;
    }
    eq Block.getStmt(int index).functionParameters() = new List<VarOrFieldDecl>();
    eq CaseExp.getBranch(int index).functionParameters() {
        List<VarOrFieldDecl> result = new List<VarOrFieldDecl>();
        for (VarOrFieldDecl param : functionParameters())
            if (!getBranch(index).getLeft().hasVariable(param.getName()))
                result.add((VarOrFieldDecl)param.copy());
        return result;
    }
    eq LetExp.getExp().functionParameters() {
        List<VarOrFieldDecl> result = new List<VarOrFieldDecl>();
        // oh to have a remove-if ...
        for (VarOrFieldDecl param : functionParameters())
            if (!param.getName().equals(getVar().getName()))
                result.add((VarOrFieldDecl)param.copy());
        return result;
    }
    inh List<VarOrFieldDecl> Stmt.functionParameters();
    inh List<VarOrFieldDecl> Exp.functionParameters();

    syn boolean VarOrFieldUse.isFunctionParameter();
    eq VarOrFieldUse.isFunctionParameter() {
        for (VarOrFieldDecl param : functionParameters()) {
            if (param.getName().equals(getName())) return true;
        }
        return false;
    }

    rewrite VarUse {
        when (isFunctionParameter())
            to FunctionParamUse new FunctionParamUse(getName());
    }
    
    syn lazy VarOrFieldDecl VarOrFieldUse.getDecl();
    eq VarUse.getDecl() = lookupVarName(getName());
    eq FieldUse.getDecl() = lookupVarName(getName());
    eq FunctionParamUse.getDecl() = lookupVarName(getName());


    syn lazy VarOrFieldDecl Block.localLookupVarName(String name);
    eq Block.localLookupVarName(String name) {
        for (VarDecl decl : getVars()) {
            if (decl.getName().equals(name))
                return decl;
        }
        return null;
    }
    
    syn lazy PatternVarDecl Pattern.localLookupVarName(String name);
    eq Pattern.localLookupVarName(String name) = null;
    eq PatternVar.localLookupVarName(String name) {
        if (getVar().getName().equals(name))
            return getVar();
        return null;
    }
    eq ConstructorPattern.localLookupVarName(String name) {
        for (Pattern p : getParams()) {
            PatternVarDecl d = p.localLookupVarName(name);
            if (d != null)
                return d;
        }
        return null;
    }
    
    syn lazy VarOrFieldDecl Decl.localLookupVarName(String name);
    eq Decl.localLookupVarName(String name) = null;
    eq FunctionDecl.localLookupVarName(String name) {
        for (VarOrFieldDecl decl : getParams()) {
            if (decl.getName().equals(name))
                return decl;
        }
        return null;
    }

    eq Block.getStmt(int i).lookupVarName(String name) {
        VarOrFieldDecl d = localLookupVarName(name);
        if (d != null)
            return d;
        
        return lookupVarName(name);
    }
    
    eq Model.getBlock().lookupVarName(String name) = getBlock().localLookupVarName(name);
    eq Model.getDecl(int i).lookupVarName(String name) = getDecl(i).localLookupVarName(name);
    eq CaseExp.getBranch(int i).lookupVarName(String name) = getBranch(i).localLookupVarName(name);
    
    syn lazy PatternVarDecl CaseBranch.localLookupVarName(String name) = getLeft().localLookupVarName(name);
    

    inh VarOrFieldDecl Exp.lookupVarName(String name);
    inh VarOrFieldDecl Block.lookupVarName(String name);
    
}

// Local Variables:
// mode: java
// End:
