import abs.common.*;

aspect TypeAnalysis {

	// ***API***
  
	// *hasCycleOnExtendedInterfaceChain*
	// True if there is a cycle somewhere on the superinterface chain
	syn lazy boolean InterfaceDecl.hasCycleOnExtendedInterfacesChain() circular [true];
  
	
	// *hasCycleOnExtendedInterfacesChain* - true if there is a cycle somewhere on the extendedInterfaces chain
	eq InterfaceDecl.hasCycleOnExtendedInterfacesChain() {
		List<InterfaceTypeUse> refs = getExtendedInterfaceUses(); // names occuring in this declaration
		boolean cycleFound = false;

		for (InterfaceTypeUse ref : refs) {
			TypeDecl decl = ref.declaration(); // Note decl var. distinct from decl() method
			if (decl instanceof InterfaceDecl) {
				cycleFound = cycleFound || ((InterfaceDecl)decl).hasCycleOnExtendedInterfacesChain();
			} else { // Semantic errors in input program can cause dell==null or dell to have other wild values
				     // e.g., cyclic interface inheritance chains.
				; // Ignore such AST structural oddities as the causes are caught by other checks (methinks...)
			}
		}

		return cycleFound;
	}
	
    syn boolean Type.isReferenceType() = false;
    eq InterfaceType.isReferenceType() = true;
    eq NullType.isReferenceType() = true;

    syn boolean Type.isInterfaceType() = false;
	eq InterfaceType.isInterfaceType() = true;
	
    syn boolean Type.isNullType() = false;
    eq NullType.isNullType() = true;

    syn boolean Type.isDataType() = false;
    eq DataType.isDataType() = true;
	
    syn boolean Type.isTypeParameter() = false;
    eq TypeParameter.isTypeParameter() = true;

    syn boolean Type.isUnkownType() = false;
    eq UnkownType.isUnkownType() = true;

    syn lazy Type Exp.getType();
	eq Exp.getType() { throw new NotImplementedYetException("Type Checker",this); }
	
	eq AsyncCall.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq SyncCall.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq GetExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq NewExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq FutureTypeUse.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq FieldUse.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq FunctionParamUse.getType() { throw new NotImplementedYetException("Type Checker",this); }
    
    eq VarUse.getType() { 
        throw new NotImplementedYetException("Type Checker",this);        
    }
    
    eq TypeUse.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq ArithmeticExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq BoolExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq RelationalExpr.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq CaseExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq FnApp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq DataConstructorExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq FunVar.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq LetExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq IntLiteral.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq StringLiteral.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq NullExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq ThisExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq MinusExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq NegExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
	
	
}

// Local Variables:
// mode: java
// End:
