/**
 * Analysis of function application to determine if it is being called
 * from an imperative or functional context.
 *
 * This is used by the Erlang garbage collector to determine whether to add
 * local variables to the data structure representing the execution stack when
 * applying a function. In a functional context, all objects and futures are
 * already present in the data structure passed to the function, and there's
 * no need to extend it.  See ErlUtil.argumentList()
 */
aspect FnAppContext {
    inh lazy boolean FnApp.isFnAppContextImperative();

    // Statements (Imperative)
    eq FieldDecl.getInitExp().isFnAppContextImperative() = true;
    eq VarDecl.getInitExp().isFnAppContextImperative() = true;
    eq AssignStmt.getValue().isFnAppContextImperative() = true;
    eq DurationStmt.getMin().isFnAppContextImperative() = true;
    eq DurationStmt.getMax().isFnAppContextImperative() = true;
    eq MoveCogToStmt.getTarget().isFnAppContextImperative() = true;
    eq ExpressionStmt.getExp().isFnAppContextImperative() = true;
    eq AssertStmt.getCondition().isFnAppContextImperative() = true;
    eq IfStmt.getCondition().isFnAppContextImperative() = true;
    eq WhileStmt.getCondition().isFnAppContextImperative() = true;
    eq CaseStmt.getExpr().isFnAppContextImperative() = true;
    eq ReturnStmt.getRetExp().isFnAppContextImperative() = true;
    eq ThrowStmt.getReason().isFnAppContextImperative() = true;
    eq DieStmt.getReason().isFnAppContextImperative() = true;
    eq AwaitStmt.getGuard().isFnAppContextImperative() = true;
    eq RebindStmt.getObj().isFnAppContextImperative() = true;
    eq RebindStmt.getVal().isFnAppContextImperative() = true;
    eq MoveStmt.getLoc().isFnAppContextImperative() = true;
    eq MoveStmt.getTo().isFnAppContextImperative() = true;

    // Function
    eq ExpFunctionDef.getRhs().isFnAppContextImperative() = false;
    eq Annotation.getValue().isFnAppContextImperative() = false; // Are annotations compiled?
}
