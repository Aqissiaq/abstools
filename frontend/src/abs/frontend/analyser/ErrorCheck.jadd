import java.util.Collection;
import java.util.ArrayList;
import abs.frontend.analyser.*;

aspect ErrorCheck {
    
    public boolean Model.hasErrors() {
        return !getErrors().isEmpty();
    }
    
  public SemanticErrorList Model.getErrors() {
    SemanticErrorList s = new SemanticErrorList();
    collectErrors(s);
    return s;
  }

  // generic traversal that collects errors in AST
  public void ASTNode.collectErrors(SemanticErrorList c) {
    for(int i = 0; i < getNumChild(); i++)
      getChild(i).collectErrors(c);
  }

  // add error for cyclic interface inheritance hierarchy
  public void InterfaceDecl.collectErrors(SemanticErrorList c) {
    super.collectErrors(c);
    if(hasCycleOnExtendedInterfacesChain())
        c.add(new SemanticError(this,ErrorMessage.CYCLIC_INHERITANCE,getName()));
  }

  // add error for undeclared interfaces
  public void InterfaceTypeUse.collectErrors(SemanticErrorList c) {
    super.collectErrors(c);
    if(declaration().isUnknown())
      c.add(new SemanticError(this,ErrorMessage.UNKOWN_INTERFACE,getName()));
  }

  // add error for undeclared identifiers (interfaces, datatypes/type synonyms)
  public void UnresolvedTypeUse.collectErrors(SemanticErrorList c) {
    super.collectErrors(c);
    if(declaration().isUnknown())
        c.add(new SemanticError(this,ErrorMessage.UNKOWN_INTERFACE_OR_DATATYPE,getName()));
  }

  // add error for undeclared interfaces
  // TODO: generalise to check other IdUse's too.
  public void DataTypeUse.collectErrors(SemanticErrorList c) {
    super.collectErrors(c);
    if(declaration().isUnknown())
        c.add(new SemanticError(this,ErrorMessage.UNKOWN_DATATYPE,getName()));
  }

  // add error for duplicate interfaces
  public void Model.collectErrors(SemanticErrorList c) {
    super.collectErrors(c);
    if(duplicateTypeDecls().size() > 0) {
    	for (String name : duplicateTypeDecls()) {
            c.add(new SemanticError(this,ErrorMessage.DUPLICATE_TYPE_DECL,name));
    	}
    }
  }

}

// Local Variables:
// mode: java
// End:
