import java.util.Map;
import java.util.HashMap;
import abs.frontend.delta.*;
import abs.frontend.delta.exceptions.*;


aspect OriginalCallResolver {
    
    public void Model.resolveOriginalCalls(ArrayList<DeltaDecl> deltas) {
        Collections.reverse(deltas);
        // Walk list of deltas in reverse order of application and resolve original() calls.
        // Original calls in delta are resolved by finding the original method 
        // declaration in the list of previously applied deltas + core,
        // and calling it instead of original().
        for (int i=0; i < deltas.size(); i++) {
            DeltaDecl delta = deltas.remove(i);
            delta.resolveOriginalCalls(deltas);
        }
    }

    // TODO
    public void DeltaDecl.resolveOriginalCalls(ArrayList<DeltaDecl> deltas) {
        /*
         * calling original() only seems to make sense in a delta that *modifies* 
         * an existing class when *modifying* a method in that class,
         * so we only deal with this case.
         */
        System.out.println("resolving in Delta: " + this.qualifiedName());
        for (ClassModifier cm : this.getClassModifiers()) {
           if (cm instanceof ModifyClassModifier)
               for (Modifier m : ((ModifyClassModifier)cm).getModifiers())
                   if (m instanceof ModifyMethodModifier)
                       ((ModifyMethodModifier)m).resolveOriginalCalls(deltas);
        }
    }
    
    public void ModifyMethodModifier.resolveOriginalCalls(ArrayList<DeltaDecl> deltas) {
        String classid = this.className();
        MethodImpl method = getMethodImpl();
        String methodid = method.getMethodSig().getName();
        // find original calls
        Block block = method.getBlock();
        for (Stmt s : block.getStmts()) {
            System.out.println(this.deltaName() + " <Statement> " + s.getClass().getName() + " > " + s);

            if (s instanceof ExpressionStmt) {
                Exp exp = ((ExpressionStmt)s).getExp();
                if (exp instanceof OriginalCall) {
                    // replace OriginalCall with new expression
                    EffExp newexp = ((OriginalCall)exp).resolve(deltas, classid, methodid);
                    ((ExpressionStmt)s).setExp(newexp);
                }
            } else if (s instanceof VarDeclStmt) {
                VarDecl vd = ((VarDeclStmt)s).getVarDecl();
                Exp exp = vd.hasInitExp() ? vd.getInitExp() : null;
                if (exp instanceof OriginalCall) {
                    // replace OriginalCall with new expression
                    EffExp newexp = ((OriginalCall)exp).resolve(deltas, classid, methodid);
                    ((VarDeclStmt)s).getVarDecl().setInitExp(newexp);
                }
            }
        }
    }
    
    
    public EffExp OriginalCall.resolve(
            ArrayList<DeltaDecl> prevdeltas, 
            String classid, 
            String methodid) {
        // find MethodImpl with name classid.methodid in previous delta list
//      MethodImpl originalImpl = module.findOriginal(prevdeltas, classid, methodid);
        MethodImpl originalImpl = new MethodImpl(); // FIXME
        // add a new AddMethodModifier that wraps that MethodImpl (with different name) to the current delta.
        ModifyClassModifier cm = new ModifyClassModifier();
//        MethodImpl originalImplCopy = originalImpl.fullCopy();
        String methodidOriginal = methodid + "^Original"; // FIXME maybe too simple?
//      originalImplCopy.getMethodSig().setName(methodidOriginal); 
//      cm.addModifier(new AddMethodModifier(originalImplCopy));
//      delta().addClassModifier(cm);
        // replace OriginalCall node with a call to that method (new name)
        // TODO
//        System.out.println(">>> Call to original " + classid + "." + methodid + "(" + ((OriginalCall)exp).getParams() + ")");
        
        // create new call to this.methodidOriginal, pass on original params
        return new SyncCall(new ThisExp(), methodidOriginal, this.getParams());
    }
    
    
}
