import java.util.Map;
import java.util.HashMap;
import java.util.UUID;
import abs.frontend.delta.*;
import abs.frontend.delta.exceptions.*;

/*
 * Sorry for this one. Quick fix for some code below.
 * If you know a better way to return two values in Java,
 * please remove this class, and do it the proper way below.
 */
public final class MethodAndDelta {
	
	public final MethodImpl method;
	public final String     delta;
	
	public MethodAndDelta(MethodImpl first, String second) {
		this.method = first;
		this.delta = second;
	}
	
	public MethodImpl getMethod() {
		return method;
	}
	
	public String getDelta() {
		return delta;
	}
}

aspect OriginalCallResolver {

    /* Walk list of deltas in order of application and resolve original() calls.
     * Original calls in delta are resolved by finding the original method 
     * declaration in the list of previously applied deltas + core,
     * copying it, and calling it instead of original().
     */
    public void Model.resolveOriginalCalls(ArrayList<DeltaDecl> deltas) throws ASTNodeNotFoundException {
        ArrayList<DeltaDecl> prevdeltas = new ArrayList<DeltaDecl>();
        for (DeltaDecl delta : deltas) {
            delta.resolveOriginalCalls(prevdeltas);
            prevdeltas.add(0, delta);
        }
    }

    /* Resolve original() calls in current delta.
     * Calling original() only seems to make sense in a delta that modifies
     * an existing class by modifying a method in that class, so we only 
     * deal with this case.
     */
    public void DeltaDecl.resolveOriginalCalls(
            ArrayList<DeltaDecl> deltas) throws ASTNodeNotFoundException {
        System.out.println("*** resolving in Delta: " + this.qualifiedName());
        for (ClassOrIfaceModifier cm : this.getClassOrIfaceModifiers()) {
           if (cm instanceof ModifyClassModifier)
               for (Modifier m : ((ModifyClassModifier)cm).getModifiers())
                   if (m instanceof ModifyMethodModifier)
                       ((ModifyMethodModifier)m).resolveOriginalCalls(deltas);
        }
    }
    
    
    /* This field is used to save/cache the original MethodImpl
     * once it has been found.
     */
    private MethodImpl ModifyMethodModifier.OriginalMethodImpl = null;

    
    /*
     * resolve OriginalCalls within the body of the method defined
     * inside this
     */
    public void ModifyMethodModifier.resolveOriginalCalls(
            ArrayList<DeltaDecl> deltas) throws ASTNodeNotFoundException {
        
        for (Stmt stmt : this.getMethodImpl().getBlock().getStmts())
            stmt.resolveOriginalCalls(this, deltas);
    }
    

    /* 
     * traverse AST in search of OriginalCalls
     */
    public void ASTNode.resolveOriginalCalls(
            ModifyMethodModifier mod, 
            ArrayList<DeltaDecl> deltas) throws ASTNodeNotFoundException {
        for(int i = 0; i < getNumChild(); i++) {
            getChildNoTransform(i).resolveOriginalCalls(mod, deltas);
        }
    }
    
    /* Replace this original call with a newly constructed call to 
     * the copy of the original method implementation
     */
    public void OriginalCall.resolveOriginalCalls(
            ModifyMethodModifier mod, 
            ArrayList<DeltaDecl> deltas) throws ASTNodeNotFoundException {
        
        // found; replace
        System.out.println("*** found: " + this);
        EffExp call = mod.constructNewCall(this, deltas);
        ASTNode parent = getParent();
        int i = parent.getIndexOfChild(this);
        parent.setChild(call, i);
    }
    
    /* Replace this targeted original call with a newly constructed call to 
     * the copy of the original method implementation
     */
    public void TargetedOriginalCall.resolveOriginalCalls(
            ModifyMethodModifier mod, 
            ArrayList<DeltaDecl> deltas) throws ASTNodeNotFoundException {
        
        // found; replace
        System.out.println("*** found: " + this);
        EffExp call = mod.constructNewCall(this, deltas);
        ASTNode parent = getParent();
        int i = parent.getIndexOfChild(this);
        parent.setChild(call, i);
    }

    
    /* Find the original method implementation, copy it to current delta,
     * and construct a call to it.
     */
    public EffExp ModifyMethodModifier.constructNewCall(
            OriginalCall oc, 
            ArrayList<DeltaDecl> deltas) throws ASTNodeNotFoundException {
        
        String classid = this.className();
        String methodid = this.getMethodImpl().getMethodSig().getName();
        MethodImpl method;
        MethodAndDelta original = null;
        
        if (oc instanceof TargetedOriginalCall) {
            String targetDeltaID = ((TargetedOriginalCall) oc).getTarget().getName();
            for (DeltaDecl delta : deltas) {
                if (delta.getName().equals(targetDeltaID)) {
                    original = findOriginalInDelta(methodid, classid, delta);
                    System.out.println("*** found original: " + original.getMethod().getMethodSig() + " in " + original.getDelta());
                    break;
                }
            }
            //TODO throw error
            //throw new ASTNodeNotFoundException("Could not find original implementation of method " + classid + "." + methodid
            //   + " -- in delta " + targetDeltaID);
        } else {
            // find original MethodImpl and copy it
            original = findOriginal(methodid, classid, deltas);
            System.out.println("*** found original: " + original.getMethod().getMethodSig() + " in " + original.getDelta());
        }
        
        try {
        	deltas.add(0, this.delta());
        	method = findOriginal(methodid + "_Orig_" + original.getDelta(), classid, deltas).getMethod();
        	deltas.remove(0);
        } catch(ASTNodeNotFoundException e) {
	        method = copyOriginal(original.getMethod(), original.getDelta());
	        System.out.println("*** copied original: " + method.getMethodSig());
        }
        
        // construct call and pass on the original params
        System.out.println("*** replaced original call with call to: " + method.getMethodSig());
        return new SyncCall(new ThisExp(), method.getMethodSig().getName(), oc.getParams().fullCopy());
    }
    
    public MethodAndDelta ModifyMethodModifier.findOriginal(            
            String methodid,
            String classid, 
            ArrayList<DeltaDecl> deltas) throws ASTNodeNotFoundException {

        System.out.println("*** searching for method " + classid + "." + methodid);
        // search in list of applied deltas
        MethodAndDelta mad = null;
        for (DeltaDecl delta : deltas) {
            System.out.println("*** searching in delta " + delta.getName());
            mad = findOriginalInDelta(methodid, classid, delta);
            if (mad != null)
            	return mad;
        }
        // search in core classes
        KindedName symbol = new KindedName(KindedName.Kind.CLASS, classid);
        Map<KindedName, ResolvedName> visibleSymbols = this.getModule().getVisibleNames();
        if (visibleSymbols.containsKey(symbol)) {
            ClassDecl cls = (ClassDecl) visibleSymbols.get(symbol).getDecl();
            System.out.println("*** searching in core class " + cls.getName());
            for (MethodImpl method : cls.getMethods()) {
                if (method.getMethodSig().getName().equals(methodid)) {
                    return new MethodAndDelta(method, "core");
                }
            }
        }
        // give up
        throw new ASTNodeNotFoundException("Could not find original implementation of method " + classid 
                + "." + methodid);
    }
    
    /* find first MethodImpl that matches classid and methodid 
     * in given deltas and core
     */
    public MethodAndDelta ModifyMethodModifier.findOriginalInDelta(            
            String methodid,
            String classid, 
            DeltaDecl delta) throws ASTNodeNotFoundException {
        
        for (ClassOrIfaceModifier cm : delta.getClassOrIfaceModifiers()) {
            if (cm.className().equals(classid)) {
                if (cm instanceof ModifyClassModifier) {
                    for (Modifier m : ((ModifyClassModifier)cm).getModifiers())
                        if (m instanceof AddMethodModifier) {
                            MethodImpl method = ((AddMethodModifier)m).getMethodImpl();
                            if (method.getMethodSig().getName().equals(methodid))
                                return new MethodAndDelta(method, delta.getName());
                        } else if (m instanceof ModifyMethodModifier) {
                            MethodImpl method = ((ModifyMethodModifier)m).getMethodImpl();
                            if (method.getMethodSig().getName().equals(methodid))
                                return new MethodAndDelta(method, delta.getName());
                        } else if (m instanceof RemoveMethodModifier) {
                            if (((RemoveMethodModifier)m).getMethodSig().getName().equals(methodid))
                                throw new ASTNodeNotFoundException("Could not find original implementation of method " + classid + "." + methodid
                                        + " -- it was removed by delta " + delta.getName());
                        }
                } else if (cm instanceof AddClassModifier) {
                    for (MethodImpl method : ((AddClassModifier)cm).getClassDecl().getMethods())
                        if (method.getMethodSig().getName().equals(methodid))
                            return new MethodAndDelta(method, delta.getName());
                } else if (cm instanceof RemoveClassModifier) {
                    throw new ASTNodeNotFoundException("Could not find original implementation of method " + classid + "." + methodid
                            + " -- it was removed by delta " + delta.getName());
                }
            }
        }
        return null;
    }   
    

    /* copy given MethodImpl to current delta
     * and rename it
     */
    public MethodImpl ModifyMethodModifier.copyOriginal(MethodImpl method, String deltaName) {
        ModifyClassModifier cm = new ModifyClassModifier();
        cm.setName(this.className());
        cm.setImplementedInterfaceUseList(this.getModifyClassModifier().getImplementedInterfaceUseList().fullCopy());
        MethodImpl methodCopy = method.fullCopy();
        // We're leaving out the randomness in the name for now, since we need to find an original method by delta-name
        //String uid = Integer.toHexString(UUID.randomUUID().hashCode());
        //String methodCopyID = method.getMethodSig().getName() + "_Orig" + uid;
        String methodCopyID = method.getMethodSig().getName() + "_Orig_" + deltaName;
        methodCopy.getMethodSig().setName(methodCopyID); 
        cm.addModifier(new AddMethodModifier(methodCopy));
        this.delta().addClassOrIfaceModifier(cm);
        return methodCopy;
    }

}
