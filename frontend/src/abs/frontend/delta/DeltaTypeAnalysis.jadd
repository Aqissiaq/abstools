aspect DeltaTypeAnalysis {

    
    syn lazy SemanticErrorList Model.typeCheckPL() {
        SemanticErrorList res = new SemanticErrorList();
        typeCheckPL(res);
        return res;
    }

    private void Model.typeCheckPL(SemanticErrorList errors) {
        if (hasProductLine()) {
            ProductLine pl = getProductLine();
            DeltaTypeAnalysisHelper.typeCheckPL(pl, errors);
        }
    }
    
    syn lazy java.util.List<java.util.Set<String>> ProductLine.getDeltaPartition(SemanticErrorList errors) {
        return DeltaTypeAnalysisHelper.getDeltaPartition(this, errors);
    }
    
    syn lazy boolean ProductLine.isStronglyUnambiguous(java.util.List<Set<String>> deltaPartitions, SemanticErrorList errors) {
        return DeltaTypeAnalysisHelper.isStronglyUnambiguous(this, deltaPartitions, errors);
    }

    /* 
     * Return all valid feature configurations of the feature model.
     * This is done by solving the CSP and only considering features (no attributes, as that could result in an infinite number of configurations)
     */
    syn lazy Set<Set<String>> Model.getFeatureModelConfigurations() {
        if (! hasMTVL())
            return Collections.emptySet();

        ChocoSolver solver = instantiateCSModelFeaturesOnly();
        return solver.getSolutionsFeaturesOnly();
    }

    
    /*
     * Add all possible products (i.e. valid feature configurations = feature model solutions) 
     * as non-terminal attributes to the AST (as List of ImplicitProducts to the Model node)
     */
    syn List<ImplicitProduct> Model.getImplicitProductList() {
        List<ImplicitProduct> ASTlist = new List<ImplicitProduct>();
        Set<Set<String>> featureConfs = getFeatureModelConfigurations();
        for (Set<String> set : featureConfs) {
            ImplicitProduct product = new ImplicitProduct();
            // set name
            // set Features
            // set Reconfigurations (empty list)
            ASTlist.add(product);
        }
        return ASTlist;
    }
    
}