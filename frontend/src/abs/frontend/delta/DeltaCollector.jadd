import java.util.Map;
import abs.frontend.delta.*;
import abs.common.*;
import abs.frontend.delta.exceptions.*;

aspect DeltaCollector {

    // configure a product
    public void Model.configureProduct(String id) throws WrongProgramArgumentException,ASTNodeNotFoundException {
        Product prod = this.findProduct(id);
        System.out.println("configuring product: " + prod.moduleName() + "." + prod.getName());

        // first, collect ALL deltas
        HashMap<String, Delta> alldeltas = new HashMap<String, Delta>();
        this.collectDeltas(alldeltas);
//        for (String deltaid : alldeltas.keySet())
//            System.out.println("collected delta: " + deltaid);

        // given a product, find the applicable deltas (and sort them)
        ArrayList<Delta> deltas = this.findApplicableDeltas(prod, alldeltas);
        for (Delta delta : deltas)
            System.out.println(">>> applicable delta: " + delta.getName());

        // apply the applicable deltas in the given order
        for (Delta delta : deltas)
            this.applyDelta(delta);
    }

    /**************************************************************************
     * find a particular product given by its name
     */
    public Product Model.findProduct(String id) throws WrongProgramArgumentException {
        for (CompilationUnit u : this.getCompilationUnits()) {
            for (ModuleDecl d : u.getModuleDecls()) {
                for (Product p : d.getProducts()) {
                    String moduleid = p.moduleName();
                    if (id.equals(moduleid + "." + p.getName()))
                        return p;
                }
            }
        }
        throw new WrongProgramArgumentException("Product [" + id + "] is not declared");
    }


    /**************************************************************************
     * collect all Deltas
     */
    //propagate
    public void ASTNode.collectDeltas(HashMap<String, Delta> deltas) {
        for(int i = 0; i < getNumChild(); i++) {
            getChildNoTransform(i).collectDeltas(deltas);
        }
    }

    public void Model.collectDeltas(HashMap<String, Delta> deltas) {
        super.collectDeltas(deltas);
    }

    /*
     * remember the modifications (addition/removal/modification of classes)
       that this delta applies
     */
    public void DeltaDecl.collectDeltas(HashMap<String, Delta> deltas) {
        String moduleid = this.moduleName();
        String deltaid = moduleid + "." + this.getName();

        Delta delta = new Delta(deltaid);
        for (ClassModifier cm : this.getClassModifiers())
            delta.addClassModifier(moduleid, cm);

        deltas.put(deltaid, delta);
    }

    /**************************************************************************
     * Evaluate each delta clause to find the applicable deltas
     * i.e. test each application condition in the context of the features which are ON in the given product
     *
     * TODO sort the applicable deltas according to partial order
     */
    public ArrayList<Delta> Model.findApplicableDeltas(
            Product prod, 
            HashMap<String, Delta> alldeltas) throws WrongProgramArgumentException {
   
        ArrayList<Delta> deltas = new ArrayList<Delta>();
        GraphTS g = new GraphTS(100);
        
        for (CompilationUnit u : this.getCompilationUnits()) {
            for (ModuleDecl module : u.getModuleDecls()) {
                String moduleid = module.getName();
                if (module.hasProductLine()) {
                    ProductLine pl = module.getProductLine();
                    for (DeltaClause c : pl.getDeltaClauses()) {
                        String deltaid = moduleid + "." + c.getDeltaspec().getName();
                        if (c.evaluateAppCond(prod.getFeatures())) {
                            if (alldeltas.containsKey(deltaid)) {
                                Delta delta = alldeltas.get(deltaid);
                                deltas.add(delta);
                                // add vertex delta
                                g.addVertex(delta);
                                // for each thatdelta in "after" list:
                                // add edge (delta, thatdelta)
                                for (DeltaID otherid : c.getDeltaIDs()) {
                                    if (alldeltas.containsKey(otherid.getName()))
                                        try {
                                            g.addEdge(delta, alldeltas.get(otherid.getName()));
                                        } catch (VertexNotFoundException x) {
                                            // TODO
                                        }
                                    else 
                                        throw new WrongProgramArgumentException("Delta [" + otherid.getName() + "] is not declared");
                                }    
                            } else
                                throw new WrongProgramArgumentException("Delta [" + deltaid + "] is not declared");
                        }
                    }
                }
            }
        }
        // TODO sort g;
        return deltas;
    }


    /**************************************************************************
     *  Evaluate the application condition assciated with *this*
     *  in the context of the given list of features and attribute values
     *
     *  currently this only compares feature NAMES
     *  and only delas with the AND operator
     *  TODO properly handle all logical connectives, also feature attributes
     */
    public boolean DeltaClause.evaluateAppCond(List<Feature> onFeatures) {
        // first, log the names of all onFeatures in a set, for easy lookup
        HashSet<String> onFeatureIDs = new HashSet<String>();
        for (Feature f : onFeatures)
            onFeatureIDs.add(f.getName());

        // check whether each required feature is also ON
        for (Feature reqFeature : this.getFeatures()) {
//            System.out.println(">>> required feature: " + reqFeature.getName() +  " is " + onFeatureIDs.contains(reqFeature.getName()));
            if (! onFeatureIDs.contains(reqFeature.getName()))
                return false;
        }
        return true;
    }


//    /*
//     * Collect features (and later attributes) from a product.
//     */
//
//    // return a product given its name
//    public Product ASTNode.getOptProd(String product) {
//        for(int i = 0; i < getNumChild(); i++) {
//            Product p = getChildNoTransform(i).getOptProd(product);
//            if (p != null)
//                return p;
//        }
//        return null;
//    }
//
//    public Product Product.getOptProd(String product) {
//        if (product.equalsIgnoreCase(getName()))
//            return this;
//        else
//            return null;
//    }
//
//    // collect all features inside a product
//    public void Product.getFeatures(Collection<String> feats) {
//        for(int i = 0; i < getNumFeature(); i++)
//            getFeature(i).getFeatures(feats);
//    }
//
//    public void Feature.getFeatures(Collection<String> feats) {
//        feats.add(getName());
//    }
//
//    // collect all deltas that match a product  (under construction)
//
//    public void Model.collectDeltas(Product prod) {
//        HashSet<DeltaDecl> deltas = new HashSet<DeltaDecl>();
//        HashSet<String>    feats  = new HashSet<String>();
//        prod.getFeatures(feats);
//        collectDeltas(feats,deltas);
//    }
//    public void ASTNode.collectDeltas(Collection<String> feats, Collection<DeltaDecl> deltas) {
//        for(int i = 0; i < getNumChild(); i++) {
//            getChildNoTransform(i).collectDeltas(feats,deltas);
//        }
//    }

    // undested!
    abstract public Value Deltaparam.calcValue(List<Feature> feats)
        throws WrongProgramArgumentException;
    public Value Const.calcValue(List<Feature> feats)  {
        return getValue();
    }
    public Value CID.calcValue(List<Feature> feats) {
        for (Feature f : feats) {
            if (f.getName().equals(getName()))
                return new BoolVal(true);
        }
        return new BoolVal(false);
    }
    public Value FIDAID.calcValue(List<Feature> feats) throws WrongProgramArgumentException {
        for (Feature f : feats) {
            if (f.getName().equals(getFeatName())) // found feature
                for (AttrAssignment attr : f.getAttrAssignments()) {
                    if (attr.getName().equals(getAttrName()))   // found attribute
                        return attr.getValue();
                }
        }
        throw new WrongProgramArgumentException("Argument " + getFeatName() + "."+ getAttrName() +" not found.");
    }
}
