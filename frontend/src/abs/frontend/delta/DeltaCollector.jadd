import java.util.Map;
import abs.frontend.delta.*;
import abs.common.*;
import abs.frontend.delta.exceptions.*;

aspect DeltaCollector {

    // configure a product
    public void Model.configureProduct(String id) throws WrongProgramArgumentException,ASTNodeNotFoundException {
        Product prod = this.findProduct(id);
        System.out.println("configuring product: " + prod.moduleName() + "." + prod.getName());

        ArrayList<Delta> deltas = this.getSortedDeltas(prod);

        System.out.print("applicable deltas: ");
        for (Delta delta : deltas)
            System.out.print(delta.getName() + " ");
        System.out.println("");

        // apply the applicable deltas in the given order
        for (Delta delta : deltas)
            this.applyDelta(delta);
    }
    
    public ArrayList<Delta> Model.getSortedDeltas(Product prod) {

        // first, collect ALL deltas
        HashMap<String, Delta> alldeltas = new HashMap<String, Delta>();
        this.collectDeltas(alldeltas);

        // given a product, find the applicable deltas (and sort them)
        HashMap<String, Delta> appdeltas;
        try {
            appdeltas = this.findApplicableDeltas(prod, alldeltas);
        } catch(WrongProgramArgumentException e) {
            return new ArrayList<Delta>(); // shouldn't happen
        }

        return sortApplicableDeltas(appdeltas);
    }    


    /**************************************************************************
     * find a particular product given by its name
     */
    public Product Model.findProduct(String id) throws WrongProgramArgumentException {
        for (CompilationUnit u : this.getCompilationUnits()) {
            for (ModuleDecl d : u.getModuleDecls()) {
                for (Product p : d.getProducts()) {
                    String moduleid = p.moduleName();
                    if (id.equals(moduleid + "." + p.getName()))
                        return p;
                }
            }
        }
        throw new WrongProgramArgumentException("Product [" + id + "] is not declared");
    }


    /**************************************************************************
     * collect all Deltas
     */
    //propagate
    public void ASTNode.collectDeltas(HashMap<String, Delta> deltas) {
        for(int i = 0; i < getNumChild(); i++) {
            getChildNoTransform(i).collectDeltas(deltas);
        }
    }

    public void Model.collectDeltas(HashMap<String, Delta> deltas) {
        super.collectDeltas(deltas);
    }

    /*
     * remember the modifications (addition/removal/modification of classes)
       that this delta applies
     */
    public void DeltaDecl.collectDeltas(HashMap<String, Delta> deltas) {
        String moduleid = this.moduleName();
        String deltaid = moduleid + "." + this.getName();

        Delta delta = new Delta(deltaid);
        for (ClassModifier cm : this.getClassModifiers())
            delta.addClassModifier(moduleid, cm);

        deltas.put(deltaid, delta);
    }

    /**************************************************************************
     * Evaluate each delta clause to find the applicable deltas
     * i.e. test each application condition in the context of the features which are ON in the given product
     *
     * TODO sort the applicable deltas according to partial order
     */
    public HashMap<String, Delta> Model.findApplicableDeltas(
            Product prod, 
            HashMap<String, Delta> alldeltas) throws WrongProgramArgumentException {

        HashMap<String, Delta> deltas = new HashMap<String, Delta>();
        
        // collect applicable deltas
        for (CompilationUnit u : this.getCompilationUnits()) {
            for (ModuleDecl module : u.getModuleDecls()) {
                if (module.hasProductLine()) {
                    ProductLine pl = module.getProductLine();
                    for (DeltaClause c : pl.getDeltaClauses()) {
                        String deltaid = c.moduleName() + "." + c.getDeltaspec().getName();
                        if (c.evaluateAppCond(prod.getFeatures())) {
                            if (alldeltas.containsKey(deltaid)) {
                                Delta delta = alldeltas.get(deltaid);
                                deltas.put(deltaid, delta);
                            } else
                                throw new WrongProgramArgumentException("Delta [" + deltaid + "] is not declared");
                        }
                    }
                }
            }
        }
        return deltas;
    }
    
    public ArrayList<Delta> Model.sortApplicableDeltas(
            HashMap<String, Delta> deltas) {
        
        // sort applicable deltas
        GraphTS g = new GraphTS(deltas.values().toArray());

        for (CompilationUnit u : this.getCompilationUnits()) {
            for (ModuleDecl module : u.getModuleDecls()) {
                if (module.hasProductLine()) {
                    ProductLine pl = module.getProductLine();
                    for (DeltaClause c : pl.getDeltaClauses()) {
                        String deltaid = c.moduleName() + "." + c.getDeltaspec().getName();
                        if (deltas.containsKey(deltaid)) {
                            Delta delta = deltas.get(deltaid);
                            // for each afterdelta: add an edge (delta, afterdelta)
                            for (DeltaID did : c.getDeltaIDs()) {
                                String otherid = did.getName();
                                if (deltas.containsKey(otherid)) {
                                    Delta otherdelta = deltas.get(otherid);
                                    try {
                                        g.addEdge(delta, otherdelta);
                                    } catch (VertexNotFoundException x) {
                                        // FIXME
                                        System.out.println("Exception caught: " + x);
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }

        g.sort();
        return g.getSortedDeltas();
    }


    /**************************************************************************
     *  Evaluate the application condition assciated with *this*
     *  in the context of the given list of features and attribute values
     *
     *  currently this only compares feature NAMES
     *  and only delas with the AND operator
     *  TODO properly handle all logical connectives, also feature attributes
     */
    public boolean DeltaClause.evaluateAppCond(List<Feature> onFeatures) {
        // first, log the names of all onFeatures in a set, for easy lookup
        HashSet<String> onFeatureIDs = new HashSet<String>();
        for (Feature f : onFeatures)
            onFeatureIDs.add(f.getName());

        // check whether each required feature is also ON
        for (Feature reqFeature : this.getFeatures()) {
//            System.out.println(">>> required feature: " + reqFeature.getName() +  " is " + onFeatureIDs.contains(reqFeature.getName()));
            if (! onFeatureIDs.contains(reqFeature.getName()))
                return false;
        }
        return true;
    }


//    /*
//     * Collect features (and later attributes) from a product.
//     */
//
//    // return a product given its name
//    public Product ASTNode.getOptProd(String product) {
//        for(int i = 0; i < getNumChild(); i++) {
//            Product p = getChildNoTransform(i).getOptProd(product);
//            if (p != null)
//                return p;
//        }
//        return null;
//    }
//
//    public Product Product.getOptProd(String product) {
//        if (product.equalsIgnoreCase(getName()))
//            return this;
//        else
//            return null;
//    }
//
//    // collect all features inside a product
//    public void Product.getFeatures(Collection<String> feats) {
//        for(int i = 0; i < getNumFeature(); i++)
//            getFeature(i).getFeatures(feats);
//    }
//
//    public void Feature.getFeatures(Collection<String> feats) {
//        feats.add(getName());
//    }
//
//    // collect all deltas that match a product  (under construction)
//
//    public void Model.collectDeltas(Product prod) {
//        HashSet<DeltaDecl> deltas = new HashSet<DeltaDecl>();
//        HashSet<String>    feats  = new HashSet<String>();
//        prod.getFeatures(feats);
//        collectDeltas(feats,deltas);
//    }
//    public void ASTNode.collectDeltas(Collection<String> feats, Collection<DeltaDecl> deltas) {
//        for(int i = 0; i < getNumChild(); i++) {
//            getChildNoTransform(i).collectDeltas(feats,deltas);
//        }
//    }

    // undested!
    // calculate the concrete value of a Deltaparam given a feature selection.
    abstract public Value Deltaparam.calcValue(List<Feature> feats)
    throws WrongProgramArgumentException;

    public Value Const.calcValue(List<Feature> feats)  {
        try{
            return getValue().clone();
        }
        catch (CloneNotSupportedException e) { return getValue(); }
    }

    public Value CID.calcValue(List<Feature> feats) {
        for (Feature f : feats) {
            if (f.getName().equals(getName()))
                return new BoolVal(true);
        }
        return new BoolVal(false);
    }

    public Value FIDAID.calcValue(List<Feature> feats)
    throws WrongProgramArgumentException {
        for (Feature f : feats) {
            if (f.getName().equals(getFeatName())) // found feature
                for (AttrAssignment attr : f.getAttrAssignments()) {
                    if (attr.getName().equals(getAttrName()))   // found attribute
                        try{
                            return attr.getValue().clone();
                        }
                        catch (CloneNotSupportedException e) { return attr.getValue(); }
                }
        }
        throw new WrongProgramArgumentException("Argument " + getFeatName() + "."+ getAttrName() +" not found.");
    }

    // collect the substitution to be applied in a DeltaDecl given the parameters and the feature selection
    public Map<DeltaParamDecl,Value> DeltaDecl.getSubstitution(List<Deltaparam> dparams, List<Feature> feats)
    throws WrongProgramArgumentException
    {
        HashMap<DeltaParamDecl,Value> res = new HashMap<DeltaParamDecl,Value>();
        for (int i = 0; i < dparams.getNumChild(); i++) {
            res.put(getParam(i),dparams.getChild(i).calcValue(feats));
        }
        return res;
    }

    // apply a substitution to DeltaDecl
    public void DeltaDecl.applySubstitution(Map<DeltaParamDecl,Value> subst) {
        for (ClassModifier d : getClassModifiers())
            d.applySubstitution(subst);
    }

    abstract public void ClassModifier.applySubstitution(Map<DeltaParamDecl,Value> subst);
    public void ModifyClassModifier.applySubstitution(Map<DeltaParamDecl,Value> subst) {
        for (Modifier m : getModifiers())
            m.applySubstitution(subst);
    }
    public void AddClassModifier.applySubstitution(Map<DeltaParamDecl,Value> subst) {
        getClassDecl().applySubstitution(subst);
    }
    public void RemoveClassModifier.applySubstitution(Map<DeltaParamDecl,Value> subst) {}

    abstract public void Modifier.applySubstitution(Map<DeltaParamDecl,Value> subst);
    public void AddFieldModifier.applySubstitution(Map<DeltaParamDecl,Value> subst) {
        getFieldDecl().applySubstitution(subst);
    }
    public void RemoveFieldModifier.applySubstitution(Map<DeltaParamDecl,Value> subst) {
        getFieldDecl().applySubstitution(subst);
    }
    public void AddMethodModifier.applySubstitution(Map<DeltaParamDecl,Value> subst) {
        getMethodImpl().applySubstitution(subst);
    }
    public void ModifyMethodModifier.applySubstitution(Map<DeltaParamDecl,Value> subst) {
        getMethodImpl().applySubstitution(subst);
    }
    public void RemoveMethodModifier.applySubstitution(Map<DeltaParamDecl,Value> subst) {}

    // to do
    public void ClassDecl.applySubstitution(Map<DeltaParamDecl,Value> subst) {}
    public void FieldDecl.applySubstitution(Map<DeltaParamDecl,Value> subst) {}
    public void MethodImpl.applySubstitution(Map<DeltaParamDecl,Value> subst) {}



}
