import java.util.Map;
import java.util.HashMap;
import abs.frontend.delta.*;
import abs.frontend.delta.exceptions.*;

aspect Flattener {

    /* Configure a product
     * 
     * This is the top level method, which does everything:
     * finding the features of a given product, finding the sequence of 
     * associated deltas, and applying them.
     */
    public void Model.flattenForProduct(String id) throws WrongProgramArgumentException,ASTNodeNotFoundException {
        Product prod = this.findProduct(id);
        flattenForProduct(prod);
    }
    public void Model.flattenForProduct(Product prod) throws WrongProgramArgumentException,ASTNodeNotFoundException {
        System.out.println("--- configuring product: " + prod.qualifiedName());

        ArrayList<DeltaDecl> deltas = this.getSortedDeltas(prod);

        System.out.print("--- applying deltas to core << ");
        String delim = "";
        for (DeltaDecl delta : deltas) {
            System.out.print(delim + delta.qualifiedName());
            delim = " << ";
        }
        System.out.println("");

        // resolve original() calls
        this.resolveOriginalCalls(deltas);

        // apply the applicable deltas in the given order
        for (DeltaDecl delta : deltas)
            this.applyDelta(delta);
    }
    
    /*
     * Apply delta to model
     * i.e. apply each ClassOrIfaceModifier to its corresponding class or interface
     */
    public void Model.applyDelta(DeltaDecl delta) throws ASTNodeNotFoundException {
        for (ClassOrIfaceModifier cmod : delta.getClassOrIfaceModifiers()) {
//            System.out.println("*** applying ClassOrIfaceModifier " + cmod);
            cmod.apply(delta);
        }
    }

    /**************************************************************************
     * Apply ClassOrIfaceModifiers, 
     * that is, add/remove/modify classes or interfaces
     */
    abstract public void ClassOrIfaceModifier.apply(DeltaDecl delta) throws ASTNodeNotFoundException;

    public void AddClassModifier.apply(DeltaDecl delta) throws ASTNodeNotFoundException {
        ModuleDecl module = findModuleForClass(); //delta.getModule();
        module.getDecls().addChild(this.getClassDecl().fullCopy());
    }
    
    public void RemoveClassModifier.apply(DeltaDecl delta) throws ASTNodeNotFoundException {
        ClassDecl cls = this.findClassModifiedBy(delta);
        ModuleDecl module = delta.getModule();
        for (int i = 0; i < module.getNumDecl(); i++) {
            if (module.getDecl(i) == cls) {
                module.getDecls().removeChild(i);
                break;
            }
            assert false;
        }
    }

    public void ModifyClassModifier.apply(DeltaDecl delta) throws ASTNodeNotFoundException {
        ClassDecl cls = this.findClassModifiedBy(delta);
        
        // make sure cls can see each of its implemented interfaces
        
        ModuleDecl clsmodule = cls.getModule();
        Map<KindedName, ResolvedName> visibleSymbols = clsmodule.getVisibleNames();
        
//        for (KindedName n : visibleSymbols.keySet())
//            System.out.println("****** Visible: " + n);
//        for (Import imp : clsmodule.getImports())
//            System.out.println("****** Import: " + imp);

        boolean doFlushCache = false;
        for (InterfaceTypeUse iface : this.getImplementedInterfaceUseList()) {
            KindedName symbol = new KindedName(KindedName.Kind.TYPE_DECL, iface.getName());
            
            if (! visibleSymbols.containsKey(symbol)) {
                // FIXME distinguish between qualified (NamedImport) and unqualified (FromImport) symbols
                // if unqualified, need to find module where symbol was declared
                
                // make it visible by adding Import
                List<Name> names = new List<Name>();
                names.add(new Name(iface.getName()));
//                FromImport newimport = new FromImport(names, iface.getModule().getName());
                NamedImport newimport = new NamedImport(names);
                clsmodule.addImport(newimport);
                doFlushCache = true;
            }

        }
        
        // reset the list of implemented interfaces only if the ClassModifier explicitly has 'implements' statement
        // FIXME this will become obsolote when we change the syntax to allow "modifies class X add/removes I"
        if (this.getImplementedInterfaceUseList().hasChildren())
            cls.setImplementedInterfaceUseList(this.getImplementedInterfaceUseList().fullCopy());
        
        // apply all modifiers
        for (Modifier mod : this.getModifiers()) {
            mod.applyTo(cls);
        }
        // reset list of symbols visible from this module
        if (doFlushCache)
            clsmodule.flushCache();
    }
    
    public void AddInterfaceModifier.apply(DeltaDecl delta) throws ASTNodeNotFoundException {
        // FIXME? only possible to add an interface inside the module where delta is declared
        ModuleDecl module = delta.getModule();
        module.getDecls().addChild(this.getInterfaceDecl().fullCopy());
    }

    /*
     * helper method
     * find the ClassDecl which should be modified by the given delta
     */
    public ClassDecl ClassOrIfaceModifier.findClassModifiedBy(DeltaDecl delta) throws ASTNodeNotFoundException {
        // find module where delta was defined
        ModuleDecl module = delta.getModule();
        ClassDecl cls = null;
//        System.out.println("=== Delta " + module.getName() + "." + delta.getName() + " looking for ClassDecl: " + this.className());
        
        Map<KindedName, ResolvedName> visibleSymbols = module.getVisibleDeltas();
        KindedName symbol = new KindedName(KindedName.Kind.CLASS, this.className());
//        for (KindedName kn : visibleSymbols.keySet()) {
//            System.out.println("visibleNames: " + kn.getKind() + " >>>> " + kn.getName());
//        }
        
        // find the class to which the delta applies 
        if (visibleSymbols.containsKey(symbol)) {
            cls = (ClassDecl) visibleSymbols.get(symbol).getDecl();
//            System.out.println("=== found ClassDecl: " + module.getName() + "." + cls.getName());
        } else {
            // class not found
            throw new ASTNodeNotFoundException("Delta " + module.getName() + "." + delta.getName() 
                    + " wants to modify class " + this.className() + ", which was not found.");
        }
        return cls;
    }

    public ModuleDecl AddClassModifier.findModuleForClass() throws ASTNodeNotFoundException {
        Name name = new Name(getClassDecl().getName());
        ModuleDecl module = getModule();
        String mn = module.getName();
        if (!name.isSimple()) {
            mn = name.getModuleName();
            for (CompilationUnit c: module.getModel().getCompilationUnits())
                for (ModuleDecl m: c.getModuleDecls())
                    if (m.getName().equals(mn))
                        return m;
        }
        else
            return module;
        throw new ASTNodeNotFoundException("Module " + mn + " was not found when adding class " + name.getString() + ".");
    }
    
    /**************************************************************************
     * Modifiers are applied to Classes
     * - add/remove/modify methods
     * - add/remove fields
     */
    public abstract void Modifier.applyTo(ClassDecl cd) throws ASTNodeNotFoundException;

    public void RemoveMethodModifier.applyTo(ClassDecl cd) throws ASTNodeNotFoundException {
        MethodSig mysig = this.getMethodSig();

        // in given ClassDecl: find MethodDecl that matches sig
        int found = -1;
        for (int i = 0; i < cd.getNumMethod(); i++) {
            MethodSig sig = cd.getMethod(i).getMethodSig();
            if (sig.matches(mysig)) {
                found = i;
                break;
            }
        }
        if (found >= 0)
            // remove MethodImpl from list
            cd.getMethods().removeChild(found);
        else
            throw new ASTNodeNotFoundException("Delta " + this.delta().getModule().getName() + "." + this.delta().getName() 
                    + " wants to remove method " + cd.qualifiedName() + "." + mysig + ", which was not found.");
    }

    public void AddMethodModifier.applyTo(ClassDecl cd) {
        cd.addMethod(this.getMethodImpl().fullCopy());
    }

    public void ModifyMethodModifier.applyTo(ClassDecl cd) throws ASTNodeNotFoundException {
        MethodSig mysig = this.getMethodImpl().getMethodSig();

        // in given ClassDecl: find MethodDecl that matches sig
        int found = -1;
        for (int i = 0; i < cd.getNumMethod(); i++) {
            MethodSig sig = cd.getMethod(i).getMethodSig();
            if (sig.matches(mysig)) {
                found = i;
                break;
            }
        }
        if (found >= 0)
            // replace MethodImpl
            cd.getMethods().setChild(this.getMethodImpl().fullCopy(), found);
        else
            throw new ASTNodeNotFoundException("Delta " + this.delta().getModule().getName() + "." + this.delta().getName() 
                    + " wants to modify method " + cd.qualifiedName() + "." + mysig + ", which was not found.");
    }

    public void RemoveFieldModifier.applyTo(ClassDecl cd) throws ASTNodeNotFoundException {
        FieldDecl myfield = this.getFieldDecl();

        // in given ClassDecl: find FieldDecl that matches this
        int found = -1;
        for (int i = 0; i < cd.getNumField(); i++) {
            FieldDecl field = cd.getField(i);
            if (field.matches(myfield)) {
                found = i;
                break;
            }
        }
        if (found >= 0)
            cd.getFields().setChild(this.getFieldDecl().fullCopy(), found);
        else
            throw new ASTNodeNotFoundException("Delta " + this.delta().getModule().getName() + "." + this.delta().getName() 
                    + " wants to remove field " + cd.qualifiedName() + "." + myfield + ", which was not found.");
    }

    public void AddFieldModifier.applyTo(ClassDecl cd) {
        cd.addField(this.getFieldDecl().fullCopy());
    }
}
