//$Id$ 
//Grammar definition for the ABS language, this file is input to Beaver 

%header {:

package abs.frontend.parser;
import abs.frontend.ast.*;

:};
%embed {:
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new Error(s.toString());
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new Error(s.toString());
    }
  }

  { report = new Events(); } // Use error handler in parser
:};


Program goal =
    program.p		{: return p ; :}
  ;

Program program = 
	decl_list.l? block?	{: return new Program(l, block); :}
  ;

Decl decl =
		class_decl
//	|	function_decl
	|	interface_decl
	|	datatype_decl
	;

// The above is equivalent to the more explicit:  
// Decl decl =
// 		class_decl.i		{: return i; :}
// 	| ...
// 	;

InterfaceDecl interface_decl =
  INTERFACE IDENTIFIER extends_interfaces.i? LBRACE methodsig_list.l? RBRACE {: return new InterfaceDecl(IDENTIFIER, i, l); :}
  ;

ClassDecl class_decl =
	CLASS IDENTIFIER class_params.p? implement_interfaces.i? declblock {: return new ClassDecl(IDENTIFIER, p,  i , declblock); :}
  ;

DatatypeDecl  datatype_decl = 
	DATA IDENTIFIER LBRACE data_constructor_list.l? RBRACE {: return new DatatypeDecl(IDENTIFIER, l); :}
  ;

List data_constructor_list =
    data_constructor.i                                         {: return new List().add(i); :}
    | data_constructor_list.l COMMA data_constructor.i        {: return l.add(i); :}
  ;

DataConstructor data_constructor = 
	IDENTIFIER  data_constructor_params.p? {: return new DataConstructor(p) ; :} 
	;

List data_constructor_params = 
	LPAREN typename_list.l? RPAREN     {: return l; :}
	;


List class_params = 
	LPAREN var_decl_list.l? RPAREN     {: return l; :}
	;

List implement_interfaces =
    IMPLEMENTS ifname_list.i           {: return i; :}
  ;

List extends_interfaces =
    EXTENDS ifname_list.i           {: return i; :}
  ;



IdUse ifname =
    IDENTIFIER {: return new IdUse(IDENTIFIER) ; :}
    ;

IdUse typename =
    IDENTIFIER {: return new IdUse(IDENTIFIER) ; :}
    ;

TypeExp type_exp = 
	IDENTIFIER 		{: return new UnresolvedType(IDENTIFIER); :}
	| FUT LPAREN type_exp.t RPAREN {: return new FutureType(t); :}
	;	

// Used in class_decl, i.e. { initblock _T f_ ; _M_}
DeclBlock declblock =  
    LBRACE varfielddecls.l? initblock.i? method_list.m? RBRACE	{: return new DeclBlock(i,l,m) ; :}
  ;

List initblock =  
        LBRACE stmt_list.s? RBRACE  {: return s ; :}
    ;

// Parameters and parameter lists for methods
ParamDecl param_decl =
	type_exp IDENTIFIER {: return new ParamDecl(IDENTIFIER,type_exp); :}
	;

List param_decl_list =
	param_decl.p {: return new List().add(p); :}
	| param_decl_list.l COMMA param_decl.p {: return l.add(p); :}
	;


// Type the type, IDENTIFIER for the name of the variable/field.
VarOrFieldDecl var_or_field_decl = 
    type_exp IDENTIFIER  {: return new VarOrFieldDecl(IDENTIFIER,type_exp); :}
    ;

VarDecl var_decl = 
    type_exp.t IDENTIFIER.id  {: return new VarDecl(id,t); :}
    ;

List var_decl_list =
    var_decl.i                                    {: return new List().add(i); :}
    | var_decl_list.l COMMA var_decl.i        {: return l.add(i); :}
  ;


List var_or_field_decl_list =
    var_or_field_decl.i                                         {: return new List().add(i); :}
    | var_or_field_decl_list.l COMMA var_or_field_decl.i        {: return l.add(i); :}
  ;

List method_list =
    method.i                        {: return new List().add(i); :}
    | method_list.l method.i        {: return l.add(i); :}
  ;

List methodsig_list = 
    methodsig.m			        {: return new List().add(m); :}
  | methodsig_list.l methodsig.m	{: return l.add(m); :}
  ;

List decl_list =
	decl.t			{: return new List().add(t); :}
  | decl_list.l decl.t	{: return l.add(t); :}
  ;

/*
List typedecl_list =
    typedecl.t			{: return new List().add(t); :}
  | typedecl_list.l typedecl.t	{: returntypedecl l.add(t); :}
  ;
*/

//List behaviordecl_list =
//    behaviordecl.t			{: return new List().add(t); :}
//  | behaviordecl_list.l behaviordecl.t	{: return l.add(t); :}
//  ;

List ifname_list =
    ifname.i                              {: return new List().add(i); :}
    | ifname_list.l COMMA ifname.i        {: return l.add(i); :}
  ;


List typename_list =
    typename.i                              {: return new List().add(i); :}
    | typename_list.l COMMA typename.i        {: return l.add(i); :}
  ;



List pure_exp_list =
    pure_exp.i                              {: return new List().add(i); :}
    | pure_exp_list.l COMMA pure_exp.i        {: return l.add(i); :}
  ;





Method method = 
    methodsig.ms block.b {: return new Method(ms,b); :}
    ;

MethodSig methodsig = 
    type_exp IDENTIFIER LPAREN  param_decl_list.l? RPAREN       {: return new MethodSig(IDENTIFIER,type_exp,l); :}
    ;




//Program block
//Is to be used in program, and method i.e. {_T x_ ; sr}
Block block	=
        LBRACE varfielddecls.l? stmt_list.s?  RBRACE	{: return new Block(l,s) ; :}
    ;

List varfielddecls =  
	var_or_field_decl_list.l  SEMICOLON 	{: return l ; :}
	; 

PureExp pure_exp = 
    var_ref
    | get_exp
 //   | eq_exp 	FIXME
    | NULL                 {: return new NullExp() ; :}
    ;

VarRef var_ref =
    IDENTIFIER            {: return new VarRef(IDENTIFIER) ; :}
    ;

GetExp get_exp =
    pure_exp.p DOT GET             {: return new GetExp(p) ; :}
    ;

EffExp eff_exp = 
    new_exp 
	| async_call 
	| local_async_call 
	| sync_call
	| local_sync_call 
	; 


//EqExp  eq_exp = 
//	| pure_exp.e1 EQEQ pure_exp.e2  	{: return new EqExp(e1,e2); :}
//	;

NewExp  new_exp = 
	NEW IDENTIFIER.i params.p?   {: return new NewExp(i,p) ; :} 
	;

List params = 
	LPAREN pure_exp_list.l? RPAREN {: return l ; :} 
	;


AsyncCall async_call = 
	pure_exp.callee BANG IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new AsyncCall(method,params,callee) ; :} 
	;

LocalAsyncCall local_async_call = 
	BANG IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new LocalAsyncCall(method,params) ; :} 
	;

SyncCall sync_call = 
	pure_exp.callee DOT IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new SyncCall(method,params,callee) ; :} 
	;
LocalSyncCall local_sync_call =
	IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new LocalSyncCall(method,params) ; :} 
	;



Stmt stmt = 
	assign_stmt             
	|  AWAIT guard SEMICOLON      {: return new AwaitStmt(guard) ; :}
	|  SKIP SEMICOLON                       {: return new SkipStmt() ; :}
	|  RELEASE SEMICOLON                   {: return new ReleaseStmt() ; :} 
	|  RETURN exp.e SEMICOLON        {: return new ReturnStmt(e) ; :}
	|  eff_exp.e SEMICOLON               {: return new ExpressionStmt(e) ; :}	
	|  if_then_else_stmt 
	|  stmt_block
	| SEMICOLON               {: return new EmptyStmt() ; :}
		;



Guard guard = 	
	| var_ref.r QMARK        {: return new ClaimGuard(r) ; :} 
	| guard.g1 GUARDAND guard.g2 {: return new AndGuard(g1,g2) ; :} 
	  //For boolean guards 
	| pure_exp.e    {: return new ExpGuard(e) ; :} 
	;


IfStmt if_then_else_stmt = 
	IF pure_exp.e1 THEN stmt.s1 ELSE stmt.s2 {: return new IfStmt(e1,s1,new Opt(s2)) ; :} 
	| IF pure_exp.e1 THEN stmt.s1 {: return new IfStmt(e1, s1, new Opt()); :}
	;

AssignStmt assign_stmt =  
	var_ref.r ASSIGN exp.e SEMICOLON        {: return new AssignStmt(r,e) ; :}
    ;

StmtBlock stmt_block = 
	LBRACE stmt_list.l? RBRACE       {:	return new StmtBlock(l) ; :}
    ;      

List stmt_list =
    stmt.i                              {: return new List().add(i); :}
    | stmt_list.l  stmt.i        {: return l.add(i); :}
  ;



Exp exp = 
	pure_exp	
	| eff_exp
	;

