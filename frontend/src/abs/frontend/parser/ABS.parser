// $Id$ 
// Grammar definition for the ABS language 



%header {:

package abs.frontend.parser;
import abs.frontend.ast.*;


:};

%embed {:
	ArrayList<ParserError> errors = new ArrayList<ParserError>();
    boolean raiseExceptions = true;
    String fileName;

	class Events extends Parser.Events {
		public void syntaxError(Symbol token) {
			StringBuffer s = new StringBuffer();
			s.append(Symbol.getLine(token.getStart()) + ":" + Symbol.getColumn(token.getStart()) + ": ");
			s.append("Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
			SyntaxError e = new SyntaxError(s.toString(), Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
			errors.add(e);
			if (raiseExceptions) throw e;
		}
		public void scannerError(Scanner.Exception e) {
			StringBuffer s = new StringBuffer();
			s.append(e.line + ", " + e.column + "\n");
			s.append("Lexical error: " + e.getMessage());
			LexicalError err = new LexicalError(s.toString(), e.line, e.column);
			errors.add(err);
			if (raiseExceptions) throw err;
		}
	}

	{ report = new Events(); } // Use error handler in parser
  
	public void doRaiseExceptions(boolean raiseExceptions) {
		this.raiseExceptions = raiseExceptions;
	}

	public ArrayList<ParserError> getErrors() { return errors; }
	public CompilationUnit parse(String fileName, Scanner scanner) throws java.lang.Exception {
	   this.fileName = fileName;
	   return (CompilationUnit) parse(scanner);
	}
:};



CompilationUnit goal =
    compilation_unit.cu		{: return cu ; :}
  ;

CompilationUnit compilation_unit = 
	decl_list.l? main_block.b?	{: return new CompilationUnit(fileName,l, b); :}
  ;

List decl_list =
	decl.t			{: return new List().add(t); :}
  | decl_list.l decl.t	{: return l.add(t); :}
  ;

Decl decl =
		datatype_decl
	|   typesyn_decl
	|	function_decl
	|	interface_decl
	|	class_decl
	;
// The above is equivalent to the more explicit:  
// Decl decl =
// 		class_decl.i		{: return i; :}
// 	| ...
// 	;

// Main model block
// Same as other blocks, but a different class for code-generation purposes.
MainBlock main_block =
    annotation_list.al? LBRACE stmt_list.s? RBRACE     {: return new MainBlock(al, s); :}
    ;    

//Program block
//used in init blocks and method body
Block block	=
	annotation_list.al? LBRACE stmt_list.s?  RBRACE	{: return new Block(al, s) ; :}
    ;

InitBlock init_block =
	block	{: return new InitBlock(block.getAnnotationsNoTransform(), block.getStmtsNoTransform()); :}
	;

VarDecl var_decl = 
    type_exp.t IDENTIFIER.i ASSIGN exp.e  {: return new VarDecl(i,t, new Opt(e)); :}
    | type_exp.t IDENTIFIER.i  {: return new VarDecl(i,t, new Opt()); :}
    ;

DataTypeDecl  datatype_decl = 
	annotation_list.al? DATA TYPEIDENTIFIER datatypeparam_list_decl.p? ASSIGN data_constructor_list.l SEMICOLON {: return new ParametricDataTypeDecl(TYPEIDENTIFIER, l, al, p); :}
   | annotation_list.al? DATA TYPEIDENTIFIER datatypeparam_list_decl.p? SEMICOLON {: return new ParametricDataTypeDecl(TYPEIDENTIFIER, new List<DataConstructor>(), al, p); :}
  ;

TypeSynDecl  typesyn_decl = 
	annotation_list.al? TYPE TYPEIDENTIFIER.lhs ASSIGN datatypeuse.rhs SEMICOLON  {: return new TypeSynDecl(lhs, al, rhs); :}
  ;


FunctionDecl  function_decl = 
	annotation_list.al? DEF datatypeuse.t IDENTIFIER.fn datatypeparam_list_decl.p LPAREN param_decl_list.l? RPAREN ASSIGN BUILTIN SEMICOLON {: return new ParametricFunctionDecl(fn, t, l, new BuiltinFunctionDef(), al, p); :}
    | annotation_list.al? DEF datatypeuse.t IDENTIFIER.fn datatypeparam_list_decl.p LPAREN param_decl_list.l? RPAREN ASSIGN data_exp.ef SEMICOLON {: return new ParametricFunctionDecl(fn, t, l, new ExpFunctionDef(ef), al, p); :}
	| annotation_list.al? DEF datatypeuse.t IDENTIFIER.fn LPAREN param_decl_list.l? RPAREN ASSIGN BUILTIN SEMICOLON {: return new FunctionDecl(fn, al, t, l, new BuiltinFunctionDef()); :}
	| annotation_list.al? DEF datatypeuse.t IDENTIFIER.fn LPAREN param_decl_list.l? RPAREN ASSIGN data_exp.ef SEMICOLON {: return new FunctionDecl(fn, al, t, l, new ExpFunctionDef(ef)); :}
	; 

InterfaceDecl interface_decl =
  annotation_list.al? INTERFACE TYPEIDENTIFIER extends_interfaces.i? LBRACE methodsig_list.l? RBRACE {: return new InterfaceDecl(TYPEIDENTIFIER, al, i, l); :}
  ;


ClassDecl class_decl =
	annotation_list.annotations? CLASS TYPEIDENTIFIER param_decls.params? implement_interfaces.i? LBRACE field_decl_list.fields? init_block.init_block? method_list.methods? RBRACE {: return new ClassDecl(TYPEIDENTIFIER, annotations, params,  i, init_block, fields, methods); :}
  ;

List data_constructor_list =
    data_constructor.i                                         {: return new List().add(i); :}
    | data_constructor_list.l BAR data_constructor.i        {: return l.add(i); :}
  ;

DataConstructor data_constructor = 
	TYPEIDENTIFIER.co  data_constructor_params.p? {: return new DataConstructor(co,p) ; :} 
	;

List data_constructor_params = 
	LPAREN datatypeuse_list.l? RPAREN     {: return l; :}
	;


List implement_interfaces =
    IMPLEMENTS ifname_list.i           {: return i; :}
  ;

List extends_interfaces =
    EXTENDS ifname_list.i           {: return i; :}
  ;


List annotation_list =
     annotation.a                          {: return new List().add(a); :}
     | annotation_list.l annotation.a      {: return l.add(a); :}
     ;

Annotation annotation =
    LBRACKET TYPEIDENTIFIER.name COLON data_exp.exp RBRACKET {: return new Annotation(name, exp); :}
    ;

InterfaceTypeUse ifname =
    TYPEIDENTIFIER {: return new InterfaceTypeUse(TYPEIDENTIFIER) ; :}
    ;

DataTypeUse datatypeuse =
	TYPEIDENTIFIER LT datatypeuse_list.p GT {: return new ParametricDataTypeUse(TYPEIDENTIFIER, p); :}
    | TYPEIDENTIFIER {: return new DataTypeUse(TYPEIDENTIFIER) ; :}
    ;

TypeParameterDecl datatypeparam =
    TYPEIDENTIFIER {: return new TypeParameterDecl(TYPEIDENTIFIER); :}
    ;

Access type_exp =
	  TYPEIDENTIFIER.id LT datatypeuse_list.p GT {: return new ParametricDataTypeUse(id, p); :}
	| TYPEIDENTIFIER.id 		{: return new UnresolvedTypeUse(id); :}
	;	

//fix class_var --> field
List field_decl_list = 
	  field_decl.i  SEMICOLON						{: return new List().add(i); :}
	| field_decl_list.l field_decl.i SEMICOLON		{: return l.add(i); :}
	; 

FieldDecl field_decl = 
    type_exp.t IDENTIFIER.i ASSIGN data_exp.e  {: return new FieldDecl(i,t, new Opt(e)); :}
    | type_exp.t IDENTIFIER.i  {: return new FieldDecl(i,t, new Opt()); :}
    ;



List param_decls = 
	LPAREN param_decl_list.f? RPAREN     {: return f ; :}
	;

List param_decl_list =
      param_decl.i                                    {: return new List().add(i); :}
    | param_decl_list.l COMMA param_decl.i        {: return l.add(i); :}
  ;

ParamDecl param_decl = 
    type_exp.t IDENTIFIER.i  {: return new ParamDecl(i,t); :}
    ;

List method_list =
     method.i                        {: return new List().add(i); :}
     | method_list.l method.i        {: return l.add(i); :}
   ;

List methodsig_list = 
    methodsig.m SEMICOLON	        	{: return new List().add(m); :}
  | methodsig_list.l methodsig.m SEMICOLON	{: return l.add(m); :}
  ;

List ifname_list =
	  ifname.i                              {: return new List().add(i); :}
    | ifname_list.l COMMA ifname.i        {: return l.add(i); :}
	;


List datatypeuse_list =
      datatypeuse.i                              {: return new List().add(i); :}
    | datatypeuse_list.l COMMA datatypeuse.i        {: return l.add(i); :}
    ;


List datatypeparam_list_decl = 
  LT datatypeparam_list.l GT {: return l; :} 
;

List datatypeparam_list =
     datatypeparam.p {: return new List().add(p); :}
   | datatypeparam_list.l COMMA datatypeparam.p {: return l.add(p); :}
   ;

MethodImpl method = 
	  methodsig.ms block.b {: return new MethodImpl(ms, b); :}
    ;

MethodSig methodsig =
	annotation_list.al? type_exp.returntype IDENTIFIER LPAREN  param_decl_list.params? RPAREN       {: return new MethodSig(IDENTIFIER, al, returntype,params); :}
    ;


PureExp pure_exp =
	  var_ref
    | NULL                 {: return new NullExp() ; :}
	| data_constructor_exp
	| let_exp
	| IDENTIFIER.f LPAREN data_exp_list.l? RPAREN {: return new FnApp(f, l) ; :}
    | IDENTIFIER.f list_literal_exp.l {: List<PureExp> llist = new List<PureExp>(); llist.add(l); {return new FnApp(f, llist) ; } :}
	| CASE data_exp.caseterm LBRACE case_branch_list.branches? RBRACE {: return new CaseExp(caseterm, branches) ; :}
    ;




//built_in or pure , since built_in_data -> int_exp -> mult_exp -> factor -> pure 
List data_exp_list = 
	  data_exp.i                            {: return new List().add(i); :}
	| data_exp_list.l COMMA data_exp.i    {: return l.add(i); :}
	;

// The List literal.  Special syntax, but allows us to construct
// arbitrary n-ary data structures (set, map, array ...) without resorting
// to chains of constructors.
PureExp list_literal_exp = LBRACKET data_exp_list.l? RBRACKET
 {: { 
        DataConstructorExp result = new DataConstructorExp("Cons", new List<PureExp>());
        DataConstructorExp current = result;
        for (Object e : l) {
            DataConstructorExp next = new DataConstructorExp("Cons", new List<PureExp>());
            current.addParamNoTransform((PureExp)e);
            current.addParamNoTransform(next);
            current = next;
        }
        current.setConstructor("Nil");
        return result ; }
 :}
 ;

PureExp data_exp = 
	  or_exp
	;

PureExp or_exp = 
      and_exp   
	| or_exp.e1 OROR and_exp.e2 {: return new OrBoolExp(e1, e2); :}
	;

PureExp and_exp = 
	equality_exp 
	| and_exp.e1 ANDAND equality_exp.e2  {: return new AndBoolExp(e1, e2); :}
	;


PureExp equality_exp = 
	relational_exp 
	| equality_exp.e1 EQEQ relational_exp.e2  {: return new EqExp(e1, e2); :}
	| equality_exp.e1 NOTEQ relational_exp.e2  {: return new NotEqExp(e1, e2); :}
	;

PureExp relational_exp = 
	add_exp
	|relational_exp.e1 LT add_exp.e2     {: return new LTExp(e1, e2); :}
	|relational_exp.e1 GT add_exp.e2     {: return new GTExp(e1, e2); :}
	|relational_exp.e1 LTEQ add_exp.e2   {: return new LTEQExp(e1, e2); :}
	|relational_exp.e1 GTEQ add_exp.e2   {: return new GTEQExp(e1, e2); :}
	;

PureExp add_exp = 
	mult_exp.e  {: return e; :}
	| add_exp.e1 PLUS mult_exp.e2   {: return new AddAddExp(e1, e2); :}
	| add_exp.e1 MINUS mult_exp.e2  {: return new SubAddExp(e1, e2); :}
  ;

PureExp mult_exp =
	factor.f {: return f; :}
	| mult_exp.e1 MULT factor.e2 {: return new MultMultExp(e1, e2); :}
	| mult_exp.e1 DIV factor.e2 {: return new DivMultExp(e1, e2); :}
	| mult_exp.e1 MOD factor.e2 {: return new ModMultExp(e1, e2); :}
	;

PureExp factor =  
 	literal 
	| pure_exp
//	| pair_exp 
	| MINUS factor.e           {: return new MinusExp(e); :} 
	| NEGATION factor.b            {: return new NegExp(b); :} 
	| LPAREN or_exp.e RPAREN {: return e; :}
	;

LiteralExp literal = 
	  int_literal.i              {: return i ; :} 
	| string_literal.s                 {: return s ; :} 
	;

// Literals 

StringLiteral string_literal = STRINGLITERAL.s {: return new StringLiteral(s); :} ;

IntLiteral int_literal = INTLITERAL.i {: return new IntLiteral(i); :} ;

LetExp let_exp = 
	LET LPAREN param_decl.var RPAREN ASSIGN data_exp.val IN data_exp.exp {: return new LetExp(var,val,exp) ; :}
	;

List case_branch_list =
    case_branch.b                         {: return new List().add(b); :}
    | case_branch_list.l case_branch.b    {: return l.add(b); :}
	;

CaseBranch case_branch =
	pattern.lhs RARROW data_exp.rhs SEMICOLON {: return new CaseBranch(lhs, rhs); :}
	; 

Pattern pattern = 
	  IDENTIFIER.v  {: return new PatternVarUse(v) ; :}
	| constructor_pattern 
	| literal.l  	{: return new LiteralPattern(l) ; :}
//  | LPAREN pattern.left COMMA pattern.right RPAREN  {: return new PatternPair(left,right) ; :}
	| USCORE {: return new UnderscorePattern() ; :}
	;

Pattern constructor_pattern = 
	TYPEIDENTIFIER.co  pattern_params.p? {: return new ConstructorPattern(co,p) ; :} 
	;

List pattern_params = 
	LPAREN pattern_list.l? RPAREN     {: return l; :}
	;
List pattern_list =
    pattern.i                              {: return new List().add(i); :}
    | pattern_list.l COMMA pattern.i        {: return l.add(i); :}
	;

PureExp data_constructor_exp =
	TYPEIDENTIFIER.co data_exp_params.l? {: return new DataConstructorExp(co,l) ; :}
	;

VarOrFieldUse var_ref =
    IDENTIFIER            {: return new VarUse(IDENTIFIER) ; :}
    | THIS                {: return new ThisExp() ; :}
	| THIS DOT IDENTIFIER   {: return new FieldUse(IDENTIFIER) ; :}
	;

GetExp get_exp =
    pure_exp.p DOT GET             {: return new GetExp(p) ; :}
    ;

Exp exp = data_exp | eff_exp ; 

Exp eff_exp = 
    new_exp 
	| async_call 
	| sync_call
    | get_exp
	; 

NewExp  new_exp = 
	NEW COG.c? TYPEIDENTIFIER.i data_exp_params.p?   {: return new NewExp(i,p,c) ; :} 
	;

List data_exp_params = 
	LPAREN data_exp_list.l? RPAREN {: return l ; :} 
	;

AsyncCall async_call = 
	THIS.callee BANG IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new AsyncCall(new ThisExp(), method,params) ; :} 
	| pure_exp.callee BANG IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new AsyncCall(callee,method,params) ; :} 
	;

SyncCall sync_call = 
	THIS.callee DOT IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new SyncCall(new ThisExp(),method,params) ; :} 
	| pure_exp.callee DOT IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new SyncCall(callee,method,params) ; :} 
	;


Stmt stmt = 
	assign_stmt             
	|  annotation_list.al? AWAIT guard SEMICOLON  {: return new AwaitStmt(al, guard) ; :}
	|  annotation_list.al? SKIP SEMICOLON         {: return new SkipStmt(al) ; :}
	|  annotation_list.al? SUSPEND SEMICOLON      {: return new SuspendStmt(al) ; :} 
	|  return_stmt 
	|  annotation_list.al? eff_exp.e SEMICOLON    {: return new ExpressionStmt(al, e) ; :}	
	|  if_then_else_stmt 
	|  while_stmt 
	|  annotation_list.al? var_decl.vd SEMICOLON  {: return new VarDeclStmt(al,vd) ; :}
	|  block
	|  annotation_list.al? SEMICOLON                    {: return new SkipStmt(al) ; :}
    |  annotation_list.al? ASSERT data_exp.e SEMICOLON  {: return new AssertStmt(al, e) ; :}
	;


Stmt return_stmt = 
	annotation_list.al? RETURN exp.e SEMICOLON        {: return new ReturnStmt(al,e) ; :}
	;

Guard guard = 	
	  var_ref.r QMARK        {: return new ClaimGuard(r) ; :} 
	| data_exp.e    {: return new ExpGuard(e) ; :} 
	| guard.g1 GUARDAND guard.g2 {: return new AndGuard(g1,g2) ; :} 
	;


IfStmt if_then_else_stmt = 
	annotation_list.al? IF LPAREN data_exp.e1 RPAREN stmt.s1 ELSE stmt.s2 {: return new IfStmt(al,e1,s1,new Opt(s2)) ; :} 
	| annotation_list.al? IF LPAREN data_exp.e1 RPAREN stmt.s1 {: return new IfStmt(al,e1,s1,new Opt()); :}
	;

WhileStmt while_stmt = 
	annotation_list.al? WHILE LPAREN data_exp.e1 RPAREN stmt.s1  {: return new WhileStmt(al,e1,s1) ; :} 
	;

AssignStmt assign_stmt =  
	annotation_list.al? var_ref.r ASSIGN exp.e SEMICOLON        {: return new AssignStmt(al,r,e) ; :} 
	;	

List stmt_list =
    stmt.i                              {: return new List().add(i); :}
    | stmt_list.l  stmt.i        {: return l.add(i); :}
	;

// Local Variables:
// tab-width: 4
// End:
