// $Id$ 
// Grammar definition for the ABS language 



%header {:

package abs.frontend.parser;
import abs.frontend.ast.*;


:};

%embed {:
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ":" + token.getColumn(token.getStart()) + ": ");
      s.append("Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new SyntaxError(s.toString(), Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("Lexical error: " + e.getMessage());
      throw new LexicalError(s.toString(), e.line, e.column);
    }
  }

  { report = new Events(); } // Use error handler in parser
  
  public void setEventHandler(Parser.Events handler) {
    report = handler;
  }

:};



Model goal =
    model.m		{: return m ; :}
  ;

Model model = 
	decl_list.l? block?	{: return new Model(l, block); :}
  ;

List decl_list =
	decl.t			{: return new List().add(t); :}
  | decl_list.l decl.t	{: return l.add(t); :}
  ;

Decl decl =
		datatype_decl
	|   typesyn_decl
	|	function_decl
	|	interface_decl
	|	class_decl
	;
// The above is equivalent to the more explicit:  
// Decl decl =
// 		class_decl.i		{: return i; :}
// 	| ...
// 	;


//Program block
//used in program, init blocks and method body
Block block	=
	LBRACE var_decls.l? stmt_list.s?  RBRACE	{: return new Block(l,s) ; :}
    ;

InitBlock init_block =
	block	{: return new InitBlock(block.getVarsNoTransform(), block.getStmtsNoTransform()); :}
	;

List var_decls = 
	var_decl_list.l SEMICOLON {: return l ; :} 
	; 


List var_decl_list =
      var_decl.i                                  {: return new List().add(i); :}
    | var_decl_list.l SEMICOLON var_decl.i        {: return l.add(i); :}
    ;

VarDecl var_decl = 
    type_exp.t IDENTIFIER.i ASSIGN data_exp.e  {: return new VarDecl(i,t, new Opt(e)); :}
    | type_exp.t IDENTIFIER.i  {: return new VarDecl(i,t, new Opt()); :}
    ;

DataTypeDecl  datatype_decl = 
	DATA TYPEIDENTIFIER LT datatypeparam_list.p GT LBRACE data_constructor_list.l? RBRACE {: return new ParametricDataTypeDecl(TYPEIDENTIFIER, l, p); :}
	| DATA TYPEIDENTIFIER LBRACE data_constructor_list.l? RBRACE {: return new DataTypeDecl(TYPEIDENTIFIER, l); :}
  ;

TypeSynDecl  typesyn_decl = 
	TYPE TYPEIDENTIFIER.lhs ASSIGN datatypeuse.rhs  {: return new TypeSynDecl(lhs, rhs); :}
  ;


FunctionDecl  function_decl = 
	DEF datatypeuse.t IDENTIFIER.fn LT datatypeparam_list.p GT LPAREN param_decl_list.l? RPAREN ASSIGN data_exp.ef {: return new ParametricFunctionDecl(fn, t, l, ef, p); :}
	| DEF datatypeuse.t IDENTIFIER.fn LPAREN param_decl_list.l? RPAREN ASSIGN data_exp.ef {: return new FunctionDecl(fn, t, l, ef); :}
	; 

InterfaceDecl interface_decl =
  INTERFACE TYPEIDENTIFIER extends_interfaces.i? LBRACE methodsig_list.l? RBRACE {: return new InterfaceDecl(TYPEIDENTIFIER, i, l); :}
  ;


ClassDecl class_decl =
	CLASS TYPEIDENTIFIER param_decls.params? implement_interfaces.i? LBRACE field_decl_list.fields? init_block.init_block? method_list.methods? RBRACE {: return new ClassDecl(TYPEIDENTIFIER, params,  i, init_block, fields, methods); :}
  ;

List data_constructor_list =
    data_constructor.i                                         {: return new List().add(i); :}
    | data_constructor_list.l data_constructor.i        {: return l.add(i); :}
  ;

DataConstructor data_constructor = 
	TYPEIDENTIFIER.co  data_constructor_params.p? SEMICOLON {: return new DataConstructor(co,p) ; :} 
	;

List data_constructor_params = 
	LPAREN datatypeuse_list.l? RPAREN     {: return l; :}
	;


List implement_interfaces =
    IMPLEMENTS ifname_list.i           {: return i; :}
  ;

List extends_interfaces =
    EXTENDS ifname_list.i           {: return i; :}
  ;



InterfaceTypeUse ifname =
    TYPEIDENTIFIER {: return new InterfaceTypeUse(TYPEIDENTIFIER) ; :}
    ;

DataTypeUse datatypeuse =
	TYPEIDENTIFIER LT datatypeuse_list.p GT {: return new ParametricDataTypeUse(TYPEIDENTIFIER, p); :}
    | TYPEIDENTIFIER {: return new DataTypeUse(TYPEIDENTIFIER) ; :}
    ;

TypeParameterDecl datatypeparam =
    TYPEIDENTIFIER {: return new TypeParameterDecl(TYPEIDENTIFIER); :}
    ;

Access type_exp =
	  TYPEIDENTIFIER.id LT datatypeuse_list.p GT {: return new ParametricDataTypeUse(id, p); :}
	| TYPEIDENTIFIER.id 		{: return new UnresolvedTypeUse(id); :}
	;	

//fix class_var --> field
List field_decl_list = 
	  field_decl.i  SEMICOLON						{: return new List().add(i); :}
	| field_decl_list.l field_decl.i SEMICOLON		{: return l.add(i); :}
	; 

FieldDecl field_decl = 
    type_exp.t IDENTIFIER.i ASSIGN data_exp.e  {: return new FieldDecl(i,t, new Opt(e)); :}
    | type_exp.t IDENTIFIER.i  {: return new FieldDecl(i,t, new Opt()); :}
    ;



List param_decls = 
	LPAREN param_decl_list.f? RPAREN     {: return f ; :}
	;

List param_decl_list =
      param_decl.i                                    {: return new List().add(i); :}
    | param_decl_list.l COMMA param_decl.i        {: return l.add(i); :}
  ;

ParamDecl param_decl = 
    type_exp.t IDENTIFIER.i  {: return new ParamDecl(i,t); :}
    ;

List method_list =
     method.i                        {: return new List().add(i); :}
     | method_list.l method.i        {: return l.add(i); :}
   ;

List methodsig_list = 
    methodsig.m SEMICOLON	        	{: return new List().add(m); :}
  | methodsig_list.l methodsig.m SEMICOLON	{: return l.add(m); :}
  ;

List ifname_list =
	  ifname.i                              {: return new List().add(i); :}
    | ifname_list.l COMMA ifname.i        {: return l.add(i); :}
	;


List datatypeuse_list =
      datatypeuse.i                              {: return new List().add(i); :}
    | datatypeuse_list.l COMMA datatypeuse.i        {: return l.add(i); :}
    ;


List datatypeparam_list =
     datatypeparam.p {: return new List().add(p); :}
   | datatypeparam_list.l COMMA datatypeparam.p {: return l.add(p); :}
   ;

Method method = 
	  methodsig.ms block.b {: return new Method(ms.getName(), ms.getReturnTypeNoTransform(), ms.getParamsNoTransform(), b); :}
    ;

MethodSig methodsig =
	type_exp.returntype IDENTIFIER LPAREN  param_decl_list.params? RPAREN       {: return new MethodSig(IDENTIFIER,returntype,params); :}
    ;


PureExp pure_exp =
	  var_ref
    | NULL                 {: return new NullExp() ; :}
	| data_constructor_exp
	| let_exp
	| IDENTIFIER.f LPAREN data_exp_list.l? RPAREN {: return new FnApp(f, l) ; :}
	| CASE data_exp.caseterm LBRACE case_branch_list.branches? RBRACE {: return new CaseExp(caseterm, branches) ; :}
    ;

//PureExp pair_exp = 
//	LPAREN data_exp.left COMMA data_exp.right RPAREN  {: return new TermPair(left,right) ; :}
//	;


//built_in or pure , since built_in_data -> int_exp -> mult_exp -> factor -> pure 
List data_exp_list = 
	  data_exp.i                            {: return new List().add(i); :}
	| data_exp_list.l COMMA data_exp.i    {: return l.add(i); :}

	;

PureExp data_exp = 
	  or_exp
	;

PureExp or_exp = 
      and_exp   
	| or_exp.e1 OROR and_exp.e2 {: return new OrBoolExp(e1, e2); :}
	;

PureExp and_exp = 
	equality_exp 
	| and_exp.e1 ANDAND equality_exp.e2  {: return new AndBoolExp(e1, e2); :}
	;


PureExp equality_exp = 
	relational_exp 
	| equality_exp.e1 EQEQ relational_exp.e2  {: return new EqExp(e1, e2); :}
	| equality_exp.e1 NOTEQ relational_exp.e2  {: return new NotEqExp(e1, e2); :}
	;

PureExp relational_exp = 
	add_exp
	|relational_exp.e1 LT add_exp.e2     {: return new LTExp(e1, e2); :}
	|relational_exp.e1 GT add_exp.e2     {: return new GTExp(e1, e2); :}
	|relational_exp.e1 LTEQ add_exp.e2   {: return new LTEQExp(e1, e2); :}
	|relational_exp.e1 GTEQ add_exp.e2   {: return new GTEQExp(e1, e2); :}
	;

PureExp add_exp = 
	mult_exp.e  {: return e; :}
	| add_exp.e1 PLUS mult_exp.e2   {: return new AddAddExp(e1, e2); :}
	| add_exp.e1 MINUS mult_exp.e2  {: return new SubAddExp(e1, e2); :}
  ;

PureExp mult_exp =
	factor.f {: return f; :}
	| mult_exp.e1 MULT factor.e2 {: return new MultMultExp(e1, e2); :}
	| mult_exp.e1 DIV factor.e2 {: return new DivMultExp(e1, e2); :}
	| mult_exp.e1 MOD factor.e2 {: return new ModMultExp(e1, e2); :}
	;

PureExp factor =  
 	literal 
	| pure_exp
//	| pair_exp 
	| MINUS factor.e           {: return new MinusExp(e); :} 
	| NEGATION factor.b            {: return new NegExp(b); :} 
	| LPAREN or_exp.e RPAREN {: return e; :}
	;

LiteralExp literal = 
	  int_literal.i              {: return i ; :} 
	| string_literal.s                 {: return s ; :} 
	;

// Literals 

StringLiteral string_literal = STRINGLITERAL.s {: return new StringLiteral(s); :} ;

IntLiteral int_literal = INTLITERAL.i {: return new IntLiteral(i); :} ;

LetExp let_exp = 
	LET LPAREN param_decl.var RPAREN ASSIGN data_exp.val IN data_exp.exp {: return new LetExp(var,val,exp) ; :}
	;

List case_branch_list =
    case_branch.b                         {: return new List().add(b); :}
    | case_branch_list.l case_branch.b    {: return l.add(b); :}
	;

CaseBranch case_branch =
	pattern.lhs RARROW data_exp.rhs SEMICOLON {: return new CaseBranch(lhs, rhs); :}
	; 

Pattern pattern = 
	  IDENTIFIER.v  {: return new PatternVar(new PatternVarDecl(v)) ; :}
	| constructor_pattern 
	| literal.l  	{: return new LiteralPattern(l) ; :}
//  | LPAREN pattern.left COMMA pattern.right RPAREN  {: return new PatternPair(left,right) ; :}
	| USCORE {: return new UnderscorePattern() ; :}
	;

Pattern constructor_pattern = 
	TYPEIDENTIFIER.co  pattern_params.p? {: return new ConstructorPattern(co,p) ; :} 
	;

List pattern_params = 
	LPAREN pattern_list.l? RPAREN     {: return l; :}
	;
List pattern_list =
    pattern.i                              {: return new List().add(i); :}
    | pattern_list.l COMMA pattern.i        {: return l.add(i); :}
	;

PureExp data_constructor_exp =
	TYPEIDENTIFIER.co data_exp_params.l? {: return new DataConstructorExp(co,l) ; :}
	;

VarOrFieldUse var_ref =
    IDENTIFIER            {: return new VarUse(IDENTIFIER) ; :}
    | THIS                {: return new ThisExp() ; :}
	| THIS DOT IDENTIFIER   {: return new FieldUse(IDENTIFIER) ; :}
	;

GetExp get_exp =
    pure_exp.p DOT GET             {: return new GetExp(p) ; :}
    ;

Exp eff_exp = 
    new_exp 
	| async_call 
	| sync_call
    | get_exp
	; 

NewExp  new_exp = 
	NEW COG.c? TYPEIDENTIFIER.i data_exp_params.p?   {: return new NewExp(i,p,c) ; :} 
	;

List data_exp_params = 
	LPAREN data_exp_list.l? RPAREN {: return l ; :} 
	;

AsyncCall async_call = 
	THIS.callee BANG IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new AsyncCall(method,params,new ThisExp()) ; :} 
	| pure_exp.callee BANG IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new AsyncCall(method,params,callee) ; :} 
	;

SyncCall sync_call = 
	THIS.callee DOT IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new SyncCall(method,params,new ThisExp()) ; :} 
	| pure_exp.callee DOT IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new SyncCall(method,params,callee) ; :} 
	;


Stmt stmt = 
	assign_stmt             
	|  AWAIT guard SEMICOLON      {: return new AwaitStmt(guard) ; :}
	|  SKIP SEMICOLON                       {: return new SkipStmt() ; :}
	|  SUSPEND SEMICOLON                   {: return new SuspendStmt() ; :} 
	|  return_stmt 
	|  eff_exp.e SEMICOLON               {: return new ExpressionStmt(e) ; :}	
	|  if_then_else_stmt 
	|  while_stmt 
	|  block
	| SEMICOLON               {: return new SkipStmt() ; :}
	;


Stmt return_stmt = 
	  RETURN eff_exp.e SEMICOLON        {: return new ReturnStmt(e) ; :}
	|  RETURN data_exp.e SEMICOLON        {: return new ReturnStmt(e) ; :}
	;

Guard guard = 	
	  var_ref.r QMARK        {: return new ClaimGuard(r) ; :} 
	| data_exp.e    {: return new ExpGuard(e) ; :} 
	| guard.g1 GUARDAND guard.g2 {: return new AndGuard(g1,g2) ; :} 
	;


IfStmt if_then_else_stmt = 
	IF LPAREN data_exp.e1 RPAREN stmt.s1 ELSE stmt.s2 {: return new IfStmt(e1,s1,new Opt(s2)) ; :} 
	| IF LPAREN data_exp.e1 RPAREN stmt.s1 {: return new IfStmt(e1, s1, new Opt()); :}
	;

WhileStmt while_stmt = 
	WHILE LPAREN data_exp.e1 RPAREN stmt.s1  {: return new WhileStmt(e1,s1) ; :} 
	;


AssignStmt assign_stmt =  
	var_ref.r ASSIGN eff_exp.e SEMICOLON        {: return new AssignStmt(r,e) ; :} 
	|	var_ref.r ASSIGN data_exp.e SEMICOLON        {: return new AssignStmt(r,e) ; :}
	;	

List stmt_list =
    stmt.i                              {: return new List().add(i); :}
    | stmt_list.l  stmt.i        {: return l.add(i); :}
	;
