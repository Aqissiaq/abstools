//$Id$ 
//Grammar definition for the ABS language, this file is input to Beaver 

%header {:

package abs.frontend.parser;
import abs.frontend.ast.*;

:};
%embed {:
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new Error(s.toString());
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new Error(s.toString());
    }
  }

  { report = new Events(); } // Use error handler in parser
:};


Program goal =
    program.p		{: return p ; :}
  ;

Program program = 
	decl_list.l? block	{: return new Program(l, block); :}
  ;


Decl decl =
		typedecl
//	|	behaviordecl
;

TypeDecl typedecl =
		interfacedecl
	|	classdecl // TODO: move to behaviordecl cf. AST def
//	| adtdecl
    ;

// The above is equivalent to the more explicit:  
// TypeDecl typedecl =
// 		interfacedecl.i		{: return i; :}
// 	| classdecl.c       	{: return c; :}
// 	;

// BehaviorDecl behaviordecl =
//		classdecl
//	|	defdecl
// ; 


InterfaceDecl interfacedecl =
  INTERFACE IDENTIFIER LBRACE methodsig_list.l? RBRACE
				{: return new InterfaceDecl(IDENTIFIER, l); :}
  ;

ClassDecl classdecl =
  CLASS IDENTIFIER implement_interfaces.i? declblock {: return new ClassDecl(IDENTIFIER, i , declblock); :}
  ;

List implement_interfaces =
    IMPLEMENTS ifName_list.i           {: return i; :}
  ;



IdUse ifName =
    IDENTIFIER {: return new IdUse(IDENTIFIER) ; :}
    ;

TypeAccess type =
	IDENTIFIER {: return new IdUse(IDENTIFIER) ; :}
	| BOOL  {: return new IdUse(BOOL) ; :}
	| FUT LPAREN IDENTIFIER RPAREN {: return new Future(IDENTIFIER) ; :}
    ;



//Is to be used in classdecl, i.e. {_T f_ ; _M_}
DeclBlock declblock =  
    LBRACE var_or_field_decl_list.l?  SEMICOLON method_list.m? RBRACE	{: return new DeclBlock(l,m) ; :}
  ;


//type the type, IDENTIFIER for the name of the variable/field.
VarOrFieldDecl var_or_field_decl = 
    type IDENTIFIER  {: return new VarOrFieldDecl(IDENTIFIER,type); :}
    ;


List var_or_field_decl_list =
    var_or_field_decl.i                                         {: return new List().add(i); :}
    | var_or_field_decl_list.l COMMA var_or_field_decl.i        {: return l.add(i); :}
  ;

List method_list =
    method.i                        {: return new List().add(i); :}
    | method_list.l method.i        {: return l.add(i); :}
  ;

List methodsig_list = 
    methodsig.m			        {: return new List().add(m); :}
  | methodsig_list.l methodsig.m	{: return l.add(m); :}
  ;

List decl_list =
    decl.t			{: return new List().add(t); :}
  | decl_list.l decl.t	{: return l.add(t); :}
  ;

//List typedecl_list =
//    typedecl.t			{: return new List().add(t); :}
//  | typedecl_list.l typedecl.t	{: return l.add(t); :}
//  ;

//List behaviordecl_list =
//    behaviordecl.t			{: return new List().add(t); :}
//  | behaviordecl_list.l behaviordecl.t	{: return l.add(t); :}
//  ;

List ifName_list =
    ifName.i                              {: return new List().add(i); :}
    | ifName_list.l COMMA ifName.i        {: return l.add(i); :}
  ;

List pure_exp_list =
    pure_exp.i                              {: return new List().add(i); :}
    | pure_exp_list.l COMMA pure_exp.i        {: return l.add(i); :}
  ;





Method method = 
    methodsig.ms block.b {: return new Method(ms,b); :}
    ;

MethodSig methodsig = 
    type IDENTIFIER LPAREN  var_or_field_decl_list.l? RPAREN       {: return new MethodSig(IDENTIFIER,type,l); :}
    ;




//Program block
//Is to be used in program, and method i.e. {_T x_ ; sr}
Block block	=
    //    LBRACE RBRACE {: return new Block() ; :} //For empty block
        LBRACE var_or_field_decl_list.l? SEMICOLON stmt_ret.s RBRACE	{: return new Block(l,s) ; :}
    ;

StmtRet stmt_ret = 
    stmt_list.l? SEMICOLON RETURN pure_exp.e                                  {: return new StmtRet(l,e) ; :}
    
    ;

PureExp pure_exp = 
    var_ref
    | get_exp
    | bool_exp
    | NULL                 {: return new NullExp() ; :}
    ;


BoolExp bool_exp = 
	NEG pure_exp.e         {: return new BoolExpNeg(e); :} 
	| pure_exp.e1 ANDAND pure_exp.e2  	{: return new BoolExpAnd(e1,e2); :} 
	| pure_exp.e1 OROR pure_exp.e2  	{: return new BoolExpOr(e1,e2); :} 
	| 	BOOLEAN_LITERAL.b    {: return new BoolLiteral(b); :}
	;

VarRef var_ref =
    IDENTIFIER            {: return new VarRef(IDENTIFIER) ; :}
    ;

GetExp get_exp =
    pure_exp.p DOT GET             {: return new GetExp(p) ; :}
    ;

EffExp eff_exp = 
    new_exp 
	| asynch_call 
	| synch_call
	| local_sync_call 
	; 


NewExp  new_exp = 
	NEW IDENTIFIER.i LPAREN RPAREN {: return new NewExp(i) ; :} 
	;

AsyncCall asynch_call = 
	pure_exp.callee BANG IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new AsyncCall(method,params,callee) ; :} 
	;
SyncCall synch_call = 
	pure_exp.callee DOT IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new SyncCall(method,params,callee) ; :} 
	;
LocalSyncCall local_sync_call =
	IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new LocalSyncCall(method,params) ; :} 
	;



Stmt stmt = 
	assign_stmt             
	|  AWAIT guard               {: return new AwaitStmt(guard) ; :}
	|  SKIP                      {: return new SkipStmt() ; :}
	|  RELEASE                   {: return new ReleaseStmt() ; :} 
	|  if_then_else_stmt         
	|  stmt_block
		;



Guard guard = 	
	| var_ref.r QMARK        {: return new ClaimGuard(r) ; :} 
	| guard.g1 GUARDAND guard.g2 {: return new AndGuard(g1,g2) ; :} 
	  //	| bool_exp.b  {: return new BoolGuard(b) ; :} 
	;


IfStmt if_then_else_stmt = 
	IF pure_exp.e1 THEN stmt.s1 ELSE stmt.s2 {: return new IfStmt(e1,s1,new Opt(s2)) ; :} 
	| IF pure_exp.e1 THEN stmt.s1 {: return new IfStmt(e1, s1, new Opt()); :}
	;

AssignStmt assign_stmt =  
	var_ref.r ASSIGN pure_exp.e        {: return new AssignStmt(r,e) ; :}
    |   var_ref.r ASSIGN eff_exp.e  {: return new AssignStmt(r,e) ; :}
    ;


StmtBlock stmt_block = 
	LBRACE stmt_list.s RBRACE       {:	return new StmtBlock(s) ; :}
    ;      

List stmt_list =
    stmt.i                              {: return new List().add(i); :}
    | stmt_list.l SEMICOLON stmt.i        {: return l.add(i); :}
  ;


/*

List XXX_list =
    XXX.i                              {: return new List().add(i); :}
    | XXX_list.l SEPARATOR XXX.i        {: return l.add(i); :}
  ;

    
/*

List block_stmt_list_opt =
                               {: return new List(); :}
  | block_stmt_list            {: return block_stmt_list; :}
  ;


BlockStmt block_stmt =
    class_decl 
  | var_decl
  | stmt
  ;

Stmt stmt =
    assign_stmt
  | while_stmt
  ;

ClassDecl class_decl =
  CLASS IDENTIFIER extends_opt block {: return new ClassDecl(IDENTIFIER, extends_opt, block); :}
  ;
Opt extends_opt =
                               {: return new Opt(); :}
  | EXTENDS IDENTIFIER         {: return new Opt(new Use(IDENTIFIER)); :}
  ;

VarDecl var_decl = 
  name IDENTIFIER SEMICOLON    {: return new VarDecl(IDENTIFIER, name); :}
  ;

AssignStmt assign_stmt =
  name ASSIGN exp SEMICOLON    {: return new AssignStmt(name, exp); :}
  ;

WhileStmt while_stmt =
  WHILE LPAREN exp RPAREN stmt {: return new WhileStmt(exp, stmt); :}
  ;

Exp exp =
    name
  | boolean_literal
  ;

Access name =
    IDENTIFIER                 {: return new Use(IDENTIFIER); :}
  | name DOT IDENTIFIER        {: return new Dot(name, new Use(IDENTIFIER)); :}
  ;

Exp boolean_literal =
  BOOLEAN_LITERAL              {: return new BooleanLiteral(BOOLEAN_LITERAL); :}
  ;
*/

