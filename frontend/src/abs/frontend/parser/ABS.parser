//$Id$ 
//Grammar definition for the ABS language, this file is input to Beaver 

%header {:

package parser;
import ast.*;

:};
%embed {:
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new Error(s.toString());
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new Error(s.toString());
    }
  }

  { report = new Events(); } // Use error handler in parser
:};


Program goal =
    program.p		{: return p ; :}
  ;

Program program = 
  typedecl_list.l? block	{: return new Program(l, block); :}
  ;



TypeDecl typedecl =
    interfacedecl.i		{: return i; :}
    | classdecl.c       	{: return c; :}
    ;

IntDecl interfacedecl =
  INTERFACE IDENTIFIER LBRACE methodsig_list.l? RBRACE
				{: return new IntDecl(IDENTIFIER, l); :}
  ;

ClassDecl classdecl =
  CLASS IDENTIFIER implement_interfaces.i? declblock {: return new ClassDecl(IDENTIFIER, i , declblock); :}
  ;

List implement_interfaces =
    IMPLEMENTS ifName_list.i           {: return i; :}
  ;



IdUse ifName =
    IDENTIFIER {: return new IdUse(IDENTIFIER) ; :}
    ;

IdUse type =
    IDENTIFIER {: return new IdUse(IDENTIFIER) ; :}
    ;



//Is to be used in classdecl, i.e. {_T f_ ; _M_}
DeclBlock declblock =  
    LBRACE var_or_field_decl_list.l?  SEMICOLON method_list.m? RBRACE	{: return new DeclBlock(l,m) ; :}
  ;


//type the type, IDENTIFIER for the name of the variable/field.
VarOrFieldDecl var_or_field_decl = 
    type IDENTIFIER  {: return new VarOrFieldDecl(IDENTIFIER,type); :}
    ;


List var_or_field_decl_list =
    var_or_field_decl.i                                         {: return new List().add(i); :}
    | var_or_field_decl_list.l COMMA var_or_field_decl.i        {: return l.add(i); :}
  ;

List method_list =
    method.i                        {: return new List().add(i); :}
    | method_list.l method.i        {: return l.add(i); :}
  ;

List methodsig_list = 
    methodsig.m			        {: return new List().add(m); :}
  | methodsig_list.l methodsig.m	{: return l.add(m); :}
  ;

List typedecl_list =
    typedecl.t			{: return new List().add(t); :}
  | typedecl_list.l typedecl.t	{: return l.add(t); :}
  ;

List ifName_list =
    ifName.i                              {: return new List().add(i); :}
    | ifName_list.l COMMA ifName.i        {: return l.add(i); :}
  ;



Method method = 
    methodsig.ms block.b {: return new Method(ms,b); :}
    ;

MethodSig methodsig = 
    type IDENTIFIER LPAREN  var_or_field_decl_list.l? RPAREN       {: return new MethodSig(IDENTIFIER,type,l); :}
    ;




//Program block, just an empty block for now, no statements.
//Is to be used in program, i.eÂ· {_T x_ ; sr}
Block block	=
    LBRACE RBRACE	{: return new Block() ; :}
    ;



/*

List XXX_list =
    XXX.i                              {: return new List().add(i); :}
    | XXX_list.l SEPARATOR XXX.i        {: return l.add(i); :}
  ;

IdUse ifName =
    IDENTIFIE {: return new IdUse(IDENTIFIER) ; :}
    ;



Method method = 
    methodSig block {: return ned  
    



/*

List block_stmt_list_opt =
                               {: return new List(); :}
  | block_stmt_list            {: return block_stmt_list; :}
  ;

List block_stmt_list =
    block_stmt                 {: return new List().add(block_stmt); :}
  | block_stmt_list block_stmt {: return block_stmt_list.add(block_stmt); :}
  ;

BlockStmt block_stmt =
    class_decl 
  | var_decl
  | stmt
  ;

Stmt stmt =
    assign_stmt
  | while_stmt
  ;

ClassDecl class_decl =
  CLASS IDENTIFIER extends_opt block {: return new ClassDecl(IDENTIFIER, extends_opt, block); :}
  ;
Opt extends_opt =
                               {: return new Opt(); :}
  | EXTENDS IDENTIFIER         {: return new Opt(new Use(IDENTIFIER)); :}
  ;

VarDecl var_decl = 
  name IDENTIFIER SEMICOLON    {: return new VarDecl(IDENTIFIER, name); :}
  ;

AssignStmt assign_stmt =
  name ASSIGN exp SEMICOLON    {: return new AssignStmt(name, exp); :}
  ;

WhileStmt while_stmt =
  WHILE LPAREN exp RPAREN stmt {: return new WhileStmt(exp, stmt); :}
  ;

Exp exp =
    name
  | boolean_literal
  ;

Access name =
    IDENTIFIER                 {: return new Use(IDENTIFIER); :}
  | name DOT IDENTIFIER        {: return new Dot(name, new Use(IDENTIFIER)); :}
  ;

Exp boolean_literal =
  BOOLEAN_LITERAL              {: return new BooleanLiteral(BOOLEAN_LITERAL); :}
  ;
*/

