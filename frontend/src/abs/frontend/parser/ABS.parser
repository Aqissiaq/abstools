//$Id$ 
//Grammar definition for the ABS language 



%header {:

package abs.frontend.parser;
import abs.frontend.ast.*;

:};

%embed {:
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new Error(s.toString());
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new Error(s.toString());
    }
  }

  { report = new Events(); } // Use error handler in parser

:};



Model goal =
    model.m		{: return m ; :}
  ;

Model model = 
	decl_list.l? block?	{: return new Model(l, block); :}
  ;

List decl_list =
	decl.t			{: return new List().add(t); :}
  | decl_list.l decl.t	{: return l.add(t); :}
  ;

Decl decl =
		datatype_decl
	|	function_decl
	|	interface_decl
	|	class_decl
	;
// The above is equivalent to the more explicit:  
// Decl decl =
// 		class_decl.i		{: return i; :}
// 	| ...
// 	;


//Program block
//used in program, init blocks and method body
Block block	=
	LBRACE var_decls.l? stmt_list.s?  RBRACE	{: return new Block(l,s) ; :}
    ;


List var_decls = 
	var_decl_list.l SEMICOLON {: return l ; :} 
	; 


DatatypeDecl  datatype_decl = 
	DATA TYPEIDENTIFIER LBRACE data_constructor_list.l? RBRACE {: return new DatatypeDecl(TYPEIDENTIFIER, l); :}
  ;


FunctionDecl  function_decl = 
	DEF datatypename.t IDENTIFIER.fn LPAREN fun_var_decl_list.l? RPAREN ASSIGN pure_exp.ef {: return new FunctionDecl(fn, t, l, ef); :}
	; //TODO : ASSIGN (=) or EQEQ == ? 


InterfaceDecl interface_decl =
  INTERFACE TYPEIDENTIFIER extends_interfaces.i? LBRACE methodsig_list.l? RBRACE {: return new InterfaceDecl(TYPEIDENTIFIER, i, l); :}
  ;


ClassDecl class_decl =
	CLASS TYPEIDENTIFIER param_decls.params? implement_interfaces.i? classblock {: return new ClassDecl(TYPEIDENTIFIER, params,  i , classblock); :}
  ;


FunVarDecl fun_var_decl = 
    datatypename.d IDENTIFIER.id  {: return new FunVarDecl(id,d); :}
    ;

List fun_var_decl_list =
    fun_var_decl.i                                    {: return new List().add(i); :}
    | fun_var_decl_list.l COMMA fun_var_decl.i        {: return l.add(i); :}
  ;



List data_constructor_list =
    data_constructor.i                                         {: return new List().add(i); :}
    | data_constructor_list.l COMMA data_constructor.i        {: return l.add(i); :}
  ;

DataConstructor data_constructor = 
	TYPEIDENTIFIER.co  data_constructor_params.p? {: return new DataConstructor(co,p) ; :} 
	;

List data_constructor_params = 
	LPAREN datatypename_list.l? RPAREN     {: return l; :}
	;


List implement_interfaces =
    IMPLEMENTS ifname_list.i           {: return i; :}
  ;

List extends_interfaces =
    EXTENDS ifname_list.i           {: return i; :}
  ;



IdUse ifname =
    TYPEIDENTIFIER {: return new IdUse(TYPEIDENTIFIER) ; :}
    ;

DataType datatypename =
    TYPEIDENTIFIER {: return new DataType(TYPEIDENTIFIER) ; :}
    ;

TypeExp type_exp = 
	TYPEIDENTIFIER.id 		{: return new UnresolvedType(id); :}
	| FUT LPAREN type_exp.t RPAREN {: return new FutureType(t); :}
	;	

// Used in class_decl, i.e. { _T f_ ; {b]  _M_ }
ClassBlock classblock =  
	LBRACE field_decls.fields? block.init_block? method_list.methods? RBRACE	{: return new ClassBlock(init_block,fields,methods) ; :}
	;


//fix class_var --> field
List field_decls = 
	var_decl.i  SEMICOLON                          {: return new List().add(i); :}
	| field_decls.l var_decl.i SEMICOLON        {: return l.add(i); :}
	; 

List var_decl_list =
    var_decl.i                                    {: return new List().add(i); :}
    | var_decl_list.l SEMICOLON var_decl.i        {: return l.add(i); :}
  ;


VarDecl var_decl = 
    type_exp.t IDENTIFIER.i  {: return new VarDecl(i,t); :}
    ;


List param_decls = 
	LPAREN param_decl_list.f? RPAREN     {: return f ; :}
	;

List param_decl_list =
    param_decl.i                                    {: return new List().add(i); :}
    |param_decl_list.l COMMA param_decl.i        {: return l.add(i); :}
  ;

ParamDecl param_decl = 
    type_exp.t IDENTIFIER.i  {: return new ParamDecl(i,t); :}
    ;

List method_list =
     method.i                        {: return new List().add(i); :}
     | method_list.l method.i        {: return l.add(i); :}
   ;

List methodsig_list = 
    methodsig.m			        {: return new List().add(m); :}
  | methodsig_list.l methodsig.m	{: return l.add(m); :}
  ;


/*
List typedecl_list =
    typedecl.t			{: return new List().add(t); :}
  | typedecl_list.l typedecl.t	{: returntypedecl l.add(t); :}
  ;
*/

//List behaviordecl_list =
//    behaviordecl.t			{: return new List().add(t); :}
//  | behaviordecl_list.l behaviordecl.t	{: return l.add(t); :}
//  ;

List ifname_list =
    ifname.i                              {: return new List().add(i); :}
    | ifname_list.l COMMA ifname.i        {: return l.add(i); :}
  ;


List datatypename_list =
    datatypename.i                              {: return new List().add(i); :}
    | datatypename_list.l COMMA datatypename.i        {: return l.add(i); :}
  ;





Method method = 
    methodsig.ms block.b {: return new Method(ms,b); :}
    ;

MethodSig methodsig =
	type_exp.returntype IDENTIFIER LPAREN  param_decl_list.params? RPAREN       {: return new MethodSig(IDENTIFIER,returntype,params); :}
    ;










PureExp pure_exp =
	var_ref
	| THIS                   {: return new ThisExp() ; :}
    | NULL                 {: return new NullExp() ; :}
	| data_constructor_exp
	| IDENTIFIER.f LPAREN pure_exp_list.l? RPAREN {: return new FnApp(f, l) ; :}
	| PAIR LPAREN pure_exp.left COMMA pure_exp.right RPAREN  {: return new TermPair(left,right) ; :}
	| CASE pure_exp.caseterm LBRACE case_branch_list.branches? RBRACE {: return new CaseExp(caseterm, branches) ; :}
    ;

List pure_exp_list =
    pure_exp.i                            {: return new List().add(i); :}
    | pure_exp_list.l COMMA pure_exp.i    {: return l.add(i); :}
  ;

List case_branch_list =
    case_branch.b                         {: return new List().add(b); :}
    | case_branch_list.l case_branch.b    {: return l.add(b); :}
	;

CaseBranch case_branch =
	data_constructor_exp.lhs RARROW pure_exp.rhs SEMICOLON {: return new CaseBranch(lhs, rhs); :}
//Do we allow the special pair constructor or a variable in the LHS 
//TODO add catchall 
	; 

DataConstructorExp data_constructor_exp =
	TYPEIDENTIFIER.co pure_exp_params.l? {: return new DataConstructorExp(co,l) ; :}
	;



VarRef var_ref =
    IDENTIFIER            {: return new LocalVarRef(IDENTIFIER) ; :}
	| THIS DOT IDENTIFIER   {: return new FieldRef(IDENTIFIER) ; :}
 ;





GetExp get_exp =
    pure_exp.p DOT GET             {: return new GetExp(p) ; :}
    ;

EffExp eff_exp = 
    new_exp 
	| async_call 
	| sync_call
    | get_exp
	; 


EqExp  eq_exp = 
	| exp.e1 EQEQ exp.e2  	{: return new EqExp(e1,e2); :}
	;


NewExp  new_exp = 
	NEW TYPEIDENTIFIER.i pure_exp_params.p?   {: return new NewExp(i,p) ; :} 
	;

List pure_exp_params = 
	LPAREN pure_exp_list.l? RPAREN {: return l ; :} 
	;


AsyncCall async_call = 
	pure_exp.callee BANG IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new AsyncCall(method,params,callee) ; :} 
	;

SyncCall sync_call = 
	THIS.callee DOT IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new SyncCall(method,params,new ThisExp()) ; :} 
	| pure_exp.callee DOT IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new SyncCall(method,params,callee) ; :} 
	;


Stmt stmt = 
	assign_stmt             
	|  AWAIT guard SEMICOLON      {: return new AwaitStmt(guard) ; :}
	|  SKIP SEMICOLON                       {: return new SkipStmt() ; :}
	|  SUSPEND SEMICOLON                   {: return new SuspendStmt() ; :} 
	|  RETURN exp.e SEMICOLON        {: return new ReturnStmt(e) ; :}
	|  eff_exp.e SEMICOLON               {: return new ExpressionStmt(e) ; :}	
	|  if_then_else_stmt 
	|  while_stmt 
	|  stmt_block
	| SEMICOLON               {: return new EmptyStmt() ; :}
		;



Guard guard = 	
	var_ref.r QMARK        {: return new ClaimGuard(r) ; :} 
	| guard.g1 GUARDAND guard.g2 {: return new AndGuard(g1,g2) ; :} 
	  //For boolean guards 
	| pure_exp.e    {: return new ExpGuard(e) ; :} 
	;


IfStmt if_then_else_stmt = 
	IF LPAREN pure_exp.e1 RPAREN stmt.s1 ELSE stmt.s2 {: return new IfStmt(e1,s1,new Opt(s2)) ; :} 
	| IF LPAREN pure_exp.e1 RPAREN stmt.s1 {: return new IfStmt(e1, s1, new Opt()); :}
	;

WhileStmt while_stmt = 
	WHILE LPAREN pure_exp.e1 RPAREN stmt.s1  {: return new WhileStmt(e1,s1) ; :} 
	;


AssignStmt assign_stmt =  
	var_ref.r ASSIGN exp.e SEMICOLON        {: return new AssignStmt(r,e) ; :}
    ;

StmtBlock stmt_block = 
	LBRACE stmt_list.l? RBRACE       {:	return new StmtBlock(l) ; :}
    ;      

List stmt_list =
    stmt.i                              {: return new List().add(i); :}
    | stmt_list.l  stmt.i        {: return l.add(i); :}
  ;



Exp exp = 
	pure_exp
	| eff_exp
	| eq_exp
	;

