//$Id$ 
//Grammar definition for the ABS language, this file is input to Beaver 

%header {:

package abs.frontend.parser;
import abs.frontend.ast.*;

:};
%embed {:
  class Events extends Parser.Events {
    public void syntaxError(Symbol token) {
      StringBuffer s = new StringBuffer();
      s.append(token.getLine(token.getStart()) + ", " + token.getColumn(token.getStart()) + "\n");
      s.append("  *** Syntactic error: unexpected token " + Terminals.NAMES[token.getId()]);
      throw new Error(s.toString());
    }
    public void scannerError(Scanner.Exception e) {
      StringBuffer s = new StringBuffer();
      s.append(e.line + ", " + e.column + "\n");
      s.append("  *** Lexical error: " + e.getMessage());
      throw new Error(s.toString());
    }
  }

  { report = new Events(); } // Use error handler in parser
:};


Program goal =
    program.p		{: return p ; :}
  ;

Program program = 
	decl_list.l? block	{: return new Program(l, block); :}
  ;

Decl decl =
		class_decl
//	|	function_decl
	|	interface_decl
	|	DATA // TODO: change to     adt_decl
	;

// The above is equivalent to the more explicit:  
// Decl decl =
// 		class_decl.i		{: return i; :}
// 	| ...
// 	;

InterfaceDecl interface_decl =
  INTERFACE IDENTIFIER extends_interfaces.i? LBRACE methodsig_list.l? RBRACE {: return new InterfaceDecl(IDENTIFIER, i, l); :}
  ;

ClassDecl class_decl =
  CLASS IDENTIFIER implement_interfaces.i? declblock {: return new ClassDecl(IDENTIFIER, i , declblock); :}
  ;

List implement_interfaces =
    IMPLEMENTS ifName_list.i           {: return i; :}
  ;

List extends_interfaces =
    EXTENDS ifName_list.i           {: return i; :}
  ;



IdUse ifName =
    IDENTIFIER {: return new IdUse(IDENTIFIER) ; :}
    ;

TypeAccess type =
	IDENTIFIER {: return new IdUse(IDENTIFIER) ; :}
	| BOOL  {: return new IdUse(BOOL) ; :}
	| FUT LPAREN IDENTIFIER RPAREN {: return new Future(IDENTIFIER) ; :}
    ;



// Used in class_decl, i.e. {_T f_ ; _M_}
DeclBlock declblock =  
    LBRACE varfielddecls.l? method_list.m? RBRACE	{: return new DeclBlock(l,m) ; :}
  ;


// Type the type, IDENTIFIER for the name of the variable/field.
VarOrFieldDecl var_or_field_decl = 
    type IDENTIFIER  {: return new VarOrFieldDecl(IDENTIFIER,type); :}
    ;


List var_or_field_decl_list =
    var_or_field_decl.i                                         {: return new List().add(i); :}
    | var_or_field_decl_list.l COMMA var_or_field_decl.i        {: return l.add(i); :}
  ;

List method_list =
    method.i                        {: return new List().add(i); :}
    | method_list.l method.i        {: return l.add(i); :}
  ;

List methodsig_list = 
    methodsig.m			        {: return new List().add(m); :}
  | methodsig_list.l methodsig.m	{: return l.add(m); :}
  ;

List decl_list =
	decl.t			{: return new List().add(t); :}
  | decl_list.l decl.t	{: return l.add(t); :}
  ;

/*
List typedecl_list =
    typedecl.t			{: return new List().add(t); :}
  | typedecl_list.l typedecl.t	{: returntypedecl l.add(t); :}
  ;
*/

//List behaviordecl_list =
//    behaviordecl.t			{: return new List().add(t); :}
//  | behaviordecl_list.l behaviordecl.t	{: return l.add(t); :}
//  ;

List ifName_list =
    ifName.i                              {: return new List().add(i); :}
    | ifName_list.l COMMA ifName.i        {: return l.add(i); :}
  ;

List pure_exp_list =
    pure_exp.i                              {: return new List().add(i); :}
    | pure_exp_list.l COMMA pure_exp.i        {: return l.add(i); :}
  ;





Method method = 
    methodsig.ms block.b {: return new Method(ms,b); :}
    ;

MethodSig methodsig = 
    type IDENTIFIER LPAREN  var_or_field_decl_list.l? RPAREN       {: return new MethodSig(IDENTIFIER,type,l); :}
    ;




//Program block
//Is to be used in program, and method i.e. {_T x_ ; sr}
Block block	=
        LBRACE varfielddecls.l? stmt_ret.s SEMICOLON RBRACE	{: return new Block(l,s) ; :}
    ;

List varfielddecls =  
	var_or_field_decl_list.l  SEMICOLON 	{: return l ; :}
	; 

StmtRet stmt_ret = 
     stmt_list.l? return_exp.e                                  {: return new StmtRet(l,e) ; :}
	;

Exp return_exp = 
	RETURN exp.e                                                {: return e ; :}


PureExp pure_exp = 
    var_ref
    | get_exp
    | bool_exp
    | NULL                 {: return new NullExp() ; :}
    ;


BoolExp bool_exp = 
	NEG pure_exp.e         {: return new BoolExpNeg(e); :} 
	| pure_exp.e1 ANDAND pure_exp.e2  	{: return new BoolExpAnd(e1,e2); :} 
	| pure_exp.e1 OROR pure_exp.e2  	{: return new BoolExpOr(e1,e2); :} 
	| pure_exp.e1 EQEQ pure_exp.e2  	{: return new BoolExpComp(e1,e2); :} 
	| 	BOOLEAN_LITERAL.b    {: return new BoolLiteral(b); :}
	;

VarRef var_ref =
    IDENTIFIER            {: return new VarRef(IDENTIFIER) ; :}
    ;

GetExp get_exp =
    pure_exp.p DOT GET             {: return new GetExp(p) ; :}
    ;

EffExp eff_exp = 
    new_exp 
	| asynch_call 
	| synch_call
	| local_sync_call 
	; 


NewExp  new_exp = 
	NEW IDENTIFIER.i LPAREN RPAREN {: return new NewExp(i) ; :} 
	;

AsyncCall asynch_call = 
	pure_exp.callee BANG IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new AsyncCall(method,params,callee) ; :} 
	;
SyncCall synch_call = 
	pure_exp.callee DOT IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new SyncCall(method,params,callee) ; :} 
	;
LocalSyncCall local_sync_call =
	IDENTIFIER.method LPAREN pure_exp_list.params? RPAREN {: return new LocalSyncCall(method,params) ; :} 
	;



Stmt stmt = 
	assign_stmt             
	|  AWAIT guard SEMICOLON      {: return new AwaitStmt(guard) ; :}
	|  SKIP SEMICOLON                       {: return new SkipStmt() ; :}
	|  RELEASE SEMICOLON                   {: return new ReleaseStmt() ; :} 
	|  if_then_else_stmt         
	|  stmt_block
	| SEMICOLON               {: return new EmptyStmt() ; :}
		;



Guard guard = 	
	| var_ref.r QMARK        {: return new ClaimGuard(r) ; :} 
	| guard.g1 GUARDAND guard.g2 {: return new AndGuard(g1,g2) ; :} 
	  //	| bool_exp.b  {: return new BoolGuard(b) ; :} 
	;


IfStmt if_then_else_stmt = 
	IF pure_exp.e1 THEN stmt.s1 ELSE stmt.s2 {: return new IfStmt(e1,s1,new Opt(s2)) ; :} 
	| IF pure_exp.e1 THEN stmt.s1 {: return new IfStmt(e1, s1, new Opt()); :}
	;

AssignStmt assign_stmt =  
	var_ref.r ASSIGN exp.e SEMICOLON        {: return new AssignStmt(r,e) ; :}
    ;


StmtBlock stmt_block = 
	LBRACE stmt_list.l? RBRACE       {:	return new StmtBlock(l) ; :}
    ;      

List stmt_list =
    stmt.i                              {: return new List().add(i); :}
    | stmt_list.l  stmt.i        {: return l.add(i); :}
  ;



Exp exp = 
	pure_exp	
	| eff_exp
	;

