// $Id$ 
// Grammar definition for the ABS language 



%header {:

package abs.frontend.parser;
import abs.frontend.ast.*;
import abs.common.*;
import java.io.File;


:};

%embed {:
	ArrayList<ParserError> errors = new ArrayList<ParserError>();
    boolean raiseExceptions = true;
    File file;
    String sourceCode; // only set if not read from file

	public void setSourceCode(String sourceCode) {
	   this.sourceCode = sourceCode;
	}

	public void setFile(File file) {
	   this.file = file;
	}

	class Events extends Parser.Events {
		public void syntaxError(Symbol token) {
			SyntaxError e = new SyntaxError("Syntactic error: unexpected token " + Terminals.NAMES[token.getId()], Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
			e.setFile(file);
			e.setSourceCode(sourceCode);
			errors.add(e);
			if (raiseExceptions) 
				throw new ParseException(e);
		}
		public void scannerError(Scanner.Exception e) {
			LexicalError err = new LexicalError("Lexical error: " + e.getMessage(), e.line, e.column);
			err.setFile(file);
			err.setSourceCode(sourceCode);
			errors.add(err);
			if (raiseExceptions) 
				throw new ParseException(err);
		}
	}

	{ report = new Events(); } // Use error handler in parser
  
	public void doRaiseExceptions(boolean raiseExceptions) {
		this.raiseExceptions = raiseExceptions;
	}

	public ArrayList<ParserError> getErrors() { return errors; }
	
	public String getFileName() {
		if (file != null)
		    return file.getAbsolutePath();
		return "<unknown>";
	}
:};



CompilationUnit goal =
    compilation_unit.cu		{: return cu ; :}
  ;

CompilationUnit compilation_unit = 
	module_decl_list.m? {: return new CompilationUnit(getFileName(),m); :}
  ;

ModuleDecl module_decl = 
	  module_name_decl.n export_list.el? import_list.il? decl_list.dl? product_line.pr? product_list.pl? main_block.b?
	  {: return new ModuleDecl(n.getName(),el,il,dl,pr,pl,b); :} 	
  ;

List module_decl_list =
	module_decl.t			{: return new List().add(t); :}
  | module_decl_list.l module_decl.t	{: return l.add(t); :}
  ;

  
Name module_name_decl =
    MODULE module_name.n SEMICOLON {: return n; :}
  ; 

Name module_name = type_name ;

Name simple_type_name =
  TYPE_IDENTIFIER.id      {: return new Name(id); :}
;
        
Name simple_name =
    IDENTIFIER.id  {: return new Name(id); :}  
;
        
Name name =
	simple_name     
  | qualified_name
;

Name type_name =
    simple_type_name
  | qualified_type_name 
;

Name any_name = 
    name 
  | type_name
;


Name qualified_name =
    type_name.qn DOT IDENTIFIER.n {: return new Name(qn.getName() + "." + n); :}
  ;

Name qualified_type_name =
    type_name.qn DOT TYPE_IDENTIFIER.n {: return new Name(qn.getName() + "." + n); :} 
  ;
  
Export export =
  EXPORT any_name_list.l SEMICOLON {: return new NamedExport(l); :}
  | EXPORT MULT SEMICOLON {: return new StarExport(); :}
  | EXPORT MULT FROM module_name.m SEMICOLON {: return new StarExport(new Opt(m)); :}
  | EXPORT any_name_list.l FROM module_name.m SEMICOLON {: return new FromExport(l,m.getName()); :}
;

Import import =
    IMPORT MULT FROM module_name.m SEMICOLON {: return new StarImport(m.getName()); :}
  | IMPORT any_name_list.l FROM module_name.m SEMICOLON {: return new FromImport(l,m.getName()); :}
  | IMPORT any_name_list.l SEMICOLON {: return new NamedImport(l); :}
;

List export_list =
	export.t			{: return new List().add(t); :}
  | export_list.l export.t	{: return l.add(t); :}
;

List import_list =
	import.t			{: return new List().add(t); :}
  | import_list.l import.t	{: return l.add(t); :}
;

List any_name_list =
    any_name.n {: return new List().add(n); :}
  | any_name_list.l COMMA any_name.n {: return l.add(n); :}
;

List decl_list =
	decl.t			{: return new List().add(t); :}
  | decl_list.l decl.t	{: return l.add(t); :}
  ;

Decl decl =
		datatype_decl
	|   typesyn_decl
	|	function_decl
	|	interface_decl
	|	class_decl
    |   delta_decl
	;

// Same as other blocks, but a different class for code-generation purposes.
MainBlock main_block =
    annotation_list.al? LBRACE stmt_list.s? RBRACE     {: return new MainBlock(al, s); :}
    ;    

//used in init blocks and method body
Block block	=
	annotation_list.al? LBRACE stmt_list.s?  RBRACE	{: return new Block(al, s) ; :}
    ;

InitBlock init_block =
	block	{: return new InitBlock(block.getAnnotationsNoTransform(), block.getStmtsNoTransform()); :}
	;

VarDecl var_decl = 
    type_exp.t IDENTIFIER.i ASSIGN exp.e  {: return new VarDecl(i,t, new Opt(e)); :}
    | type_exp.t IDENTIFIER.i  {: return new VarDecl(i,t, new Opt()); :}
    ;

DataTypeDecl  datatype_decl = 
	annotation_list.al? DATA TYPE_IDENTIFIER.id datatypeparam_list_decl.p? ASSIGN data_constructor_list.l SEMICOLON 
	{: return new ParametricDataTypeDecl(id, l, al, p); :}
   | annotation_list.al? DATA TYPE_IDENTIFIER.id datatypeparam_list_decl.p? SEMICOLON 
    {: return new ParametricDataTypeDecl(id, new List<DataConstructor>(), al, p); :}
  ;

TypeSynDecl  typesyn_decl = 
	annotation_list.al? TYPE TYPE_IDENTIFIER.lhs ASSIGN datatypeuse.rhs SEMICOLON  {: return new TypeSynDecl(lhs, al, rhs); :}
  ;


FunctionDecl  function_decl = 
	annotation_list.al? DEF datatypeuse.t IDENTIFIER.fn datatypeparam_list_decl.p LPAREN param_decl_list.l? RPAREN ASSIGN BUILTIN SEMICOLON {: return new ParametricFunctionDecl(fn, t, l, new BuiltinFunctionDef(), al, p); :}
    | annotation_list.al? DEF datatypeuse.t IDENTIFIER.fn datatypeparam_list_decl.p LPAREN param_decl_list.l? RPAREN ASSIGN data_exp.ef SEMICOLON {: return new ParametricFunctionDecl(fn, t, l, new ExpFunctionDef(ef), al, p); :}
	| annotation_list.al? DEF datatypeuse.t IDENTIFIER.fn LPAREN param_decl_list.l? RPAREN ASSIGN BUILTIN SEMICOLON {: return new FunctionDecl(fn, al, t, l, new BuiltinFunctionDef()); :}
	| annotation_list.al? DEF datatypeuse.t IDENTIFIER.fn LPAREN param_decl_list.l? RPAREN ASSIGN data_exp.ef SEMICOLON {: return new FunctionDecl(fn, al, t, l, new ExpFunctionDef(ef)); :}
	; 

InterfaceDecl interface_decl =
  annotation_list.al? INTERFACE TYPE_IDENTIFIER.id extends_interfaces.i? LBRACE methodsig_list.l? RBRACE 
  {: return new InterfaceDecl(id, al, i, l); :}
  ;


ClassDecl class_decl =
	annotation_list.annotations? CLASS TYPE_IDENTIFIER.id param_decls.params? implement_interfaces.i? LBRACE field_decl_list.fields? init_block.init_block? method_list.methods? RBRACE 
	{: return new ClassDecl(id, annotations, params,  i, init_block, fields, methods); :}
  ;

DeltaDecl delta_decl =
    annotation_list.annotations? DELTA TYPE_IDENTIFIER.id LBRACE class_modifier_list.modifiers? RBRACE {: return new DeltaDecl(id, annotations, modifiers); :} ;

List class_modifier_list =
    class_modifier.m {: return new List().add(m); :}
  | class_modifier_list.l class_modifier.m {: return l.add(m); :}
  ;

ClassModifier class_modifier =
    MODIFIES TYPE_IDENTIFIER.id LBRACE modifier_fragment_list.fragments? RBRACE {: return new ClassModifier(id, fragments); :} ;

List modifier_fragment_list =
    modifier_fragment.f {: return new List().add(f); :}
  | modifier_fragment_list.l modifier_fragment.f {: return l.add(f); :}
  ;

ModifierFragment modifier_fragment =
    ADDS method.m {: return new AddMethodModifier(m); :}
  | MODIFIES method.m {: return new ModifyMethodModifier(m); :}
  | REMOVES methodsig.ms SEMICOLON {: return new RemoveMethodModifier(ms); :}
  ;

List data_constructor_list =
    data_constructor.i                                         {: return new List().add(i); :}
    | data_constructor_list.l BAR data_constructor.i        {: return l.add(i); :}
  ;

DataConstructor data_constructor = 
	TYPE_IDENTIFIER.co  data_constructor_params.p? {: return new DataConstructor(co,p) ; :} 
	;

List data_constructor_params = 
	LPAREN datatypeuse_list.l? RPAREN     {: return l; :}
	;


List implement_interfaces =
    IMPLEMENTS ifname_list.i           {: return i; :}
  ;

List extends_interfaces =
    EXTENDS ifname_list.i           {: return i; :}
  ;


List annotation_list =
     annotation.a                          {: return new List().add(a); :}
     | annotation_list.l annotation.a      {: return l.add(a); :}
     ;

Annotation annotation =
    LBRACKET TYPE_IDENTIFIER.name COLON data_exp.exp RBRACKET {: return new Annotation(name, exp); :}
    ;

InterfaceTypeUse ifname =
    type_name.n {: return new InterfaceTypeUse(n.getName()) ; :}
    ;

DataTypeUse datatypeuse =
	  type_name.n LT datatypeuse_list.p GT {: return new ParametricDataTypeUse(n.getName(), p); :}
	| type_name.n {: return new DataTypeUse(n.getName()); :}
    ;

TypeParameterDecl datatypeparam =
    TYPE_IDENTIFIER.id {: return new TypeParameterDecl(id); :}
    ;

Access type_exp =
	  type_name.id LT datatypeuse_list.p GT {: return new ParametricDataTypeUse(id.getName(), p); :}
	| type_name.id 		{: return new DataTypeUse(id.getName()); :}
	;	

//fix class_var --> field
List field_decl_list = 
	  field_decl.i  SEMICOLON						{: return new List().add(i); :}
	| field_decl_list.l field_decl.i SEMICOLON		{: return l.add(i); :}
	; 

FieldDecl field_decl = 
    type_exp.t IDENTIFIER.i ASSIGN data_exp.e  {: return new FieldDecl(i,t, new Opt(e)); :}
    | type_exp.t IDENTIFIER.i  {: return new FieldDecl(i,t, new Opt()); :}
    ;



List param_decls = 
	LPAREN param_decl_list.f? RPAREN     {: return f ; :}
	;

List param_decl_list =
      param_decl.i                                    {: return new List().add(i); :}
    | param_decl_list.l COMMA param_decl.i        {: return l.add(i); :}
  ;

ParamDecl param_decl = 
    type_exp.t IDENTIFIER.i  {: return new ParamDecl(i,t); :}
    ;

List method_list =
     method.i                        {: return new List().add(i); :}
     | method_list.l method.i        {: return l.add(i); :}
   ;

List methodsig_list = 
    methodsig.m SEMICOLON	        	{: return new List().add(m); :}
  | methodsig_list.l methodsig.m SEMICOLON	{: return l.add(m); :}
  ;

List ifname_list =
	  ifname.i                              {: return new List().add(i); :}
    | ifname_list.l COMMA ifname.i        {: return l.add(i); :}
	;


List datatypeuse_list =
      datatypeuse.i                              {: return new List().add(i); :}
    | datatypeuse_list.l COMMA datatypeuse.i        {: return l.add(i); :}
    ;


List datatypeparam_list_decl = 
  LT datatypeparam_list.l GT {: return l; :} 
;

List datatypeparam_list =
     datatypeparam.p {: return new List().add(p); :}
   | datatypeparam_list.l COMMA datatypeparam.p {: return l.add(p); :}
   ;

MethodImpl method = 
	  methodsig.ms block.b {: return new MethodImpl(ms, b); :}
    ;

MethodSig methodsig =
	annotation_list.al? type_exp.returntype IDENTIFIER.id LPAREN  param_decl_list.params? RPAREN       
	{: return new MethodSig(id, al, returntype,params); :}
    ;

PureExp pure_exp =
	  var_or_field_ref   
    | NULL                 {: return new NullExp() ; :}
	| let_exp  
	| constructor_exp
	| fnapp_exp
    | fnapp_list_exp
    | case_exp
    ;

PureExp var_or_field_ref =
      THIS                {: return new ThisExp() ; :}
	| THIS DOT IDENTIFIER.id   {: return new FieldUse(id) ; :}
    | IDENTIFIER.n {: return new VarUse(n); :} 
	;

FnApp fnapp_list_exp = 
    name.f list_literal_exp.l {: List<PureExp> llist = new List<PureExp>(); llist.add(l); {return new FnApp(f.getName(), llist) ; } :}
    ;

FnApp fnapp_exp =
	name.f LPAREN data_exp_list.l? RPAREN {: return new FnApp(f.getName(), l) ; :}
    ;

DataConstructorExp constructor_exp =
	  type_name.f LPAREN data_exp_list.l? RPAREN {: return new DataConstructorExp(f.getName(), l) ; :}
	| type_name.f {: return new DataConstructorExp(f.getName(), new List()) ; :}
    ;

    
CaseExp case_exp = 
	CASE data_exp.caseterm LBRACE case_branch_list.branches? RBRACE {: return new CaseExp(caseterm, branches) ; :}
;

//built_in or pure , since built_in_data -> int_exp -> mult_exp -> factor -> pure 
List data_exp_list = 
	  data_exp.i                            {: return new List().add(i); :}
	| data_exp_list.l COMMA data_exp.i    {: return l.add(i); :}
	;


// The List literal.  Special syntax, but allows us to construct
// arbitrary n-ary data structures (set, map, array ...) without resorting
// to chains of constructors.
PureExp list_literal_exp = LBRACKET data_exp_list.l? RBRACKET
 {: { 
        DataConstructorExp result = new DataConstructorExp("Cons", new List<PureExp>());
        DataConstructorExp current = result;
        for (Object e : l) {
            DataConstructorExp next = new DataConstructorExp("Cons", new List<PureExp>());
            current.addParamNoTransform((PureExp)e);
            current.addParamNoTransform(next);
            current = next;
        }
        current.setConstructor("Nil");
        return result ; }
 :}
 ;

PureExp data_exp = 
	  or_exp
	;

PureExp or_exp = 
      and_exp   
	| or_exp.e1 OROR and_exp.e2 {: return new OrBoolExp(e1, e2); :}
	;

PureExp and_exp = 
	equality_exp 
	| and_exp.e1 ANDAND equality_exp.e2  {: return new AndBoolExp(e1, e2); :}
	;


PureExp equality_exp = 
	relational_exp 
	| equality_exp.e1 EQEQ relational_exp.e2  {: return new EqExp(e1, e2); :}
	| equality_exp.e1 NOTEQ relational_exp.e2  {: return new NotEqExp(e1, e2); :}
	;

PureExp relational_exp = 
	add_exp
	|relational_exp.e1 LT add_exp.e2     {: return new LTExp(e1, e2); :}
	|relational_exp.e1 GT add_exp.e2     {: return new GTExp(e1, e2); :}
	|relational_exp.e1 LTEQ add_exp.e2   {: return new LTEQExp(e1, e2); :}
	|relational_exp.e1 GTEQ add_exp.e2   {: return new GTEQExp(e1, e2); :}
	;

PureExp add_exp = 
	mult_exp.e  {: return e; :}
	| add_exp.e1 PLUS mult_exp.e2   {: return new AddAddExp(e1, e2); :}
	| add_exp.e1 MINUS mult_exp.e2  {: return new SubAddExp(e1, e2); :}
  ;

PureExp mult_exp =
	factor.f {: return f; :}
	| mult_exp.e1 MULT factor.e2 {: return new MultMultExp(e1, e2); :}
	| mult_exp.e1 DIV factor.e2 {: return new DivMultExp(e1, e2); :}
	| mult_exp.e1 MOD factor.e2 {: return new ModMultExp(e1, e2); :}
	;

PureExp factor =  
 	literal 
	| pure_exp
//	| pair_exp 
	| MINUS factor.e           {: return new MinusExp(e); :} 
	| NEGATION factor.b            {: return new NegExp(b); :} 
	| LPAREN or_exp.e RPAREN {: return e; :}
	;

LiteralExp literal = 
	  int_literal.i              {: return i ; :} 
	| string_literal.s                 {: return s ; :} 
	;

// Literals 

StringLiteral string_literal = STRINGLITERAL.s {: return new StringLiteral(s); :} ;

IntLiteral int_literal = INTLITERAL.i {: return new IntLiteral(i); :} ;

LetExp let_exp = 
	LET LPAREN param_decl.var RPAREN ASSIGN data_exp.val IN data_exp.exp {: return new LetExp(var,val,exp) ; :}
	;

List case_branch_list =
    case_branch.b                         {: return new List().add(b); :}
    | case_branch_list.l case_branch.b    {: return l.add(b); :}
	;

CaseBranch case_branch =
	pattern.lhs RARROW data_exp.rhs SEMICOLON {: return new CaseBranch(lhs, rhs); :}
	; 

Pattern pattern =
 	  IDENTIFIER.v  {: return new PatternVarUse(v) ; :}
	| constructor_pattern 
	| literal.l  	{: return new LiteralPattern(l) ; :}
//  | LPAREN pattern.left COMMA pattern.right RPAREN  {: return new PatternPair(left,right) ; :}
	| USCORE {: return new UnderscorePattern() ; :}
	;

Pattern constructor_pattern = 
	type_name.co pattern_params.p? {: return new ConstructorPattern(co.getName(),p) ; :} 
	;

List pattern_params = 
	LPAREN pattern_list.l? RPAREN     {: return l; :}
	;

List pattern_list =
    pattern.i                              {: return new List().add(i); :}
    | pattern_list.l COMMA pattern.i        {: return l.add(i); :}
	;

Exp exp = 
	  eff_exp.e   {: return e; :}
	| data_exp.e  {: return e; :}
	;

Exp eff_exp = 
    pure_exp.p DOT GET    {: return new GetExp(p) ; :}
    | new_exp 
	| async_call 
	| sync_call
	; 

NewExp new_exp = 
	  NEW type_name.i LPAREN data_exp_list.l? RPAREN   {: return new NewExp(i.getName(),l,"") ; :} 
	| NEW COG.c type_name.i LPAREN data_exp_list.l? RPAREN   {: return new NewExp(i.getName(),l,c) ; :} 
	;

AsyncCall async_call = 
	THIS.callee BANG IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new AsyncCall(new ThisExp(), method,params) ; :} 
	| pure_exp.callee BANG IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new AsyncCall(callee,method,params) ; :} 
	;

SyncCall sync_call = 
	THIS.callee DOT IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new SyncCall(new ThisExp(),method,params) ; :} 
	| pure_exp.callee DOT IDENTIFIER.method LPAREN data_exp_list.params? RPAREN {: return new SyncCall(callee,method,params) ; :} 
	;


Stmt stmt = 
	assign_stmt             
	|  annotation_list.al? AWAIT guard SEMICOLON  {: return new AwaitStmt(al, guard) ; :}
	|  annotation_list.al? SKIP SEMICOLON         {: return new SkipStmt(al) ; :}
	|  annotation_list.al? SUSPEND SEMICOLON      {: return new SuspendStmt(al) ; :} 
	|  return_stmt 
	|  annotation_list.al? eff_exp.e SEMICOLON    {: return new ExpressionStmt(al, e) ; :}	
	|  if_then_else_stmt 
	|  while_stmt 
	|  annotation_list.al? var_decl.vd SEMICOLON  {: return new VarDeclStmt(al,vd) ; :}
	|  block
	|  annotation_list.al? SEMICOLON                    {: return new SkipStmt(al) ; :}
    |  annotation_list.al? ASSERT data_exp.e SEMICOLON  {: return new AssertStmt(al, e) ; :}
	;


Stmt return_stmt = 
	annotation_list.al? RETURN exp.e SEMICOLON        {: return new ReturnStmt(al,e) ; :}
	;

Guard guard = 	
	  var_or_field_ref.r QMARK        {: return new ClaimGuard(r) ; :} 
	| data_exp.e    {: return new ExpGuard(e) ; :} 
	| guard.g1 GUARDAND guard.g2 {: return new AndGuard(g1,g2) ; :} 
	;


IfStmt if_then_else_stmt = 
	annotation_list.al? IF LPAREN data_exp.e1 RPAREN stmt.s1 ELSE stmt.s2 {: return new IfStmt(al,e1,s1,new Opt(s2)) ; :} 
	| annotation_list.al? IF LPAREN data_exp.e1 RPAREN stmt.s1 {: return new IfStmt(al,e1,s1,new Opt()); :}
	;

WhileStmt while_stmt = 
	annotation_list.al? WHILE LPAREN data_exp.e1 RPAREN stmt.s1  {: return new WhileStmt(al,e1,s1) ; :} 
	;

AssignStmt assign_stmt =  
	annotation_list.al? var_or_field_ref.r ASSIGN exp.e SEMICOLON        {: return new AssignStmt(al,r,e) ; :} 
	;	

List stmt_list =
    stmt.i                              {: return new List().add(i); :}
    | stmt_list.l  stmt.i        {: return l.add(i); :}
	;




ProductLine product_line =
    PRODUCTLINE TYPE_IDENTIFIER.id LBRACE
    optfeature_list.o
    corefeature_list.c
    deltacondition_list.d
    RBRACE
    {: return new ProductLine(id, o, c, d); :}
    ;

List optfeature_list = {: return new List(); :}
    | OPTFEATURES feature_list.l SEMICOLON {: return l; :}
    ;

List corefeature_list = {: return new List(); :}
    | COREFEATURES feature_list.l SEMICOLON {: return l; :}
    ;

List feature_list = feature.f {: return new List().add(f); :}
    | feature_list.l COMMA feature.f {: return l.add(f); :}
    ;

Feature feature = TYPE_IDENTIFIER.id {: return new Feature(id); :} ;


List deltacondition_list = {: return new List(); :}
    | deltacondition_list.l DELTA delta.d after_condition.a? when_condition.w?
      SEMICOLON {: return l.add(new Deltacondition(d, a, w)); :};

Delta after_condition = AFTER delta.d {: return d; :} ;

Delta delta = TYPE_IDENTIFIER.id {: return new Delta(id); :} ;

List when_condition = WHEN application_condition.dl {: return dl; :};

List application_condition = feature.f {: return new List().add(f); :}
    | application_condition.l ANDAND feature.f {: return l.add(f); :}
    ;

List product_list = product.p {: return new List().add(p); :}
    | product_list.l product.p {: return l.add(p); :}
    ;

Product product = PRODUCT TYPE_IDENTIFIER.id LPAREN feature_list.l RPAREN main_block.b
    {: return new Product(id, l, b); :} ;
        

// Local Variables:
// tab-width: 4
// End:
