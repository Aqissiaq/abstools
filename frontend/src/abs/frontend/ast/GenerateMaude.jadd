// -*- mode: java; tab-width: 4; -*-

aspect GenerateMaude {

    // Differentiate between function parameters and other variables.
    // FIXME: this does not consider shadowing rebinding of variables
    // inside the function body, e.g. via `case' expressions.
    eq FunctionDecl.getFunDef().functionParameters() = getParams();
    eq Block.getStmt(int index).functionParameters() = new List<VarOrFieldDecl>();
    inh List<VarOrFieldDecl> Stmt.functionParameters();
    inh List<VarOrFieldDecl> Exp.functionParameters();

    syn boolean VarOrFieldUse.isFunctionParameter();
    eq VarOrFieldUse.isFunctionParameter() {
        for (VarOrFieldDecl param : functionParameters()) {
            if (param.getName().equals(getName())) return true;
        }
        return false;
    }

    // Calculate whether the method is inside an active class; needed
    // for init block behavior.
    eq ClassDecl.getMethod(int index).inActiveClass() = isActiveClass();
    inh boolean Method.inActiveClass();

    syn boolean ClassDecl.isActiveClass();
    eq ClassDecl.isActiveClass() {
        for (Method method : getMethods()) {
            if (method.getName().equals("run")) return true;
        }
        return false;
    }

    // New rule!  Everyone can expect sufficient whitespace to be set
    // up, but has to leave whitespace at the end if needed.

    public void Model.generateMaude(java.io.PrintStream stream) {
        boolean hasClasses = false;
        stream.println("in abs-interpreter\n\nmod MODEL is\nprotecting ABS-SIMULATOR .\n");
        for (Decl decl : getDecls()) {
            if (decl.getClass() == FunctionDecl.class)
                decl.generateMaude(stream);
        }
        stream.println("op classes : -> Configuration .");
        stream.print("eq classes =");
        for (Decl decl : getDecls()) {
            if (decl.getClass() == ClassDecl.class) {
                hasClasses = true;
                decl.generateMaude(stream);
            }
        }
        if (hasBlock()) {
            // Create an artificial class that is started by the
            // interpreter.
            stream.print("\n\n< \".Start\" : Class |\n  Param: noVid,\n  Att: ");
            if (getBlock().getNumField() == 0) {
                stream.println("noSubst,");
            } else {
                for (VarDecl field : getBlock().getFields()) {
                    stream.print("@ \"" + field.getName() + "\" |-> null , ");
                }
            }
            stream.print("\n  Mtds: ");
            // hand-craft init method - we're not inside a class
            stream.print("< \".init\" : Method | Param: noVid, Att: noSubst");
            stream.print(",\n      Code: ");
            if (getBlock().getNumStmt() == 0) {
                stream.print("noStmt ");
            } else {
                boolean inlist = false;
                for (Stmt stmt : getBlock().getStmts()) {
                    if (inlist) stream.print("; "); else inlist = true;
                    stmt.generateMaude(stream);
                }
            }
            stream.print("> ,\n  Ocnt: 0 > ");
        }
        if (!hasBlock() && !hasClasses) stream.print(" none ");
        stream.println(".");
        stream.println("\n--- Start the model with 'rew start .'");
        stream.println("op start : -> State .");
        stream.println("eq start = main(classes, \".Start\", emp) .");
        stream.println("\nendm");
    }

	abstract public void Decl.generateMaude(java.io.PrintStream stream);

	public void InterfaceDecl.generateMaude(java.io.PrintStream stream) {
		stream.println("*** Interface code ...");
	}

	public void DataTypeDecl.generateMaude(java.io.PrintStream stream) {
		stream.println("*** Datatype " + getName());
	}

	public void TypeSynDecl.generateMaude(java.io.PrintStream stream) {
		stream.println("*** Type synonym: Datatype " + getName());
	}

	
	public void FunctionDecl.generateMaude(java.io.PrintStream stream) {
		boolean inList = false;
		stream.print("eq \"" + getName() + "\"(");
		for (VarOrFieldDecl param : getParams()) {
			if (inList == false) inList = true; else stream.print(" :: ");
			stream.print(param.getName() + ":Data");
		}
		stream.print(") =\n   ") ;
		getFunDef().generateMaude(stream);
        stream.println(".");
	}

    abstract public void Exp.generateMaude(java.io.PrintStream stream);

    public void Access.generateMaude(java.io.PrintStream stream) {
        stream.println("--- Hey, I didn't expect this to be generated! " + getClass().toString());
    }

    abstract public void Exp.generateMaudeAsStatement(java.io.PrintStream stream, String var);
    public void PureExp.generateMaudeAsStatement(java.io.PrintStream stream, String var)
    {
        stream.print("noStmt");
    }

    public void EffExp.generateMaude(java.io.PrintStream stream) {
        stream.println("--- Hey, you used a side-effecting expression as a normal one! " + getClass().toString());
    }
    public void AsyncCall.generateMaudeAsStatement(java.io.PrintStream stream, String var)
    {
        boolean inlist = false;
        stream.print("call(@ \"" + var + "\" ; ");
        getCallee().generateMaude(stream);
        stream.print(" ; \"" + getMethod() + "\" ; ");
        if (getNumParam() == 0) {
            stream.print("emp");
        } else {
            stream.print("(");
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            stream.print(")");
        }
        stream.print(") ");
    }

    public void SyncCall.generateMaudeAsStatement(java.io.PrintStream stream, String var)
    {
        boolean inlist = false;
        stream.print("call(@ \"" + var + "_future\", ");
        getCallee().generateMaude(stream);
        stream.print(", " + getMethod() + ", ");
        if (getNumParam() == 0) {
            stream.print("emp");
        } else {
            stream.print("(");
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            stream.print(")");
        }
        stream.print(") ; get( @ \"" + var + "_future\" ; @ \"" + var + "\") ");
    }

    public void GetExp.generateMaudeAsStatement(java.io.PrintStream stream, String var)
    {
        stream.print("get(");
        getPureExp().generateMaude(stream);
        stream.print(" ; @ \"" + var + "\") ");        
    }

    public void NewExp.generateMaudeAsStatement(java.io.PrintStream stream, String var)
    {
        boolean inlist = false;
        stream.print("new(@ \"" + var + "\" ; \"" + getClassRef() + "\" ; ");
        if (getNumParam() == 0) {
            stream.print("emp");
        } else {
            stream.print("(");
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            stream.print(")");
        }
        stream.print(") ");
    }

    abstract public void LiteralExp.generateMaude(java.io.PrintStream stream);

    public void StringLiteral.generateMaude(java.io.PrintStream stream) {
        stream.print("\"str\"[\"" + getContent() + "\"] ");
    }

    public void IntLiteral.generateMaude(java.io.PrintStream stream) {
        stream.print("\"int\"[" + getContent() + "] ");
    }

    public void BoolLiteral.generateMaude(java.io.PrintStream stream) {
        stream.print("\"bool\"[" + getContent().toLowerCase() + "] ");
    }

    syn String Unary.maudePrefixOperator();
    eq MinusExp.maudePrefixOperator() = "-";
    eq NegExp.maudePrefixOperator() = "~";
    public void Unary.generateMaude(java.io.PrintStream stream) {
        stream.print("\"" + maudePrefixOperator() + "\"( ");
        getOperand().generateMaude(stream);
        stream.print(") ");
    }

    syn String Binary.maudeInfixOperator();
    eq EqExp.maudeInfixOperator() = "=";
    eq NotEqExp.maudeInfixOperator() = "/=";
    eq AndBoolExp.maudeInfixOperator() = "&&";
    eq OrBoolExp.maudeInfixOperator() = "||";
    eq LTExp.maudeInfixOperator() = "<";
    eq GTExp.maudeInfixOperator() = ">";
    eq LTEQExp.maudeInfixOperator() = "<=";
    eq GTEQExp.maudeInfixOperator() = ">=";
    eq AddAddExp.maudeInfixOperator() = "+";
    eq SubAddExp.maudeInfixOperator() = "-";
    eq MultMultExp.maudeInfixOperator() = "*";
    eq DivMultExp.maudeInfixOperator() = "/";
    eq ModMultExp.maudeInfixOperator() = "%";
    public void Binary.generateMaude(java.io.PrintStream stream) {
        stream.print("\"" + maudeInfixOperator() + "\"( ");
        getLeft().generateMaude(stream);
        stream.print(":: ");
        getRight().generateMaude(stream);
        stream.print(") ");
    }

    public void ThisExp.generateMaude(java.io.PrintStream stream) {
        stream.print("@ \"this\" ");
    }

    public void NullExp.generateMaude(java.io.PrintStream stream) {
        stream.print("null ");
    }

    public void DataConstructorExp.generateMaude(java.io.PrintStream stream) {
        boolean inlist = false;
        stream.print("\"" + getConstructor() + "\"[ ");
        if (getNumParam() == 0) {
            stream.print("emp ");
        } else {
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
        }
        stream.print("] ");
    }

	public void VarUse.generateMaude(java.io.PrintStream stream) {
        if (isFunctionParameter()) {
            stream.print(getName() + ":Data ");
        } else {
            stream.print("@ \"" + getName() + "\" ");
        }
	}

	public void FieldUse.generateMaude(java.io.PrintStream stream) {
        stream.print("\"this\" @ \"" + getName() + "\" ");
	}

    public void FunVar.generateMaude(java.io.PrintStream stream) {
        stream.print(getName() + ":Data ");
    }

    public void FnApp.generateMaude(java.io.PrintStream stream) {
        boolean inlist = false;
        stream.print("\"" + getName() + "\"( ");
        for (PureExp param : getParams()) {
            if (inlist) stream.print(":: "); else inlist = true;
            param.generateMaude(stream);
        }
        stream.print(") ");
    }

    public void LetExp.generateMaude(java.io.PrintStream stream) {
        boolean inlist = false;
        stream.print("let @ \"" + getVar().getName() + "\" = ");
        getVal().generateMaude(stream);
        stream.print("in ");
        getExp().generateMaude(stream);
    }

	public void CaseExp.generateMaude(java.io.PrintStream stream) {
        boolean inlist = false;
		stream.print("case " );
		getExpr().generateMaude(stream);
		stream.print("of { ");
		for (CaseBranch branch : getBranchess()) {
            if (inlist) stream.print("; "); else inlist = true;
			branch.generateMaude(stream);
		}
		stream.print("} ");
	}
	
	public void CaseBranch.generateMaude(java.io.PrintStream stream) {
		getLeft().generateMaude(stream);
        stream.print("=> ");
        getRight().generateMaude(stream);
	}
	
	abstract public void Pattern.generateMaude(java.io.PrintStream stream);

    public void UnderscorePattern.generateMaude(java.io.PrintStream stream) {
        stream.print("@ \"_\" ");
    }

    public void PatternVar.generateMaude(java.io.PrintStream stream) {
        getVar().generateMaude(stream);
    }

    public void LiteralPattern.generateMaude(java.io.PrintStream stream) {
        getLiteral().generateMaude(stream);
    }

    public void ConstructorPattern.generateMaude(java.io.PrintStream stream) {
        boolean inlist = false;
        stream.print("\"" + getConstructor() + "\"[ ");
        for (Pattern pattern : getParamList()) {
            if (inlist) stream.print(":: "); else inlist = true;
            pattern.generateMaude(stream);
        }
        stream.print("] ");
    }

	public void UnknownDecl.generateMaude(java.io.PrintStream stream) {
		stream.println("--- Unknown declaration " + getName());
	}

    public void ClassDecl.generateMaude(java.io.PrintStream stream) {
        boolean inlist = false;
		stream.println("\n\n< \"" + getName() + "\" : Class |");
        stream.print("  Param: ");
        if (getNumParam() == 0) {
            stream.print("noVid");
        } else {
            stream.print("(");
            for (ParamDecl param : getParams()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + param.getName() + "\"");
            }
            stream.print(")");
        }
        stream.print(",\n  Att: ");
        if (getNumField() == 0) {
            stream.print("noSubst");
        } else {
            inlist = false;
            for (FieldDecl field : getFields()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + field.getName() + "\" |-> null ");
            }
        }
        stream.print(",\n  Mtds: ");
        // KLUDGE (rs 2010-06-15): this should be a general tree
        // rewriting rule, not a tree mutation while generating source
        // code.
        if (hasInitBlock()) {
            addMethod(new Method(".init", new DataTypeUse("Void"),
                                 new List<ParamDecl>(), getInitBlock().copy()));
        } else {
            addMethod(new Method(".init", new DataTypeUse("Void"),
                                 new List<ParamDecl>(), new Block()));
        }
        inlist = false;
        for (Method method : getMethods()) {
            if (inlist) stream.print(",\n    "); else inlist = true;
            method.generateMaude(stream);
        }
        stream.print(",\n  Ocnt: 0 > ");
	}
	
    public void Method.generateMaude(java.io.PrintStream stream) {
        boolean inlist = false;
        boolean amInitMethod = getName().equals(".init");
        boolean amRunMethod = getName().equals("run");
        stream.print("< \"" + getName() + "\" : Method | Param: ");
        if (getNumParam() == 0) {
            stream.print("noVid");
        } else {
            stream.print("(");
            for (ParamDecl param : getParams()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + param.getName() + "\"");
            }
            stream.print(")");
        }
        stream.print(", Att: ");
        if (getBlock().getNumField() == 0) {
            stream.print("noSubst");
        } else {
            inlist = false;
            for (VarDecl var : getBlock().getFields()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + var.getName() + "\" |-> null ");
            }
        }
        stream.print(",\n      Code: ");
        if (getBlock().getNumStmt() == 0) {
            if (amInitMethod) stream.print("noStmt ");
            else stream.print("return( null ) ");
        } else {
            inlist = false;
            for (Stmt stmt : getBlock().getStmts()) {
                if (inlist) stream.print("; "); else inlist = true;
                stmt.generateMaude(stream);
            }
            // KLUDGE (rs 2010-06-15): Emit this for "Void" methods for
            // now, since we don't have an empty `return' statement
            // currently.  Ideally we should flow-analyze where to
            // insert a dummy return statement for Void methods, and
            // give warnings about control paths not returning values
            // otherwise.
            Access returnType = getReturnType();
            if (returnType instanceof DataTypeUse
                && ((DataTypeUse)returnType).getName().equals("Void")
                // the run method has no place to return anything to
                && !amRunMethod && !amInitMethod)
            {
                stream.print("; return( null ) ");
            }
        }
        if (amInitMethod && inActiveClass()) {
            stream.print("; selftailcall (\"run\" ; emp) ");
        }
        stream.print("> ");
    }

    abstract public void Stmt.generateMaude(java.io.PrintStream stream);

    public void SkipStmt.generateMaude(java.io.PrintStream stream) {
        stream.print("skip ");
    }

    public void EmptyStmt.generateMaude(java.io.PrintStream stream) {
        stream.print("noStmt ");
    }


    public void AssignStmt.generateMaude(java.io.PrintStream stream) {
        if (getValue() instanceof PureExp) {
            stream.print("assign( @ \"" + getVar().getName() + "\" ; ");
            getValue().generateMaude(stream);
            stream.print(") ");
        } else {
            getValue().generateMaudeAsStatement(stream, getVar().getName());
        }
    }

    public void ReturnStmt.generateMaude(java.io.PrintStream stream) {
        if (getRetExp() instanceof PureExp) {
            stream.print("return( ");
            getRetExp().generateMaude(stream);
            stream.print(") ");
        } else {
            getRetExp().generateMaudeAsStatement(stream, "_");
            stream.print("; return(@ \"_\") " );
        }
    }

    abstract public void Guard.generateMaude(java.io.PrintStream stream);

    public void ClaimGuard.generateMaude(java.io.PrintStream stream) {
        stream.print("?(");
        getVar().generateMaude(stream);
        stream.print(") ");
    }

    public void AndGuard.generateMaude(java.io.PrintStream stream) {
        stream.print("\"&&\"(");
        getLeft().generateMaude(stream);
        stream.print(":: ");
        getRight().generateMaude(stream);
        stream.print(") ");
    }

    public void ExpGuard.generateMaude(java.io.PrintStream stream) {
        getPureExp().generateMaude(stream);
    }

    public void SuspendStmt.generateMaude(java.io.PrintStream stream) {
        stream.print("release ");
    }

    public void AwaitStmt.generateMaude(java.io.PrintStream stream) {
        stream.print("await ");
        getGuard().generateMaude(stream);
    }

    public void IfStmt.generateMaude(java.io.PrintStream stream) {
        stream.print("if ");
        getCondition().generateMaude(stream);
        stream.print("th ");
        getThen().generateMaude(stream);
        stream.print("el ");
        if (hasElse()) {
            getElse().generateMaude(stream);
        } else {
            stream.print("noStmt ");
        }
        stream.print("fi ");
    }

    public void ExpressionStmt.generateMaude(java.io.PrintStream stream) {
        getExp().generateMaudeAsStatement(stream, "_");
    }

    public void WhileStmt.generateMaude(java.io.PrintStream stream) {
        stream.print("while ");
        getCondition().generateMaude(stream);
        stream.print("do ");
        getBody().generateMaude(stream);
        stream.print("od ");
    }

	public void Block.generateMaude(java.io.PrintStream stream) {
        boolean inlist = false;
        if (getNumField() > 0) {
            stream.print("$push ( ");
            inlist = false;
            for (VarDecl field : getFields()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + field.getName() + "\" |-> null ");
            }
            stream.print(") ");
            inlist = true;      // set up for rest of the statements
        }
        if (getNumStmt() == 0 && getNumField() == 0) {
            stream.print("noStmt ");
        } else {
            for (Stmt stmt : getStmts()) {
                if (inlist) stream.print("; "); else inlist = true;
                stmt.generateMaude(stream);
            }
        }
        if (getNumField() > 0) {
            stream.print("; $pop ");
        }
	}

}
