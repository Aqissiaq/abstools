//$Id$ 
//
 

Model                         ::= Decl* [Block];

// (see below for Blocks)

// A ClassBlock is the body of a Class. 
ClassBlock			::= [InitBlock:Block] Field:VarDecl* Method:Method*;

abstract 				Decl ::= <Name>;
abstract BehaviorDecl:	Decl; // Entities used in behavior expressions
abstract TypeDecl:		Decl; // Entities used in type expressions

UnknownDecl:	Decl;			// Unknown declarations
ClassDecl:		BehaviorDecl	::= Param:ParamDecl* ImplementedInterfaceUse:InterfaceTypeUse* Body:ClassBlock;
InterfaceDecl:	TypeDecl		::= ExtendedInterfaceUse:InterfaceTypeUse* Body:MethodSig*;
DataTypeDecl:	TypeDecl		::= DataConstructor* ;
FunctionDecl:	Decl		    ::= TypeUse Param:VarOrFieldDecl* FunDef:PureExp ;
TypeSynDecl:    Decl            ::= <Value> ; 


abstract	VarOrFieldDecl  ::= <Name> Access; 
VarDecl:	VarOrFieldDecl; 
ParamDecl:	VarOrFieldDecl;

Method  ::= MethodSig Block;

MethodSig	::= <Name> ReturnType:Access Param:ParamDecl*;

// Uses of various identifiers
abstract Access:		PureExp;
abstract IdUse:			Access	::= <Name>;
abstract TypeUse:		IdUse;
InterfaceTypeUse:		TypeUse; // TODO: reconsider hierarchy of expressions?
DataTypeUse:			TypeUse;
abstract VarOrFieldUse: IdUse;
VarUse:					VarOrFieldUse;
FieldUse:				VarOrFieldUse;        // this.f            
UnresolvedTypeUse:		TypeUse;	// A type expression whose type cannot be resolved at parse time.
									// Will be  resolved by rewriting.   TODO: needed? 
FutureTypeUse:			Access ::= Access ;  // A future doesn't have a name as such


/*
Constructors occur as 
- DataConstructors as in data declarations Co(_D_)
- term consctructors as in Co(_t_)
- patterns as in Co(_p_)
- Don't know yet how to organise these.   
*/

abstract Constructor ::= <Name>; 
DataConstructor : Constructor ::= ConstructorArg:DataTypeUse* ;


abstract Stmt; 
abstract InitStmt:		Stmt;   //FIXME not all statements can be init statements, i.e. occur in an init block

AssignStmt: Stmt		::= Var:VarOrFieldUse Value:Exp;
AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
SuspendStmt: Stmt;
ReturnStmt: Stmt		::= RetExp:Exp; 
ExpressionStmt: Stmt	::= Exp:Exp; 

IfStmt: Stmt			::= Condition:PureExp Then:Stmt [Else:Stmt];
WhileStmt: Stmt			::= Condition:PureExp Body:Stmt;
EmptyStmt: Stmt;
// A Block is the body of programs and methods and is also used for initblocks
// It contains a list of zero or more ast.VarOrFieldDecl 
// and zero or more ast.Stmt, these are named Fields and Stmts resp.  
Block: Stmt				::= Field:VarDecl*  Stmt:Stmt*;



abstract Guard;
ClaimGuard: Guard		::= Var:VarOrFieldUse;
AndGuard: Guard			::= Left:Guard Right:Guard;
//For boolean guards   
ExpGuard: Guard			::= PureExp ; 


// Expressions 
abstract Exp;
// Pure expressions
abstract PureExp: Exp;
// Expressions with side effect. 
abstract EffExp: Exp;

// Side effect free expressions 
NullExp: PureExp;
ThisExp: PureExp;
// plus *Use-s

abstract LiteralExp: PureExp;
// For now the literal just contain a variable Content of type String. 
StringLiteral: LiteralExp  ::= <Content> ;
IntLiteral: LiteralExp ::= <Content>;        
BoolLiteral: LiteralExp ::= <Content>;        

// Functional expression 
abstract FunVal  : PureExp ; 

FunVar : FunVal ::= <Name> ; //Name = Variable name 
DataConstructorExp : FunVal  ::= <Constructor> Param:PureExp* ;
//TermPair : FunVal ::= Left:PureExp Right:PureExp ;

LetExp  : PureExp ::= Var:VarOrFieldDecl Val:PureExp Exp:PureExp ; 
FnApp  : PureExp ::= <Name> Param:PureExp* ;
CaseExp  : PureExp ::= Expr:PureExp Branches:CaseBranch* ;
CaseBranch ::= Left:Pattern Right:PureExp ; 


//Patterns 
abstract Pattern ; 

PatternVar:			Pattern ::= Var:VarOrFieldUse; 
ConstructorPattern: Pattern ::= <Constructor> Param:Pattern*;
LiteralPattern:		Pattern ::= Literal:LiteralExp;
//PatternPair:		Pattern ::= Left:Pattern Right:Pattern;
UnderscorePattern:	Pattern; 



// Expressions with side effects. 
NewExp: EffExp			::= <ClassRef> Param:PureExp* <Cog> ; //todo, optional cog 
abstract Call: EffExp 	::= <Method> Param:PureExp*;
SyncCall: Call			::= Callee:PureExp;
AsyncCall: Call			::= Callee:PureExp;
GetExp: EffExp			::= PureExp;


abstract Unary : PureExp ::= Operand:PureExp;

abstract Binary : PureExp ::= Left:PureExp Right:PureExp; 


//Integers
MinusExp : Unary ;  

abstract ArithmeticExp : Binary ; 

abstract MultExp :  ArithmeticExp ;   
MultMultExp  : MultExp ;
DivMultExp  : MultExp ;
ModMultExp : MultExp ;

abstract AddExp :  ArithmeticExp ;
AddAddExp  : AddExp ;
SubAddExp : AddExp ;

//Booleans 
NegExp: Unary ; 

abstract BoolExp : Binary ; 
AndBoolExp : BoolExp ; 
OrBoolExp : BoolExp ; 

//Relations
abstract RelationalExpr : Binary;
LTExp : RelationalExpr ;
GTExp : RelationalExpr ;
LTEQExp : RelationalExpr ;
GTEQExp : RelationalExpr ;

abstract EqualityExpr : RelationalExpr;
EqExp : EqualityExpr ;
NotEqExp : EqualityExpr ;



/*
// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;
*/