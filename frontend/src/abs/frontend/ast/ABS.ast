// TODO: 
// When we get round to it:
// 1. An instance of this AST will be generated by the parser 
//    (probably using a staightforward Antlr tree grammar)
// 2. The concrete AST will be simplified and augmented using equations
// 3. Type analysis (and what other analyses?) will be performed on the AST
// 4. Generate VM code (in the form of a Maude program) from the AST

// Remarks:
// Liberalisation's wrt. EBJ's grammar in the formal spec. of ABS (abs.tex):
// - Allow interfaces and classes in any order
// - In blocks, allow declarations and statements in any order
// 

Program ::= IntOrClassDecl* Block;
// TODO: add this too?: /Predefined:InterfaceOrClassDecl*/;

abstract 	IntOrClassDecl	::= <Name:String>; // TODO: simplify to <Name>
ClassDecl:	IntOrClassDecl	::= Implements:IdUse* Body:ClassBlock;
IntDecl:	IntOrClassDecl	::= Body:Signature*;

ClassBlock			::= Fields:VarOrParamDecl* Methods:Method*;

Method				::= Signature Block;

Signature			::= <ReturnType:String> <Name:String> Params:VarOrParamDecl*;

Block				::= BlockStmt*;

// A `BlockStmt' is either a variable declaration or a regular statement
abstract BlockStmt;
VarOrParamDecl:	BlockStmt	::= <Name:String> Type:TypeAccess;
abstract Stmt:	BlockStmt;

AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
IfStmt: Stmt			::= Condition:PureExp IfPart:Stmt* ElsePart:Stmt*;
WhileStmt: Stmt			::= Condition:PureExp Body:Stmt*;
ReleaseStmt: Stmt;
AssignStmt: Stmt		::= <Variable:String> Value:Exp;

// TODO: assume that parsing guarantees that `Stmt*' is never empty?

abstract Guard;
Put: Guard			::= <Variable:String>;
And: Guard			::= Left:Guard right:Guard;

abstract Exp;
abstract PureExp: Exp;
abstract ImpureExp: Exp;

VarRef: PureExp			::= <VarRef:String>;
GetExp: PureExp			::= PureExp;
NullExpr: PureExp;
Bool: PureExp;

NewExp: ImpureExp		::= <ClassRef:String>;
abstract MethCall: ImpureExp 	::= <Method:String> Params:PureExp*;
LocalSyncMethCall: MethCall;
NonlocalSyncMethCall: MethCall	::= <Callee:String>;
AsyncMethCall: MethCall		::= Callee:Exp;

// TODO: unfinished
abstract TypeAccess;
abstract IdUse:	TypeAccess ::= <Name:String>;
Future: TypeAccess;

// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;
