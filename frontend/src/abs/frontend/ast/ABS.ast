//$Id$ 
//
// Remarks:
// Liberalisation's wrt. EBJ's grammar in the formal spec. of ABS (abs.tex):
// - Allow interfaces and classes in any order
// - In blocks, allow declarations and statements in any order
// 

Program                         ::= Decl* Block;

// A Block is the body of programs and methods. 
// It contains a list of zero or more ast.VarOrFieldDecl and one ast.StmtRet, 
// these are named Fields and Stmts resp.  
Block				::= Fields:VarOrFieldDecl*  Stmts:StmtRet;

DeclBlock			::= Fields:VarOrFieldDecl*  Methods:Method*;


// TODO: add this too?: /Predefined:InterfaceOrClassDecl*/;

abstract Decl	::= <Name>;
abstract BehaviorDecl:	Decl; // Entities used in behavior expressions
abstract TypeDecl:			Decl; // Entities used in type expressions


//abstract 	TypeDecl	::= <Name:String>; // TODO: simplify to <Name>
ClassDecl:	BehaviorDecl	::= Implements:IdUse* Body:DeclBlock; // TODO: make implements optional
InterfaceDecl:	TypeDecl	::= Extends:IdUse* Body:MethodSig*;


VarOrFieldDecl:	TypeDecl	::= Type:TypeAccess; //<Name:String> for the name of the variable or field is inherited from TypeDecl and 
                                                     //IdUse is a subclass of TypeAccess, parsing (cf. ABS.parser) returns an instance of IdUse. 

Method				::= MethodSig Block;

//MethodSig                      ::= <ReturnType:String> <Name:String> Params:VarOrParamDecl*;
MethodSig : TypeDecl 		::= ReturnType:TypeAccess Params:VarOrFieldDecl*; //<Name:String> (for the name) inherited from TypeDecl.
                                                                                  //IdUse (for the type)  

abstract TypeAccess ::= <ID:String>;
IdUse:	TypeAccess; 
Future: TypeAccess;


StmtRet                         ::= Stmts:Stmt* RetExp:PureExp; 

abstract Stmt; 

AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
IfStmt: Stmt			::= Condition:PureExp Then:Stmt [Else:Stmt];
//WhileStmt: Stmt			::= Condition:PureExp Body:Stmt*;
ReleaseStmt: Stmt;
AssignStmt: Stmt		::= Var:VarRef Value:Exp;
StmtBlock : Stmt        ::= Stmts:Stmt* ;


abstract Guard;
ClaimGuard: Guard			::= Var:VarRef ;
AndGuard: Guard			::= Left:Guard Right:Guard;
//No boolguards yet 
//BoolGuard: Guard           ::= BoolExp ; 

abstract Exp;
abstract PureExp: Exp;
abstract EffExp: Exp;

// Side effect free expressions 
VarRef: PureExp			::= <VarName:String>;
GetExp: PureExp			::= PureExp;
NullExp: PureExp ;
BoolExp: PureExp ; 
BoolLiteral: BoolExp   ::= <Value:String>;        
BoolExpNeg: BoolExp ::= PureExp ; 
BoolExpAnd: BoolExp ::= e1:PureExp e2:PureExp ; 
BoolExpOr: BoolExp ::= e1:PureExp e2:PureExp ; 
BoolExpComp: BoolExp ::= e1:PureExp e2:PureExp ; 


// Expressions with side effects. 
NewExp: EffExp		        ::= <ClassRef:String>;
abstract Call: EffExp 	::= <Method:String> Params:PureExp*;
LocalSyncCall: Call;
SyncCall: Call	    ::= Callee:PureExp;
AsyncCall: Call		::= Callee:PureExp;




// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;


