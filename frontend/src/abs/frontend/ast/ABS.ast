// TODO: 
// When we get round to it:
// 1. An instance of this AST will be generated by the parser 
//    (probably using a staightforward Antlr tree grammar)
// 2. The concrete AST will be simplified and augmented using equations
// 3. Type analysis (and what other analyses?) will be performed on the AST
// 4. Generate VM code (in the form of a Maude program) from the AST

// Remarks:
// Liberalisation's wrt. EBJ's grammar in the formal spec. of ABS (abs.tex):
// - Allow interfaces and classes in any order
// - In blocks, allow declarations and statements in any order
// 

Program ::= InterfaceOrClassDecl* Block;
// TODO: add this too?: /Predefined:InterfaceOrClassDecl*/;

abstract 	IntOrClassDecl	::= <Name:String>; // TODO: simplify to <Name>
ClassDecl:	IntOrClassDecl	::= Implements:[IdUse] Body:ClassBlock;
IntDecl:	IntOrClassDecl	::= Body:[Signature];

Block				::= BlockStmt*;

ClassBlock			::= Fields:[VarDecl] Methods;
Methods				::= 

// A `BlockStmt' is either a variable declaration or a regular statement
abstract BlockStmt;
VarDecl:	BlockStmt	::= <Name:String> Type:TypeAccess;
abstract Stmt:	BlockStmt;

AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
IfStmt: Stmt			::= Condition:PureExp IfPart:PureStmts ElsePart:PureStmts;
WhileStmt: Stmt			::= Condition:PureExp Body:PureStmts;
ReleaseStmt: Stmt;
AssignStmt: Stmt		::= <Variable:String> Value:Exp;

// `PureStmts' is a non-empty sequence of regular statements (no var. decls.)
abstract PureBlockStmt		::= Stmt+;

abstract Guard;
Put: Guard			::= <Variable:String>;
And: Guard			::= Guard Guard;

abstract Exp;
abstract PureExp: Exp;
abstract ImpureExp: Exp;

VarRef: PureExp			::= <VarRef:String>;
GetExp: PureExp			::= PureExp;
NullExpr: PureExp;
Bool: PureExp;

NewExp: ImpureExp		::= <ClassRef:String>;
abstract MethCall: ImpureExp 	::= <Method:String> Params:[PureExp];
LocalSyncMethCall: MethCall;
NonlocalSyncMethCall: MethCall	::= <Callee:String>;
AsyncMethCall: MethCall		::= Callee:Exp;

// TODO: unfinished
abstract TypeAccess;
abstract IdUse:	TypeAccess ::= <Name:String>;
Future: TypeAccess;

// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;
