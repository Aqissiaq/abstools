//$Id$ 
//
 

Model                         ::= Decl* [Block];

// (see below for Blocks)

abstract 				Decl ::= <Name>;
abstract BehaviorDecl:	Decl; // Entities used in behavior expressions
abstract TypeDecl:		Decl; // Entities used in type expressions

UnknownDecl:	TypeDecl;		// Unknown declarations
ClassDecl:		BehaviorDecl	::= Param:ParamDecl* ImplementedInterfaceUse:InterfaceTypeUse* [InitBlock] Field:FieldDecl* Method:MethodImpl*;
FunctionDecl:	BehaviorDecl    ::= TypeUse Param:ParamDecl* FunDef:PureExp ;
ParametricFunctionDecl : FunctionDecl ::= TypeParameter:TypeParameterDecl* ;
InterfaceDecl:	TypeDecl		::= ExtendedInterfaceUse:InterfaceTypeUse* Body:MethodSig*;
DataTypeDecl:	TypeDecl		::= DataConstructor* ;
TypeParameterDecl	: TypeDecl 	::= <Name>;  // local declaration
ParametricDataTypeDecl : DataTypeDecl ::= TypeParameter:TypeParameterDecl* ;
TypeSynDecl:    TypeDecl        ::= Value:DataTypeUse ; 


abstract	VarOrFieldDecl  ::= <Name>;
abstract TypedVarOrFieldDecl : VarOrFieldDecl ::= Access; 
VarDecl:	TypedVarOrFieldDecl  ::= [InitExp:PureExp];
FieldDecl:	TypedVarOrFieldDecl ::= [InitExp:PureExp];
ParamDecl:	TypedVarOrFieldDecl;
PatternVarDecl: VarOrFieldDecl;


MethodSig	::= <Name> ReturnType:Access Param:ParamDecl*;
MethodImpl  ::= MethodSig Block;


// Uses of various identifiers
abstract Access:		PureExp;
abstract IdUse:			Access	::= <Name>;
abstract TypeUse:		IdUse;
InterfaceTypeUse:		TypeUse; // TODO: reconsider hierarchy of expressions?
DataTypeUse:			TypeUse;
ParametricDataTypeUse:  DataTypeUse ::= Param:DataTypeUse* ; // FIXME: should be TypeParameterUse - fix in ABS.parser as well
TypeParameterUse:		TypeUse;
abstract VarOrFieldUse: IdUse;
VarUse:					VarOrFieldUse;
FieldUse:				VarOrFieldUse;        // this.f

UnresolvedTypeUse:		TypeUse;	// A type expression whose type cannot be resolved at parse time.
									// Will be  resolved by rewriting.   TODO: needed? 


/*
Constructors occur as 
- DataConstructors as in data declarations Co(_D_)
- term consctructors as in Co(_t_)
- patterns as in Co(_p_)
- Don't know yet how to organise these.   
*/

abstract Constructor ::= <Name>; 
DataConstructor : Constructor ::= ConstructorArg:DataTypeUse* ;


abstract Stmt; 
abstract InitStmt:		Stmt;   //FIXME not all statements can be init statements, i.e. occur in an init block

AssignStmt: Stmt		::= Var:VarOrFieldUse Value:Exp;
AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
SuspendStmt: Stmt;
ReturnStmt: Stmt		::= RetExp:Exp; 
ExpressionStmt: Stmt	::= Exp:Exp; 

IfStmt: Stmt			::= Condition:PureExp Then:Stmt [Else:Stmt];
WhileStmt: Stmt			::= Condition:PureExp Body:Stmt;
// A Block is the body of programs and methods and is also used for initblocks
// It contains a list of zero or more ast.VarOrFieldDecl 
// and zero or more ast.Stmt, these are named Fields and Stmts resp.  
Block: Stmt				::= Var:VarDecl*  Stmt:Stmt*;
InitBlock: Block;		// Initializer block in a class - can be handled specially during code generation


abstract Guard;
ClaimGuard: Guard		::= Var:VarOrFieldUse;
AndGuard: Guard			::= Left:Guard Right:Guard;
//For boolean guards   
ExpGuard: Guard			::= PureExp ; 


// Expressions 
abstract Exp;
// Pure expressions
abstract PureExp: Exp;
// Expressions with side effect. 
abstract EffExp: Exp;

// Side effect free expressions 
NullExp: PureExp;
ThisExp: PureExp;
// plus *Use-s

abstract LiteralExp: PureExp;
// For now the literal just contain a variable Content of type String. 
StringLiteral: LiteralExp  ::= <Content> ;
IntLiteral: LiteralExp ::= <Content>;        

// Functional expression 
abstract FunVal  : PureExp ; 

FunVar : FunVal ::= <Name> ; //Name = Variable name 
DataConstructorExp : FunVal  ::= <Constructor> Param:PureExp* ;
//TermPair : FunVal ::= Left:PureExp Right:PureExp ;

LetExp  : PureExp ::= Var:ParamDecl Val:PureExp Exp:PureExp ; 
FnApp  : PureExp ::= <Name> Param:PureExp* ;
CaseExp  : PureExp ::= Expr:PureExp Branch:CaseBranch* ;
CaseBranch ::= Left:Pattern Right:PureExp ; 


//Patterns 
abstract Pattern ; 

PatternVar:			Pattern ::= Var:PatternVarDecl; 
ConstructorPattern: Pattern ::= <Constructor> Param:Pattern*;
LiteralPattern:		Pattern ::= Literal:LiteralExp;
//PatternPair:		Pattern ::= Left:Pattern Right:Pattern;
UnderscorePattern:	Pattern; 



// Expressions with side effects. 
NewExp: EffExp			::= <ClassRef> Param:PureExp* <Cog> ; //todo, optional cog 
abstract Call: EffExp 	::= <Method> Param:PureExp*;
SyncCall: Call			::= Callee:PureExp;
AsyncCall: Call			::= Callee:PureExp;
GetExp: EffExp			::= PureExp;


abstract Unary : PureExp ::= Operand:PureExp;

abstract Binary : PureExp ::= Left:PureExp Right:PureExp; 


//Integers
MinusExp : Unary ;  

abstract ArithmeticExp : Binary ; 

abstract MultExp :  ArithmeticExp ;   
MultMultExp  : MultExp ;
DivMultExp  : MultExp ;
ModMultExp : MultExp ;

abstract AddExp :  ArithmeticExp ;
AddAddExp  : AddExp ;
SubAddExp : AddExp ;

//Booleans 
NegExp: Unary ; 

abstract BoolExp : Binary ; 
AndBoolExp : BoolExp ; 
OrBoolExp : BoolExp ; 

//Relations
abstract RelationalExpr : Binary;
LTExp : RelationalExpr ;
GTExp : RelationalExpr ;
LTEQExp : RelationalExpr ;
GTEQExp : RelationalExpr ;

abstract EqualityExpr : RelationalExpr;
EqExp : EqualityExpr ;
NotEqExp : EqualityExpr ;


/*
// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;
*/