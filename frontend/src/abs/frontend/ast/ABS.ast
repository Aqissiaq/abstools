//$Id$ 
//
 
// needed for lists of strings
Name ::= <Name>;

Model                         ::= CompilationUnit*;
 
CompilationUnit ::= <Name> ModuleDecl* ;
ModuleDecl ::= <Name> Export* Import* Decl* [ProductLine] [Block:MainBlock] ;

abstract Import;
NamedImport : Import ::= Name* ;
StarImport : Import ::= <ModuleName>;
FromImport : Import ::= Name* <ModuleName>;

abstract Export;
NamedExport: Export ::= Name* ;
StarExport: Export ::= [ModuleName:Name];
FromExport: Export ::= Name* <ModuleName>;
// (see below for Blocks)

abstract 				Decl ::= <Name>;
abstract BehaviorDecl:	Decl ::= ; // Entities used in behavior expressions
abstract TypeDecl:		Decl; // Entities used in type expressions

UnknownDecl:    TypeDecl;		// Unknown declarations
ClassDecl:      BehaviorDecl	::=  Annotation* Param:ParamDecl* ImplementedInterfaceUse:InterfaceTypeUse* [InitBlock] Field:FieldDecl* Method:MethodImpl*;
DeltaDecl:      Decl    ::= Annotation* Modifier:ClassModifier*;
FunctionDecl:	BehaviorDecl    ::=  Annotation* TypeUse Param:ParamDecl* FunctionDef ;
DataConstructor : BehaviorDecl ::= <Name> ConstructorArg:DataTypeUse* ;
ParametricFunctionDecl : FunctionDecl ::=  Annotation* TypeParameter:TypeParameterDecl* ;
InterfaceDecl:	TypeDecl		::=  Annotation* ExtendedInterfaceUse:InterfaceTypeUse* Body:MethodSig*;
DataTypeDecl:	TypeDecl		::=  Annotation* DataConstructor* ;
TypeParameterDecl	: TypeDecl 	::= <Name>;  // local declaration
ParametricDataTypeDecl : DataTypeDecl ::=  Annotation* TypeParameter:TypeParameterDecl* ;
TypeSynDecl:    TypeDecl        ::=  Annotation* Value:DataTypeUse ; 


ClassModifier  ::= <Name> ModifierFragment* ;

abstract ModifierFragment ;

AddMethodModifier : ModifierFragment ::= MethodImpl;
ModifyMethodModifier : ModifierFragment ::= MethodImpl;
RemoveMethodModifier : ModifierFragment ::= MethodSig;


abstract	VarOrFieldDecl  ::= <Name>;
abstract TypedVarOrFieldDecl : VarOrFieldDecl ::= Access; 
VarDecl:	TypedVarOrFieldDecl  ::= [InitExp:Exp];
FieldDecl:	TypedVarOrFieldDecl ::= [InitExp:PureExp];
ParamDecl:	TypedVarOrFieldDecl;
PatternVarDecl: VarOrFieldDecl;

abstract FunctionDef;
BuiltinFunctionDef: FunctionDef;
ExpFunctionDef: FunctionDef ::= Rhs:PureExp;

MethodSig	::= <Name> Annotation* ReturnType:Access Param:ParamDecl*;
MethodImpl  ::= MethodSig Block;


// Uses of various identifiers
abstract Access:		PureExp;
abstract IdUse:			Access	::= <Name>;
abstract TypeUse:		IdUse;
InterfaceTypeUse:		TypeUse; // TODO: reconsider hierarchy of expressions?
DataTypeUse:			TypeUse;
ParametricDataTypeUse:  DataTypeUse ::= Param:DataTypeUse* ; 
TypeParameterUse:		TypeUse;
abstract VarOrFieldUse: Access ::= <Name>;
VarUse:					VarOrFieldUse;
FieldUse:				VarOrFieldUse;        // this.f

UnresolvedTypeUse:		TypeUse;	// A type expression whose type cannot be resolved at parse time.
									// Will be  resolved by rewriting.   TODO: needed? 


/*
Constructors occur as 
- DataConstructors as in data declarations Co(_D_)
- term consctructors as in Co(_t_)
- patterns as in Co(_p_)
- Don't know yet how to organise these.   
*/

Annotation      ::= <Name> Value:PureExp;

abstract Stmt   ::= Annotation* ; 
abstract InitStmt:		Stmt;   //FIXME not all statements can be init statements, i.e. occur in an init block

AssignStmt: Stmt		::= Var:PureExp Value:Exp;
AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
SuspendStmt: Stmt;
ReturnStmt: Stmt		::= RetExp:Exp; 
ExpressionStmt: Stmt	::= Exp:Exp;
AssertStmt: Stmt        ::= Condition:PureExp;
VarDeclStmt: Stmt ::= VarDecl:VarDecl;

IfStmt: Stmt			::= Condition:PureExp Then:Stmt [Else:Stmt];
WhileStmt: Stmt			::= Condition:PureExp Body:Stmt;
// A Block is the body of programs and methods and is also used for initblocks
// It contains a list of zero or more ast.VarOrFieldDecl 
// and zero or more ast.Stmt, these are named Fields and Stmts resp.  
Block: Stmt				::= Stmt:Stmt*;
InitBlock: Block;		// Initializer block in a class - can be handled specially during code generation
MainBlock: Block;             // Active behavior of the model


abstract Guard;
ClaimGuard: Guard		::= Var:PureExp;
AndGuard: Guard			::= Left:Guard Right:Guard;
//For boolean guards   
ExpGuard: Guard			::= PureExp ; 


// Expressions 
abstract Exp;
// Pure expressions
abstract PureExp: Exp;
// Expressions with side effect. 
abstract EffExp: Exp;

// Side effect free expressions 
NullExp: PureExp;
ThisExp: PureExp;
// plus *Use-s

abstract LiteralExp: PureExp;
// For now the literal just contain a variable Content of type String. 
StringLiteral: LiteralExp  ::= <Content> ;
IntLiteral: LiteralExp ::= <Content>;        

DataConstructorExp : PureExp  ::= <Constructor> Param:PureExp* ;
LetExp  : PureExp ::= Var:ParamDecl Val:PureExp Exp:PureExp ; 
FnApp  : PureExp ::= <Name> Param:PureExp* ;
CaseExp  : PureExp ::= Expr:PureExp Branch:CaseBranch* ;
CaseBranch ::= Left:Pattern Right:PureExp ; 

//Patterns 
abstract Pattern ; 

PatternVarUse:    Pattern ::= <Name>;
PatternVar:			Pattern ::= Var:PatternVarDecl; 
ConstructorPattern: Pattern ::= <Constructor> Param:Pattern*;
LiteralPattern:		Pattern ::= Literal:LiteralExp;
//PatternPair:		Pattern ::= Left:Pattern Right:Pattern;
UnderscorePattern:	Pattern; 


// Expressions with side effects. 
NewExp: EffExp			::= <ClassName> Param:PureExp* <Cog> ; //todo, optional cog 
abstract Call: EffExp 	::= Callee:PureExp <Method> Param:PureExp*;
SyncCall: Call;
AsyncCall: Call;
GetExp: EffExp			::= PureExp;


abstract Unary : PureExp ::= Operand:PureExp;

abstract Binary : PureExp ::= Left:PureExp Right:PureExp; 


//Integers
MinusExp : Unary ;  

abstract ArithmeticExp : Binary ; 

abstract MultExp :  ArithmeticExp ;   
MultMultExp  : MultExp ;
DivMultExp  : MultExp ;
ModMultExp : MultExp ;

abstract AddExp :  ArithmeticExp ;
AddAddExp  : AddExp ;
SubAddExp : AddExp ;

//Booleans 
NegExp: Unary ; 

abstract BoolExp : Binary ; 
AndBoolExp : BoolExp ; 
OrBoolExp : BoolExp ; 

//Relations
abstract RelationalExpr : Binary;
LTExp : RelationalExpr ;
GTExp : RelationalExpr ;
LTEQExp : RelationalExpr ;
GTEQExp : RelationalExpr ;

abstract EqualityExpr : RelationalExpr;
EqExp : EqualityExpr ;
NotEqExp : EqualityExpr ;


ProductLine ::=
  <Name> OptionalFeature:Feature* CoreFeature:Feature* Deltacondition* ;

// The third argument (Feature*) is meant to be a conjunction of
// features that have to be present for the delta to be applied.  It will
// be replaced by a more expressive expression language later.
Deltacondition ::=
  Delta [RequiredDelta:Delta] Feature* ;

Feature ::= <Name> ;

Delta ::= <Name> ;
