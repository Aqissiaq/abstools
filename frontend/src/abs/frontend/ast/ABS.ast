//$Id$ 
//
 

Program                         ::= Decl* [Block];

// A Block is the body of programs and methods. 
// It contains a list of zero or more ast.VarOrFieldDecl 
// and zero or more ast.Stmt, these are named Fields and Stmts resp.  
// and an optional "main" Block 
Block				::= Fields:VarOrFieldDecl*  Stmts:Stmt*;

DeclBlock			::= InitBlock:InitStmt* Fields:VarOrFieldDecl*  Methods:Method*;


// TODO: add this too?: /Predefined:InterfaceOrClassDecl*/;

abstract 				Decl ::= <Name>;
abstract BehaviorDecl:	Decl; // Entities used in behavior expressions
abstract TypeDecl:		Decl; // Entities used in type expressions

UnknownDecl:	Decl;			// Unknown declarations
ClassDecl:		BehaviorDecl	::= Params:VarDecl* ImplementedInterfaceUse:IdUse* Body:DeclBlock;
InterfaceDecl:	TypeDecl		::= ExtendedInterfaceUse:IdUse* Body:MethodSig*;
DatatypeDecl:	TypeDecl		::= DataConstructors:DataConstructor* ;
	//IdUse is a subclass of TypeAccess, parsing (cf. ABS.parser) returns an instance of IdUse. 


VarOrFieldDecl	::= <Name> TypeExp; 
VarDecl : VarOrFieldDecl ; 
FieldDecl : VarOrFieldDecl ; 

Method						::= MethodSig Block;

MethodSig	::= <Name> ReturnType:TypeExp Params:VarOrFieldDecl*;

IdUse				::= <Name>;

abstract TypeExp ; 
abstract NamedTypeExp : TypeExp  ::= <Name> ; 
DataType:	NamedTypeExp ;
InterfaceType:	NamedTypeExp ;
UnresolvedType : NamedTypeExp ;     // A type expression whose type cannot be resolved at parse time.
										// Will be  resolved by rewriting. 
FutureType: TypeExp ::= TypeExp ;  // A future doesn't have a name as such


/*
Constructors occur as 
- DataConstructors as in data declarations Co(_D_)
- term consctructors as in Co(_t_)
- patterns as in Co(_p_)
- Don't know yet how to organise these.   
*/

abstract Constructor ; 
DataConstructor : Constructor ::= ConstructorArgs:DataType* ;


abstract Stmt; 
abstract InitStmt : Stmt ;   //FIXME not all statements can be init statements, i.e. occur in an init block

AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
IfStmt: Stmt			::= Condition:PureExp Then:Stmt [Else:Stmt];
//WhileStmt: Stmt			::= Condition:PureExp Body:Stmt*;
ReleaseStmt: Stmt;
AssignStmt: Stmt		::= Var:VarRef Value:Exp;
StmtBlock: Stmt			::= Stmt:Stmt*;
EmptyStmt: Stmt;
ReturnStmt: Stmt		::= RetExp:Exp; 
ExpressionStmt: Stmt	::= Exp:Exp; 


abstract Guard;
ClaimGuard: Guard		::= Var:VarRef;
AndGuard: Guard			::= Left:Guard Right:Guard;
//For boolean guards   
ExpGuard: Guard			::= PureExp ; 

abstract Exp;
abstract PureExp: Exp;
abstract EffExp: Exp;

// Side effect free expressions 
VarRef: PureExp			::= <VarName>;
GetExp: PureExp			::= PureExp;
NullExp: PureExp;
EqExp: PureExp   		::= Left:PureExp Right:PureExp ; 

// Expressions with side effects. 
NewExp: EffExp			::= <ClassRef> Param:PureExp*; 
abstract Call: EffExp 	::= <Method> Param:PureExp*;
LocalSyncCall: Call;
LocalAsyncCall: Call;
SyncCall: Call			::= Callee:PureExp;
AsyncCall: Call			::= Callee:PureExp;



/*
// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;
*/