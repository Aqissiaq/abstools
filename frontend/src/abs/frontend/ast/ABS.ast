//$Id$ 
//
 

Model                         ::= Decl* [Block];

// A Block is the body of programs and methods and is also used for initblocks
// It contains a list of zero or more ast.VarOrFieldDecl 
// and zero or more ast.Stmt, these are named Fields and Stmts resp.  
Block				::= Fields:VarDecl*  Stmts:Stmt*;

// A ClassBlock is the body of a Class. 
ClassBlock			::= [InitBlock:Block] Fields:VarDecl* Methods:Method*;
//ClassBlock			::= Fields:VarDecl*  Methods:Method*;
//ClassBlock              ::= [InitBlock:Block] Decls:ClassBlockDecl* ;                          

abstract 				Decl ::= <Name>;
abstract BehaviorDecl:	Decl; // Entities used in behavior expressions
abstract TypeDecl:		Decl; // Entities used in type expressions
//abstract ClassBlockDecl ; 

UnknownDecl:	Decl;			// Unknown declarations
ClassDecl:		BehaviorDecl	::= Params:ParamDecl* ImplementedInterfaceUse:IdUse* Body:ClassBlock;
InterfaceDecl:	TypeDecl		::= ExtendedInterfaceUse:IdUse* Body:MethodSig*;
DatatypeDecl:	TypeDecl		::= DataConstructors:DataConstructor* ;
FunctionDecl:	Decl		    ::= DataType:DataType Params:FunVarDecl* FunDef:PureExp ;

	//IdUse is a subclass of TypeAccess, parsing (cf. ABS.parser) returns an instance of IdUse. 


abstract  VarOrFieldDecl  ::= <Name> TypeExp; 

VarDecl : VarOrFieldDecl  ; 
ParamDecl : VarOrFieldDecl ;

FunVarDecl ::= <Name> DataType;   

Method  ::= MethodSig Block;

MethodSig	::= <Name> ReturnType:TypeExp Params:ParamDecl*;

IdUse				::= <Name>;

abstract TypeExp ; 
abstract NamedTypeExp : TypeExp  ::= <Name> ; 
DataType:	NamedTypeExp ;
InterfaceType:	NamedTypeExp ;
UnresolvedType : NamedTypeExp ;     // A type expression whose type cannot be resolved at parse time.
										// Will be  resolved by rewriting. 
FutureType: TypeExp ::= TypeExp ;  // A future doesn't have a name as such


/*
Constructors occur as 
- DataConstructors as in data declarations Co(_D_)
- term consctructors as in Co(_t_)
- patterns as in Co(_p_)
- Don't know yet how to organise these.   
*/

abstract Constructor ::= <Name>; 
DataConstructor : Constructor ::= ConstructorArgs:DataType* ;


abstract Stmt; 
abstract InitStmt : Stmt ;   //FIXME not all statements can be init statements, i.e. occur in an init block

AssignStmt: Stmt		::= Var:VarRef Value:Exp;
AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
SuspendStmt: Stmt;
ReturnStmt: Stmt		::= RetExp:Exp; 
ExpressionStmt: Stmt	::= Exp:Exp; 

IfStmt: Stmt			::= Condition:PureExp Then:Stmt [Else:Stmt];
WhileStmt: Stmt			::= Condition:PureExp Body:Stmt;
StmtBlock: Stmt			::= Stmt:Stmt*;
EmptyStmt: Stmt;




abstract Guard;
ClaimGuard: Guard		::= Var:VarRef;
AndGuard: Guard			::= Left:Guard Right:Guard;
//For boolean guards   
ExpGuard: Guard			::= PureExp ; 

//Expressions 
abstract Exp;
//Pure expressions
abstract PureExp: Exp;
//Expressions with side effect. 
abstract EffExp: Exp;

// Side effect free expressions 
abstract VarRef: PureExp    ::= <VarName> ;
LocalVarRef: VarRef ;
FieldRef: VarRef ;          //this.f            
NullExp: PureExp;
ThisExp: PureExp;

LiteralExp: PureExp;
//For now the literal just contain a variable Content of type String. 
StringLiteral: LiteralExp  ::= <Content> ;
IntLiteral: LiteralExp ::= <Content>;        
BoolLiteral: LiteralExp ::= <Content>;        

//FunctionalExpression 
abstract FunVal  : PureExp ; 
abstract Pattern ; 

PatVar : Pattern ::= <Name> ; 


FunVar : FunVal ::= <Name> ; //Name = Variable name 
DataConstructorExp : FunVal  ::= <Constructor> Params:PureExp* ;
TermPair : FunVal ::= Left:PureExp Right:PureExp ;

LetExp  : PureExp ::= Var:FunVarDecl Val:PureExp Exp:PureExp ; 
FnApp  : PureExp ::= <Name> Params:PureExp* ;
CaseExp  : PureExp ::= Expr:PureExp Branches:CaseBranch* ;
CaseBranch ::= Left:DataConstructorExp Right:PureExp ; 




// Expressions with side effects. 
NewExp: EffExp			::= <ClassRef> Param:PureExp*; //todo, optional cog 
abstract Call: EffExp 	::= <Method> Param:PureExp*;
SyncCall: Call			::= Callee:PureExp;
AsyncCall: Call			::= Callee:PureExp;
GetExp: EffExp			::= PureExp;


abstract Unary : PureExp ::= Operand:PureExp;

abstract Binary : PureExp ::= Left:PureExp Right:PureExp; 


//Integers
MinusExp : Unary ;  

abstract ArithmeticExp : Binary ; 

abstract MultExp :  ArithmeticExp ;   
MultMultExp  : MultExp ;
DivMultExp  : MultExp ;
ModMultExp : MultExp ;

abstract AddExp :  ArithmeticExp ;
AddAddExp  : AddExp ;
SubAddExp : AddExp ;

//Booleans 
NegExp: Unary ; 

abstract BoolExp : Binary ; 
AndBoolExp : BoolExp ; 
OrBoolExp : BoolExp ; 

//Relations
abstract RelationalExpr : Binary;
LTExp : RelationalExpr ;
GTExp : RelationalExpr ;
LTEQExp : RelationalExpr ;
GTEQExp : RelationalExpr ;

abstract EqualityExpr : RelationalExpr;
EqExp : EqualityExpr ;
NotEqExp : EqualityExpr ;















/*
// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;
*/