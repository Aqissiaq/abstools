//$Id$ 
// TODO: 
// When we get round to it:
// 1. An instance of this AST will be generated by the parser 
//    (probably using a staightforward Antlr tree grammar)
// 2. The concrete AST will be simplified and augmented using equations
// 3. Type analysis (and what other analyses?) will be performed on the AST
// 4. Generate VM code (in the form of a Maude program) from the AST

// Remarks:
// Liberalisation's wrt. EBJ's grammar in the formal spec. of ABS (abs.tex):
// - Allow interfaces and classes in any order
// - In blocks, allow declarations and statements in any order
// 

Program                         ::= TypeDecl* Block;

//A Block is the body of programs and methods. 
//It contains a list of zero or more ast.VarOrFieldDecl and one ast.StmtRet, 
//these are named Fields and Stmts resp.  
Block				::= Fields:VarOrFieldDecl*  Stmts:StmtRet;

DeclBlock			::= Fields:VarOrFieldDecl*  Methods:Method*;


// TODO: add this too?: /Predefined:InterfaceOrClassDecl*/;

abstract 	TypeDecl	::= <Name:String>; // TODO: simplify to <Name>
ClassDecl:	TypeDecl	::= Implements:IdUse* Body:DeclBlock;
IntDecl:	TypeDecl	::= Body:MethodSig*;


VarOrFieldDecl:	TypeDecl	::= Type:TypeAccess; //<Name:String> for the name of the variable or field is inherited from TypeDecl and 
                                                     //IdUse is a subclass of TypeAccess, parsing (cf. ABS.parser) returns an instance of IdUse. 

Method				::= MethodSig Block;

//MethodSig                      ::= <ReturnType:String> <Name:String> Params:VarOrParamDecl*;
MethodSig : TypeDecl 		::= ReturnType:TypeAccess Params:VarOrFieldDecl*; //<Name:String> (for the name) inherited from TypeDecl.
                                                                                  //IdUse (for the type)  

abstract TypeAccess;
IdUse:	TypeAccess ::= <ID:String>;

//Testing ClassDecl 
//Old stuff below.


// A `BlockStmt' is either a variable declaration or a regular statement. 
// ATO: Why? , ABS does not allow variable declarations in blocks. 


//abstract BlockStmt;
//abstract Stmt:	BlockStmt;


StmtRet                         ::= Stmts:Stmt* RetExp:PureExp; 

abstract Stmt; 

AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
IfStmt: Stmt			::= Condition:PureExp IfPart:Stmt* ElsePart:Stmt*;
WhileStmt: Stmt			::= Condition:PureExp Body:Stmt*;
ReleaseStmt: Stmt;
AssignStmt: Stmt		::= <Variable:String> Value:Exp;

// TODO: assume that parsing guarantees that `Stmt*' is never empty?

abstract Guard;
Put: Guard			::= <Variable:String>;
And: Guard			::= Left:Guard right:Guard;

abstract Exp;
abstract PureExp: Exp;
abstract ImpureExp: Exp;

VarRef: PureExp			::= <VarName:String>;
GetExp: PureExp			::= PureExp;
NullExpr: PureExp;
BoolExp: PureExp                ::= <Value:String>;        

NewExp: ImpureExp		::= <ClassRef:String>;
abstract MethCall: ImpureExp 	::= <Method:String> Params:PureExp*;
LocalSyncMethCall: MethCall;
NonlocalSyncMethCall: MethCall	::= <Callee:String>;
AsyncMethCall: MethCall		::= Callee:Exp;



// TODO: unfinished
Future: TypeAccess;


// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;


