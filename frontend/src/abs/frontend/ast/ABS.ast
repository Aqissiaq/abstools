//$Id$ 
//
 

Program                         ::= Decl* [Block];

// A Block is the body of programs and methods and is also used for initblocks
// It contains a list of zero or more ast.VarOrFieldDecl 
// and zero or more ast.Stmt, these are named Fields and Stmts resp.  
Block				::= Fields:VarDecl*  Stmts:Stmt*;

// A ClassBlock is the body of a Class. 
ClassBlock			::= [InitBlock:Block] Fields:VarDecl* Methods:Method*;
//ClassBlock			::= Fields:VarDecl*  Methods:Method*;
//ClassBlock              ::= [InitBlock:Block] Decls:ClassBlockDecl* ;                          

abstract 				Decl ::= <Name>;
abstract BehaviorDecl:	Decl; // Entities used in behavior expressions
abstract TypeDecl:		Decl; // Entities used in type expressions
//abstract ClassBlockDecl ; 

UnknownDecl:	Decl;			// Unknown declarations
ClassDecl:		BehaviorDecl	::= Params:ParamDecl* ImplementedInterfaceUse:IdUse* Body:ClassBlock;
InterfaceDecl:	TypeDecl		::= ExtendedInterfaceUse:IdUse* Body:MethodSig*;
DatatypeDecl:	TypeDecl		::= DataConstructors:DataConstructor* ;
FunctionDecl:	Decl		    ::= DataType:DataType Params:FunVarDecl* FunDef:FunExp ;

	//IdUse is a subclass of TypeAccess, parsing (cf. ABS.parser) returns an instance of IdUse. 


abstract  VarOrFieldDecl  ::= <Name> TypeExp; 

VarDecl : VarOrFieldDecl  ; 
ParamDecl : VarOrFieldDecl ;

FunVarDecl ::= <Name> DataType;   

Method  ::= MethodSig Block;

MethodSig	::= <Name> ReturnType:TypeExp Params:ParamDecl*;

IdUse				::= <Name>;

abstract TypeExp ; 
abstract NamedTypeExp : TypeExp  ::= <Name> ; 
DataType:	NamedTypeExp ;
InterfaceType:	NamedTypeExp ;
UnresolvedType : NamedTypeExp ;     // A type expression whose type cannot be resolved at parse time.
										// Will be  resolved by rewriting. 
FutureType: TypeExp ::= TypeExp ;  // A future doesn't have a name as such


/*
Constructors occur as 
- DataConstructors as in data declarations Co(_D_)
- term consctructors as in Co(_t_)
- patterns as in Co(_p_)
- Don't know yet how to organise these.   
*/

abstract Constructor ::= <Name>; 
DataConstructor : Constructor ::= ConstructorArgs:DataType* ;


abstract Stmt; 
abstract InitStmt : Stmt ;   //FIXME not all statements can be init statements, i.e. occur in an init block

AwaitStmt: Stmt			::= Guard;
SkipStmt: Stmt;
IfStmt: Stmt			::= Condition:PureExp Then:Stmt [Else:Stmt];
//WhileStmt: Stmt			::= Condition:PureExp Body:Stmt*;
ReleaseStmt: Stmt;
AssignStmt: Stmt		::= Var:VarRef Value:Exp;
StmtBlock: Stmt			::= Stmt:Stmt*;
EmptyStmt: Stmt;
ReturnStmt: Stmt		::= RetExp:Exp; 
ExpressionStmt: Stmt	::= Exp:Exp; 


abstract Guard;
ClaimGuard: Guard		::= Var:VarRef;
AndGuard: Guard			::= Left:Guard Right:Guard;
//For boolean guards   
ExpGuard: Guard			::= PureExp ; 

abstract Exp;
abstract PureExp: Exp;
abstract EffExp: Exp;
abstract FunExp : Exp ; 

//FunctionalExpression 
abstract FunVal  : FunExp ; 
abstract Pattern ; 

PatVar : Pattern ::= <Name> ; 


FunVar : FunVal ::= <Name> ; //Name = Variable name 
Term : FunVal  ::= <Constructor> Params:Term* ;
TermPair : FunVal ::= Left:Term Right:Term ;

LetExp  : FunExp ; 
FnApp  : FunExp ;
CaseExp  : FunExp ;



// Side effect free expressions 
VarRef: PureExp			::= <VarName>;
LocalVarRef: VarRef ;            
GetExp: PureExp			::= PureExp;
NullExp: PureExp;
//EqExp: PureExp   		::= Left:PureExp Right:PureExp ; 

// Expressions with side effects. 
NewExp: EffExp			::= <ClassRef> Param:PureExp*; 
abstract Call: EffExp 	::= <Method> Param:PureExp*;
LocalSyncCall: Call;
LocalAsyncCall: Call;
SyncCall: Call			::= Callee:PureExp;
AsyncCall: Call			::= Callee:PureExp;



/*
// Created by NTA equations
InterfaceRef:	TypeAccess;
PrimitiveTypeRef: TypeAccess;	// e.g. bool
UnknownDecl:	TypeAccess;
*/