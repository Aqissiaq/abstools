import java.util.HashMap;
import java.util.HashSet;

import abs.frontend.typechecker.KindedName;
import abs.frontend.typechecker.ResolvedName;

aspect TypeResolution {
  
    // Find the type declaration for a type use.
  
    syn boolean Decl.isFunction() = false;
    syn boolean Decl.isClass() = false;
    syn boolean Decl.isDataType() = false;
    syn boolean Decl.isDataConstructor() = false;
    syn boolean Decl.isInterface() = false;
    syn boolean Decl.isTypeSyn() = false;
    syn boolean Decl.isTypeParameter() = false;
  
    eq ClassDecl.isClass() = true;
    eq FunctionDecl.isFunction() = true;
    eq InterfaceDecl.isInterface() = true;
    eq DataTypeDecl.isDataType() = true;
    eq DataConstructor.isDataConstructor() = true;
    eq TypeSynDecl.isTypeSyn() = true;
    eq TypeParameterDecl.isTypeParameter() = true;
  
    syn Boolean Name.isSimple();
    eq Name.isSimple() = !getName().contains(".");
    
    syn lazy String Name.getString() = getName();
    syn String Name.getSimpleName() {
       if (isSimple())
          return getName();
       
       return getName().substring(getName().lastIndexOf('.')+1);
    }
    syn String Name.getModuleName() {
       if (isSimple())
       	  return null;
       
       return getName().substring(0,getName().lastIndexOf('.'));
    }
    
        syn Map<KindedName,ResolvedName> ModuleDecl.getVisibleNames() circular [new HashMap<KindedName, ResolvedName>()];
	eq ModuleDecl.getVisibleNames() {
		return TypeCheckerHelper.getVisibleNames(this);
	}

        syn Map<KindedName,ResolvedName> ModuleDecl.getExportedNames() circular [new HashMap<KindedName, ResolvedName>()];
	eq ModuleDecl.getExportedNames() {
		return TypeCheckerHelper.getExportedNames(this);
	}

        syn Map<KindedName,ResolvedName> ModuleDecl.getImportedNames() circular [new HashMap<KindedName, ResolvedName>()];
	eq ModuleDecl.getImportedNames() {
		return TypeCheckerHelper.getImportedNames(this);
	}

        syn Map<KindedName,ResolvedName> ModuleDecl.getDefinedNames() circular [new HashMap<KindedName, ResolvedName>()];
	eq ModuleDecl.getDefinedNames() {
		return TypeCheckerHelper.getDefinedNames(this);
	}
	
	syn lazy boolean ModuleDecl.exportsName(String name) {
		return ! TypeCheckerHelper.getAllNames(name, this.getExportedNames()).isEmpty();
	}

	syn lazy boolean ModuleDecl.isVisible(String name) {
		return ! TypeCheckerHelper.getAllNames(name, this.getVisibleNames()).isEmpty();
	}

    syn lazy Collection<ModuleDecl> Model.getModuleDecls() {
        ArrayList<ModuleDecl> res = new ArrayList<ModuleDecl>();
        for (CompilationUnit u : getCompilationUnits()) {
        	for (ModuleDecl mdecl : u.getModuleDecls()) {
               	res.add(mdecl);
            }
        }
        return res;
    }

    syn lazy Collection<Decl> Model.getDecls() {
        ArrayList<Decl> res = new ArrayList<Decl>();
       	for (ModuleDecl mdecl : getModuleDecls()) {
           	for (Decl d : mdecl.getDecls()) {
               	res.add(d);
           	}
        }
        return res;
    }
    
    syn lazy Block Model.getMainBlock() {
        for (CompilationUnit u : getCompilationUnits()) {
        	if (u.hasMainBlock())
        		return u.getMainBlock();
        }
        return null;
    }

    syn lazy Block CompilationUnit.getMainBlock() {
        for (ModuleDecl m: getModuleDecls()) {
        	if (m.hasBlock())
        		return m.getBlock();
        }
        return null;
    }
    
    syn lazy boolean Model.hasMainBlock() = getMainBlock() != null;
    syn lazy boolean CompilationUnit.hasMainBlock() = getMainBlock() != null;
    
    // *decl* refers to the appropriate declaration of the TypeUse or to
    // UnknownDecl if the declaration is missing
    syn lazy Decl TypeUse.getDecl() = lookup(new KindedName(Kind.TYPE_DECL,getName()));
    
    
    syn lazy ModuleDecl Model.lookupModule(String name) {
    	for (CompilationUnit u : getCompilationUnits()) {
			for (ModuleDecl d : u.getModuleDecls()) {
				if (d.getName().equals(name)) {
					return d;
				}
			}    			
    	}
    	return null;
    }
    
    inh ModuleDecl Decl.getModuleDecl();
    eq ModuleDecl.getDecl().getModuleDecl() = this;
    
    inh ModuleDecl Export.getModuleDecl();
    eq ModuleDecl.getExport().getModuleDecl() = this;
    
    inh ModuleDecl Import.lookupModule(String name);
    inh ModuleDecl Export.lookupModule(String name);
    inh ModuleDecl CompilationUnit.lookupModule(String name);
    inh ModuleDecl ModuleDecl.lookupModule(String name);
    eq CompilationUnit.getModuleDecl().lookupModule(String name) = lookupModule(name);
    eq Model.getCompilationUnit().lookupModule(String name) = lookupModule(name);
    
    
    syn lazy Decl Model.lookup(KindedName name) {
    	for (CompilationUnit u : getCompilationUnits()) {
			for (ModuleDecl d : u.getModuleDecls()) {
				Decl decl = d.lookup(name);
				if (!decl.equals(unknownDecl()))
					return decl;
			}    			
    	}
    	return unknownDecl();
    }
    
    eq ParametricDataTypeDecl.getDataConstructor().lookup(KindedName name) = localLookup(name);
    eq ParametricFunctionDecl.getFunctionDef().lookup(KindedName name) = localLookup(name);
    eq ParametricFunctionDecl.getTypeUse().lookup(KindedName name) = localLookup(name);
    eq ParametricFunctionDecl.getParam().lookup(KindedName name) = localLookup(name);
    
    // Expose *lookup* at various places in the AST
    inh Decl Exp.lookup(KindedName name);
    inh Decl Pattern.lookup(KindedName name);
    inh Decl Annotation.lookup(KindedName name);
    inh Decl DataTypeUse.lookup(KindedName name);
    inh Decl TypedVarOrFieldDecl.lookup(KindedName name);
    eq ParametricDataTypeUse.getParam().lookup(KindedName name) = lookup(name);
    eq TypedVarOrFieldDecl.getAccess().lookup(KindedName name) = lookup(name);

    inh Decl ParametricDataTypeDecl.lookup(KindedName name);
    inh Decl ParametricFunctionDecl.lookup(KindedName name);
    inh Decl ClassDecl.lookup(KindedName name);
    inh Decl InterfaceDecl.lookup(KindedName name);
	eq ModuleDecl.getDecl(int i).lookup(KindedName name) = lookup(name);
	eq ModuleDecl.getBlock().lookup(KindedName name) = lookup(name);

	syn lazy Decl ModuleDecl.lookup(KindedName name) {
		ResolvedName r = TypeCheckerHelper.resolveName(this,name);
		if (r != null) {			
	    	return r.getDecl();
	    } else {	
	   		return unknownDecl();
	    } 			
	}	    
    
    
    // look through local declarations in parametric datatype, or defer
    // to model
    syn lazy Decl ParametricDataTypeDecl.localLookup(KindedName name) {
        for (TypeParameterDecl d : getTypeParameters())
            if (d.getName().equals(name.getName()))
                return d;
        return lookup(name);
    }
    // look through local declarations in parametric function, or defer
    // to model
    syn lazy Decl ParametricFunctionDecl.localLookup(KindedName name) {
        for (TypeParameterDecl d : getTypeParameters())
            if (d.getName().equals(name.getName()))
                return d;
        return lookup(name);
    }
    
    rewrite UnresolvedTypeUse {
        when (getDecl().isInterface())
            to InterfaceTypeUse new InterfaceTypeUse(getName());
        when (getDecl().isDataType()) 
            to DataTypeUse new DataTypeUse(getName(), new List());
        when (getDecl().isTypeSyn())
            to DataTypeUse ((TypeSynDecl)getDecl()).getValue().copy();
        when (getDecl().isTypeParameter())
        	to TypeParameterUse new TypeParameterUse(getName());
    }
    
    
    syn lazy Decl FnApp.getDecl() = lookup(new KindedName(Kind.FUN,getName()));
    
    inh lazy DataTypeDecl DataConstructor.getDataTypeDecl();
    eq DataTypeDecl.getDataConstructor().getDataTypeDecl() = this;
    eq ModuleDecl.getDecl().getDataTypeDecl() = null; // never called
    
    syn lazy Decl DataConstructorExp.getDecl() {
        return this.getDataConstructor();
    }

    syn lazy DataConstructor DataConstructorExp.getDataConstructor() {
		Decl decl = lookup(new KindedName(Kind.DATA_CONSTRUCTOR,getConstructor()));
		if (! (decl instanceof DataConstructor)) 
			throw new TypeCheckerException(new TypeError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE, getConstructor()));
		return (DataConstructor) decl;    
    }
    
    
    syn lazy Decl Decl.getContextDecl() = this;
    eq MethodImpl.getBlock().getContextDecl() = getContextDecl();
    eq ModuleDecl.getBlock().getContextDecl() = unknownDecl();
    eq ClassDecl.getInitBlock().getContextDecl() = getContextDecl();
    eq ClassDecl.getMethod().getContextDecl() = getContextDecl();
    eq DeltaDecl.getModifier().getContextDecl() = getContextDecl();
    inh Decl Stmt.getContextDecl();
    inh Decl Exp.getContextDecl();
    inh Decl MethodImpl.getContextDecl();
    
    eq MethodImpl.getBlock().getContextMethod() = this;
    eq ClassDecl.getInitBlock().getContextMethod() = null;
    eq ModuleDecl.getBlock().getContextMethod() = null;
    inh MethodImpl Stmt.getContextMethod();

    eq MethodImpl.getBlock().getContextBlock() = getBlock();
    eq ClassDecl.getInitBlock().getContextBlock() = getInitBlock();
    eq ModuleDecl.getBlock().getContextBlock() = getBlock();
    inh Block Stmt.getContextBlock();
    
    
    syn lazy MethodImpl ClassDecl.lookupMethod(String name) {
   	 for (MethodImpl m : getMethods()) {
   		 if (m.getMethodSig().getName().equals(name))
   			 return m;
   	 }
   	 return null;
    }
    
    syn lazy MethodSig InterfaceDecl.lookupMethod(String name) {
        for (MethodSig d : getBodys()) {
            if (d.getName().equals(name))
                return d;
        }
        
        for (InterfaceTypeUse u : getExtendedInterfaceUses()) {
            InterfaceDecl id = (InterfaceDecl) u.getDecl();
            MethodSig s = id.lookupMethod(name);
            if (s != null)
                return s;
        }
        
        return null;
    }
 
 
    syn lazy String CompilationUnit.getFileName() = getName();
    
    inh String Exp.getFileName();
    inh String Stmt.getFileName();
  	inh String ModuleDecl.getFileName();

	eq ModuleDecl.getDecl().getFileName() = getFileName();
    eq ModuleDecl.getBlock().getFileName() = getFileName();
    eq CompilationUnit.getModuleDecl().getFileName() = getFileName();
}

// Local Variables:
// mode: java
// End:
