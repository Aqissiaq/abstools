import abs.common.*;

import abs.frontend.typechecker.*;

aspect TypeAnalysis {

	// ***API***
  
	// *hasCycleOnExtendedInterfaceChain*
	// True if there is a cycle somewhere on the superinterface chain
	syn lazy boolean InterfaceDecl.hasCycleOnExtendedInterfacesChain() circular [true];
  
	
	// *hasCycleOnExtendedInterfacesChain* - true if there is a cycle somewhere on the extendedInterfaces chain
	eq InterfaceDecl.hasCycleOnExtendedInterfacesChain() {
		List<InterfaceTypeUse> refs = getExtendedInterfaceUses(); // names occuring in this declaration
		boolean cycleFound = false;

		for (InterfaceTypeUse ref : refs) {
			TypeDecl decl = ref.getDecl(); // Note decl var. distinct from decl() method
			if (decl instanceof InterfaceDecl) {
				cycleFound = cycleFound || ((InterfaceDecl)decl).hasCycleOnExtendedInterfacesChain();
			} else { // Semantic errors in input program can cause dell==null or dell to have other wild values
				     // e.g., cyclic interface inheritance chains.
				; // Ignore such AST structural oddities as the causes are caught by other checks (methinks...)
			}
		}

		return cycleFound;
	}
	
	
	syn lazy Type ClassDecl.getType() = new UnionType(getImplementedInterfaceUses());
	
    syn lazy Type TypeDecl.getType();
    
    eq DataTypeDecl.getType() {
        return new DataTypeType(this);
    }
    eq ParametricDataTypeDecl.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq InterfaceDecl.getType() { 
        return new InterfaceType(this);
    }
    eq TypeParameterDecl.getType() { 
        return new TypeParameter(this);
    }
    eq TypeSynDecl.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq UnknownDecl.getType() = UnknownType.INSTANCE;
    
    syn lazy Type VarOrFieldDecl.getType() = UnknownType.INSTANCE;
    eq TypedVarOrFieldDecl.getType() {
        Access a = getAccess();
        if (a instanceof TypeUse) {
            return ((TypeUse)a).getDecl().getType();
        }
        throw new NotImplementedYetException("Type Checker",this);
    }
    
    /* EXPRESSIONS */
    
    syn Type Exp.getIntType() = new DataTypeType((DataTypeDecl)lookup("Int"));
    syn Type Exp.getBoolType() = new DataTypeType((DataTypeDecl)lookup("Bool"));
    syn Type Exp.getStringType() = new DataTypeType((DataTypeDecl)lookup("String"));
    
    syn lazy Type Exp.getType();
	 eq AsyncCall.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq SyncCall.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq GetExp.getType() = getPureExp().getType();
    eq NewExp.getType() = ((ClassDecl)lookup(getClassRef())).getType();
    eq FutureTypeUse.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq FieldUse.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq VarUse.getType() = getDecl().getType();
    eq TypeUse.getType() = getDecl().getType();
    eq ArithmeticExp.getType() = getIntType();
    eq BoolExp.getType() = getBoolType();
    eq RelationalExpr.getType() = getBoolType();
    eq CaseExp.getType() = getBranch(0).getRight().getType(); 
    eq FnApp.getType() = ((FunctionDecl) lookup(getName())).getTypeUse().getType();
    eq DataConstructorExp.getType() = lookupDataConstructor(this).getType();
    eq FunVar.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq LetExp.getType() = getExp().getType();
    eq IntLiteral.getType() = getIntType();
    eq StringLiteral.getType() =  getStringType();
    eq NullExp.getType() = NullType.INSTANCE;
    eq ThisExp.getType() { throw new NotImplementedYetException("Type Checker",this); }
    eq MinusExp.getType() = getIntType();
    eq NegExp.getType() = getBoolType();
	
	
}

// Local Variables:
// mode: java
// End:
