import abs.common.*;

import abs.frontend.typechecker.*;

import abs.frontend.typechecker.TypeCheckerHelper;


aspect TypeChecker {
    
    syn lazy boolean Model.hasTypeErrors() = !typeCheck().isEmpty();
    
    syn lazy SemanticErrorList Model.typeCheck() {
        SemanticErrorList res = new SemanticErrorList();
        typeCheck(res);
        return res;
    }
    
    public void Model.typeCheck(SemanticErrorList e) {
        for (Decl d : getDecls()) {
            d.typeCheck(e);
        }
        
        if (hasBlock()) {
            getBlock().typeCheck(e);
        }
    }
    
    
    // DECLS
    
    public abstract void Decl.typeCheck(SemanticErrorList e);  
    
    public void ClassDecl.typeCheck(SemanticErrorList e) {
   	 // TODO: check that class implements an interface
   	 // TODO: check that class does not implement same interface twice
   	 for (FieldDecl f : getFields()) {
   		  f.typeCheck(e);
   	  }
   	  for (Method m : getMethods()) {
   		  m.typeCheck(e);
   	  }
    }
    
    public void FunctionDecl.typeCheck(SemanticErrorList e) { 
        // TODO: implement
    }
    
    public void InterfaceDecl.typeCheck(SemanticErrorList e) {
        // TODO: implement
    }
    public void DataTypeDecl.typeCheck(SemanticErrorList e) {
        // TODO no duplicate constructor names
        
    }
    
    public void TypeSynDecl.typeCheck(SemanticErrorList e) {
        getValue().typeCheck(e);
    }
    
    public void TypeParameterDecl.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    
    public void UnknownDecl.typeCheck(SemanticErrorList e) { }
    
    
    public void Block.typeCheck(SemanticErrorList e) {
        for (VarDecl v : getVars()) {
            v.typeCheck(e);
        }
        
        for (Stmt s : getStmts()) {
            s.typeCheck(e);
        }
    }
    
    public void Method.typeCheck(SemanticErrorList e) {
   	 Block b = getBlock();
   	 Type lastType = getUnitType();
   	 if (b.getNumStmt() > 0) {
   		 lastType = b.getStmt(b.getNumStmt()-1).getType();
   	 }
   	 
   	 if (!lastType.isSubtypeOf(getReturnType().getType())) {
   		 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,lastType,getReturnType().getType()));
   	 }
   	 
   	 b.typeCheck(e);
    }

    public void FieldDecl.typeCheck(SemanticErrorList e) { 
        getAccess().typeCheck(e);
    }
    
    public void VarDecl.typeCheck(SemanticErrorList e) { 
   	 getAccess().typeCheck(e);

   	 Type t = getAccess().getType();
   	 if (hasInitExp()) {
   		 TypeCheckerHelper.checkAssignment(e,this,t,getInitExp());
   		 getInitExp().typeCheck(e);
   	 } else {
   		 if (!t.isReferenceType() && !t.isFutureType()) {
   			 e.add(new TypeError(this, ErrorMessage.VAR_INIT_REQUIRED, new String[0]));
   		 }
   	 }
    }
    
    public void ParamDecl.typeCheck(SemanticErrorList e) {
   	 getAccess().typeCheck(e);
    }
    
    // STMTS
    
    public abstract void Stmt.typeCheck(SemanticErrorList e);
    public void ExpressionStmt.typeCheck(SemanticErrorList e) {
   	 getExp().typeCheck(e);
    }
    public void AssignStmt.typeCheck(SemanticErrorList e) {
   	 Type rht = getValue().getType();
   	 Type lht = getVar().getType();
		 if (!rht.isSubtypeOf(lht)) {
			 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,rht,lht));
		 }
		 getValue().typeCheck(e);
		 getVar().typeCheck(e);
    }
    
    public void ReturnStmt.typeCheck(SemanticErrorList e) {
   	 Method m = getContextMethod();
   	 Type rht = getRetExp().getType();
   	 Type lht = m.getReturnType().getType();
		 if (!rht.isSubtypeOf(lht)) {
			 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,rht,lht));
		 }
   		 
   	 getRetExp().typeCheck(e); 
    }
    
    public void AwaitStmt.typeCheck(SemanticErrorList e) {
   	 getGuard().typeCheck(e);
    }

    public void SuspendStmt.typeCheck(SemanticErrorList e) { /* nothing to check */ }
    
    
    public void IfStmt.typeCheck(SemanticErrorList e) {
   	 getCondition().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getCondition(),getBoolType());
   	 getThen().typeCheck(e);
   	 if (hasElse())
   		 getElse().typeCheck(e);

    }
    
    public void WhileStmt.typeCheck(SemanticErrorList e) {
   	 getCondition().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getCondition(),getBoolType());
   	 getBody().typeCheck(e);
    }
    
    public void SkipStmt.typeCheck(SemanticErrorList e) { /* nothing to check */ }


    // GUARDS
    public abstract void Guard.typeCheck(SemanticErrorList e);
    public void AndGuard.typeCheck(SemanticErrorList e) { 
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    
    public void ClaimGuard.typeCheck(SemanticErrorList e) { 
   	 getVar().typeCheck(e);
   	 Type t = getVar().getType();
   	 if (!t.isFutureType()) {
   		 e.add(new TypeError(getVar(),ErrorMessage.EXPECTED_FUT_TYPE, t));
   	 }
    }
    public void ExpGuard.typeCheck(SemanticErrorList e) { 
   	 getPureExp().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getPureExp(),getBoolType());
    }
    
    
    
    // EXPRESSIONS
    
    public void Exp.typeCheck(SemanticErrorList e) { }
    
    public void TypeUse.typeCheck(SemanticErrorList e) {
   	 if (getType().isUnknownType()) {
   		 e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
   	 }
    }
    
    public void AsyncCall.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void SyncCall.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void GetExp.typeCheck(SemanticErrorList e) {  
   	 if (!getPureExp().getType().isFutureType()) {
   		 e.add(new TypeError(getPureExp(), ErrorMessage.EXPECTED_FUT_TYPE, getPureExp().getType())); 
   	 }
   	 getPureExp().typeCheck(e);
    }
    public void ArithmeticExp.typeCheck(SemanticErrorList e) {  
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getIntType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getIntType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    public void BoolExp.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getBoolType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getBoolType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    public void RelationalExpr.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getIntType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getIntType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }

    public void EqualityExpr.typeCheck(SemanticErrorList e) {
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    
    public void CaseExp.typeCheck(SemanticErrorList e) {  
   	 getExpr().typeCheck(e);
   	 Type et = getExpr().getType();
   	 if (!et.isDataType()) {
   		 e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
   		 return;
   	 }
   	 Type t = null;
   	 for (CaseBranch b : getBranchs()) {
   		 b.typeCheck(e,(DataTypeType) et);
   		 if (t == null) {
   			 t = b.getType();
   		 } else {
   			 Type t2 = b.getType();
   			 if (!t.equals(t2)) {
   				 e.add(new TypeError(this,ErrorMessage.BRANCH_NO_SAME_TYPE,t,t2));
   			 }
   		 }
   	 }
    } 
    
    public void CaseBranch.typeCheck(SemanticErrorList e, DataTypeType t) {
   	 getLeft().typeCheck(e,t);
   	 getRight().typeCheck(e);
    }
    
    public void FnApp.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void DataConstructorExp.typeCheck(SemanticErrorList e) {
   	 DataConstructor c = getDecl();
   	 if (c == null) {
   		 e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
   		 return;
   	 }
   	 if (c.getNumConstructorArg() != this.getNumParam()) {
   		 e.add(new TypeError(this,ErrorMessage.WRONG_NUMBER_OF_ARGS,c.getNumConstructorArg(),this.getNumParam()));
   		 return;
   	 }
   	 for (int i = 0; i < getNumParam(); i++) {
   		 Type argType = c.getConstructorArg(i).getType();
   		 PureExp exp = getParam(i);
   		 if (!exp.getType().isSubtypeOf(argType)) {
   			 e.add(new TypeError(this,ErrorMessage.PATTERN_WRONG_TYPE,argType,exp.getType()));
   		 }
   	 }
   	 
    }
    public void LetExp.typeCheck(SemanticErrorList e) {  
   	 getVar().typeCheck(e);
   	 getVal().typeCheck(e);
   	 getExp().typeCheck(e);
		 TypeCheckerHelper.checkAssignment(e,this,getVar().getAccess().getType(),getVal());
   	 
   	 
    }

    public void MinusExp.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getOperand(),getIntType());
       getOperand().typeCheck(e);
    }

    public void NegExp.typeCheck(SemanticErrorList e) {
   	 TypeCheckerHelper.assertHasType(e,getOperand(),getBoolType());
       getOperand().typeCheck(e);
    }
    
    
    // PATTERNS
    
    public void Pattern.typeCheck(SemanticErrorList e, DataTypeType t) {  }
    public void ConstructorPattern.typeCheck(SemanticErrorList e, DataTypeType t) { 
   	 DataConstructor c = lookupDataConstructor(getConstructor());
   	 if (c == null) {
   		 e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
   		 return;
   	 }
   	 if (c.getNumConstructorArg() != this.getNumParam()) {
   		 e.add(new TypeError(this,ErrorMessage.WRONG_NUMBER_OF_ARGS,c.getNumConstructorArg(),this.getNumParam()));
   		 return;
   	 }
   	 for (int i = 0; i < getNumParam(); i++) {
   		 Type argType = c.getConstructorArg(i).getType();
   		 Pattern p = getParam(i);
   		 if (argType instanceof DataTypeType) {
   			 p.typeCheck(e,(DataTypeType) argType);
   			 if (!p.getType().isSubtypeOf(argType)) {
   				 e.add(new TypeError(this,ErrorMessage.PATTERN_WRONG_TYPE,argType,p.getType()));
   			 }
   		 }
   	 }
    }
    
    
}
