import abs.common.*;

import abs.frontend.typechecker.*;

import abs.frontend.typechecker.TypeCheckerHelper;


aspect TypeChecker {
    
    
    
    syn lazy boolean Model.hasTypeErrors() = !typeCheck().isEmpty();
    
    syn lazy SemanticErrorList Model.typeCheck() {
        SemanticErrorList res = new SemanticErrorList();
        typeCheck(res);
        return res;
    }
    
    public void Model.typeCheck(SemanticErrorList e) {
        for (Decl d : getDecls()) {
            d.typeCheck(e);
        }
        
        if (hasBlock()) {
            getBlock().typeCheck(e);
        }
    }
    
    
    // DECLS
    
    public abstract void Decl.typeCheck(SemanticErrorList e);  
    
    public void ClassDecl.typeCheck(SemanticErrorList e) {
   	 // TODO: check that class implements an interface
   	 // TODO: check that class does not implement same interface twice
   	 for (FieldDecl f : getFields()) {
   		  f.typeCheck(e);
   	  }
   	  for (Method m : getMethods()) {
   		  m.typeCheck(e);
   	  }
    }
    
    public void FunctionDecl.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void InterfaceDecl.typeCheck(SemanticErrorList e) {
   	 // TODO: implement
    }
    public void DataTypeDecl.typeCheck(SemanticErrorList e) {
   	 // TODO: implement
    }
    
    public void TypeSynDecl.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void TypeParameterDecl.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void UnknownDecl.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    
    
    public void Block.typeCheck(SemanticErrorList e) {
        for (VarDecl v : getVars()) {
            v.typeCheck(e);
        }
        
        for (Stmt s : getStmts()) {
            s.typeCheck(e);
        }
    }
    
    public void Method.typeCheck(SemanticErrorList e) {
   	 Block b = getBlock();
   	 Type lastType = getUnitType();
   	 if (b.getNumStmt() > 0) {
   		 lastType = b.getStmt(b.getNumStmt()-1).getType();
   	 }
   	 
   	 if (!lastType.isSubtypeOf(getReturnType().getType())) {
   		 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,lastType,getReturnType().getType()));
   	 }
   	 
   	 b.typeCheck(e);
    }

    public void FieldDecl.typeCheck(SemanticErrorList e) { 
   	 throw new NotImplementedYetException("Type Checker",this); 
    }
    
    public void VarDecl.typeCheck(SemanticErrorList e) { 
   	 getAccess().typeCheck(e);

   	 Type t = getAccess().getType();
   	 if (hasInitExp()) {
   		 Type te = getInitExp().getType();
   		 if (!te.isSubtypeOf(t)) {
   			 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,te,t));
   		 }
   		 getInitExp().typeCheck(e);
   	 } else {
   		 if (!t.isReferenceType() && !t.isFutureType()) {
   			 e.add(new TypeError(this, ErrorMessage.VAR_INIT_REQUIRED, new String[0]));
   		 }
   	 }
   	 
   	 
    }
    
    // STMTS
    
    public abstract void Stmt.typeCheck(SemanticErrorList e);
    public void ExpressionStmt.typeCheck(SemanticErrorList e) {
   	 getExp().typeCheck(e);
    }
    public void AssignStmt.typeCheck(SemanticErrorList e) {
   	 Type rht = getValue().getType();
   	 Type lht = getVar().getType();
		 if (!rht.isSubtypeOf(lht)) {
			 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,rht,lht));
		 }
		 getValue().typeCheck(e);
		 getVar().typeCheck(e);
    }
    
    public void ReturnStmt.typeCheck(SemanticErrorList e) {
   	 Method m = getContextMethod();
   	 Type rht = getRetExp().getType();
   	 Type lht = m.getReturnType().getType();
		 if (!rht.isSubtypeOf(lht)) {
			 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,rht,lht));
		 }
   		 
   	 getRetExp().typeCheck(e); 
    }
    
    public void AwaitStmt.typeCheck(SemanticErrorList e) {
   	 getGuard().typeCheck(e);
    }

    public void SuspendStmt.typeCheck(SemanticErrorList e) { }
    
    
    public void IfStmt.typeCheck(SemanticErrorList e) {
   	 TypeCheckerHelper.assertHasType(e,getCondition(),getBoolType());
   	 
   	 getCondition().typeCheck(e);
   	 getThen().typeCheck(e);
   	 if (hasElse())
   		 getElse().typeCheck(e);
   	 
    }
    
    public void WhileStmt.typeCheck(SemanticErrorList e) {
   	 TypeCheckerHelper.assertHasType(e,getCondition(),getBoolType());
   	 
   	 getCondition().typeCheck(e);
   	 getBody().typeCheck(e);
    }
    
    public void SkipStmt.typeCheck(SemanticErrorList e) { }


    // GUARDS
    public abstract void Guard.typeCheck(SemanticErrorList e);
    public void AndGuard.typeCheck(SemanticErrorList e) { 
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    
    public void ClaimGuard.typeCheck(SemanticErrorList e) { 
   	 getVar().typeCheck(e);
   	 Type t = getVar().getType();
   	 if (!t.isFutureType()) {
   		 e.add(new TypeError(getVar(),ErrorMessage.EXPECTED_FUT_TYPE, t));
   	 }
    }
    public void ExpGuard.typeCheck(SemanticErrorList e) { 
   	 getPureExp().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getPureExp(),getBoolType());
    }
    
    
    
    // EXPRESSIONS
    
    public void Exp.typeCheck(SemanticErrorList e) { }
    
    public void TypeUse.typeCheck(SemanticErrorList e) {
   	 if (getType().isUnknownType()) {
   		 e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
   	 }
    }
    
    public void AsyncCall.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void SyncCall.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void GetExp.typeCheck(SemanticErrorList e) {  
   	 if (!getPureExp().getType().isFutureType()) {
   		 e.add(new TypeError(getPureExp(), ErrorMessage.EXPECTED_FUT_TYPE, getPureExp().getType())); 
   	 }
   	 getPureExp().typeCheck(e);
    }
    public void ArithmeticExp.typeCheck(SemanticErrorList e) {  
   	 TypeCheckerHelper.assertEqualTypes(e,getLeft(),getLeft().getType(),getIntType());
   	 TypeCheckerHelper.assertEqualTypes(e,getRight(),getRight().getType(),getIntType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    public void BoolExp.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertEqualTypes(e,getLeft(),getLeft().getType(),getBoolType());
   	 TypeCheckerHelper.assertEqualTypes(e,getRight(),getRight().getType(),getBoolType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    public void RelationalExpr.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertEqualTypes(e,getLeft(),getLeft().getType(),getIntType());
   	 TypeCheckerHelper.assertEqualTypes(e,getRight(),getRight().getType(),getIntType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }

    public void EqualityExpr.typeCheck(SemanticErrorList e) {
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    
    public void CaseExp.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); } 
    public void FnApp.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }
    public void DataConstructorExp.typeCheck(SemanticErrorList e) {
   	 DataConstructor c = getDecl();
   	 if (c.getNumConstructorArg() > 0) {
   		 throw new NotImplementedYetException("Type Checker",this);
   	 }
    }
    public void LetExp.typeCheck(SemanticErrorList e) { throw new NotImplementedYetException("Type Checker",this); }

    public void MinusExp.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertEqualTypes(e,getOperand(),getOperand().getType(),getIntType());
       getOperand().typeCheck(e);
    }

    public void NegExp.typeCheck(SemanticErrorList e) {
   	 TypeCheckerHelper.assertEqualTypes(e,getOperand(),getOperand().getType(),getBoolType());
       getOperand().typeCheck(e);
    }
    
}
