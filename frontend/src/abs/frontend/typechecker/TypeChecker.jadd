import abs.common.*;

import abs.frontend.typechecker.*;

import abs.frontend.typechecker.TypeCheckerHelper;

import java.util.HashMap;


aspect TypeChecker {
    
    syn lazy boolean Model.hasTypeErrors() = !typeCheck().isEmpty();
    
    syn lazy SemanticErrorList Model.typeCheck() {
        SemanticErrorList res = new SemanticErrorList();
        typeCheck(res);
        return res;
    }
    
    public void Model.typeCheck(SemanticErrorList e) {
        for (Decl d : getDecls()) {
            d.typeCheck(e);
        }
        
        if (hasBlock()) {
            getBlock().typeCheck(e);
        }
    }
    
    
    // DECLS
    public void InterfaceDecl.addAllMethodSigs(HashMap<String, MethodSig> sigs) {
        for (InterfaceTypeUse u : getExtendedInterfaceUses()) {
            TypeDecl d = u.getDecl();
            if (d.isInterface()) {
                InterfaceDecl id = (InterfaceDecl) d;
                id.addAllMethodSigs(sigs);
            }    
        }
        
        for (MethodSig s : getBodys()) {
            sigs.put(s.getName(),s);
        }
    }
    
    public void ClassDecl.addAllMethodSigs(HashMap<String, MethodSig> sigs) {
        for (InterfaceTypeUse u : getImplementedInterfaceUses()) {
            TypeDecl d = u.getDecl();
            if (d.isInterface()) {
                InterfaceDecl id = (InterfaceDecl) d;
                id.addAllMethodSigs(sigs);
            }
        }
    }
    
    public abstract void Decl.typeCheck(SemanticErrorList e);  
    
    public void ClassDecl.typeCheck(SemanticErrorList e) {
   	 // TODO: check that class implements an interface

      HashMap<String, FieldDecl> fields = new HashMap<String, FieldDecl>();
      for (FieldDecl f : getFields()) {
   		  f.typeCheck(e);
   		  if (fields.containsKey(f.getName())) {
              e.add(new TypeError(f, ErrorMessage.DUPLICATE_FIELD_NAME, f.getName()));
          } else {
              fields.put(f.getName(),f);
          }
   	  }
   	  
      HashMap<String, MethodSig> sigs = new HashMap<String, MethodSig>();
      addAllMethodSigs(sigs);  
      
   	  for (MethodImpl m : getMethods()) {
   		  m.typeCheck(e);
   		  String name = m.getMethodSig().getName();
   		  if (sigs.containsKey(name)) {
//   		     e.add(new TypeError(m, ErrorMessage.NO_METHOD_IMPL, name));   		      
//   		  } else {
   		      MethodSig s = sigs.get(name);
   		      MethodSig ms = m.getMethodSig();
   		      InterfaceDecl d = (InterfaceDecl) s.getParent().getParent();
   		      if (s.getNumParam() != ms.getNumParam()) {
   		          e.add(new TypeError(m,ErrorMessage.METHOD_IMPL_WRONG_NUM_PARAMS, name, d.getName(), ""+s.getNumParam(), ""+ms.getNumParam()));
   		      } else {
   		          for (int i = 0; i < s.getNumParam(); i++) {
   		              Type texpected = s.getParam(i).getType();
   		              Type t = ms.getParam(i).getType();
   		              if (!texpected.equals(t)) {
   		                  e.add(new TypeError(m,ErrorMessage.METHOD_IMPL_WRONG_PARAM_TYPE, 
   		                        ms.getParam(i).getName(), name, d.getName(), 
   		                        texpected.toString(), t.toString()));
   		              }
   		          }
   		      }
   		  }
   	  }
   	  
   	  
    }
    
    public void FunctionDecl.typeCheck(SemanticErrorList e) {
        TypeCheckerHelper.typeCheckParamList(e,getParams());
        getTypeUse().typeCheck(e);
        getFunDef().typeCheck(e);
        
        TypeCheckerHelper.checkAssignment(e,this,getTypeUse().getType(), getFunDef());
    }
    
    public void InterfaceDecl.typeCheck(SemanticErrorList e) {
        HashMap<String, MethodSig> names = new HashMap<String, MethodSig>();
        for (MethodSig s : getBodys()) {
            if (names.containsKey(s.getName())) {
                e.add(new TypeError(s, ErrorMessage.DUPLICATE_METHOD_NAME, s.getName()));
            } else {
                names.put(s.getName(),s);
            }
            s.typeCheck(e);
        }
        
        for (InterfaceTypeUse u : getExtendedInterfaceUses()) {
            TypeDecl d = u.getDecl();
            if (!d.isInterface()) {
                e.add(new TypeError(u, ErrorMessage.ONLY_INTERFACE_EXTEND, d.getName()));
            } else {
                InterfaceDecl id = (InterfaceDecl) d;
                for (MethodSig s : id.getBodys()) {
                    if (names.containsKey(s.getName())) {
                        e.add(new TypeError(names.get(s.getName()), ErrorMessage.NO_METHOD_OVERRIDE, s.getName(), id.getName()));
                    }
                }
            }
        }
    }
    
    public void MethodSig.typeCheck(SemanticErrorList e) {
        getReturnType().typeCheck(e);
        TypeCheckerHelper.typeCheckParamList(e,getParams());
    }
     
    public void DataTypeDecl.typeCheck(SemanticErrorList e) {
        HashSet<String> names = new HashSet<String>();
        for (DataConstructor c : getDataConstructors()) {
            c.typeCheck(e);
            if (names.contains(c.getName())) {
                e.add(new TypeError(c, ErrorMessage.DUPLICATE_CONSTRUCTOR, c.getName()));
            } else {
                names.add(c.getName());
            }
        }
    }
    
    public void DataConstructor.typeCheck(SemanticErrorList e) {
        for (DataTypeUse d : getConstructorArgs()) {
            d.typeCheck(e);
        }
    }
    
    public void TypeSynDecl.typeCheck(SemanticErrorList e) {
        getValue().typeCheck(e);
    }
    
    public void TypeParameterDecl.typeCheck(SemanticErrorList e) {
        /* nothing to check */ }
    
    public void UnknownDecl.typeCheck(SemanticErrorList e) { 
        /* nothing to check */ }
    
    
    public void Block.typeCheck(SemanticErrorList e) {
        for (VarDecl v : getVars()) {
            v.typeCheck(e);
        }
        
        for (Stmt s : getStmts()) {
            s.typeCheck(e);
        }
    }
    
    public void MethodImpl.typeCheck(SemanticErrorList e) {
   	 Block b = getBlock();
   	 MethodSig sig = getMethodSig();
   	 sig.typeCheck(e);
   	 Type lastType = getUnitType();
   	 if (b.getNumStmt() > 0) {
   		 lastType = b.getStmt(b.getNumStmt()-1).getType();
   	 }
   	 
   	 if (!lastType.isSubtypeOf(sig.getReturnType().getType())) {
   		 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,lastType,sig.getReturnType().getType()));
   	 }
   	 
   	 b.typeCheck(e);
    }

    public void FieldDecl.typeCheck(SemanticErrorList e) { 
        getAccess().typeCheck(e);
    }
    
    public void VarDecl.typeCheck(SemanticErrorList e) { 
   	 getAccess().typeCheck(e);

   	 Type t = getAccess().getType();
   	 if (hasInitExp()) {
   		 TypeCheckerHelper.checkAssignment(e,this,t,getInitExp());
   		 getInitExp().typeCheck(e);
   	 } else {
   		 if (!t.isReferenceType() && !t.isFutureType()) {
   			 e.add(new TypeError(this, ErrorMessage.VAR_INIT_REQUIRED, new String[0]));
   		 }
   	 }
    }
    
    public void ParamDecl.typeCheck(SemanticErrorList e) {
   	 getAccess().typeCheck(e);
    }
    
    // STMTS
    
    public abstract void Stmt.typeCheck(SemanticErrorList e);
    public void ExpressionStmt.typeCheck(SemanticErrorList e) {
   	 getExp().typeCheck(e);
    }
    public void AssignStmt.typeCheck(SemanticErrorList e) {
   	 Type rht = getValue().getType();
   	 Type lht = getVar().getType();
		 if (!rht.isSubtypeOf(lht)) {
			 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,rht,lht));
		 }
		 getValue().typeCheck(e);
		 getVar().typeCheck(e);
    }
    
    public void ReturnStmt.typeCheck(SemanticErrorList e) {
   	 MethodImpl m = getContextMethod();
   	 if (m == null) return;
   	 
   	 Type rht = getRetExp().getType();
   	 Type lht = m.getMethodSig().getReturnType().getType();
		 if (!rht.isSubtypeOf(lht)) {
			 e.add(new TypeError(this,ErrorMessage.NO_SUBTYPE,rht,lht));
		 }
   		 
   	 getRetExp().typeCheck(e); 
    }
    
    public void AwaitStmt.typeCheck(SemanticErrorList e) {
   	 getGuard().typeCheck(e);
    }

    public void SuspendStmt.typeCheck(SemanticErrorList e) { /* nothing to check */ }
    
    
    public void IfStmt.typeCheck(SemanticErrorList e) {
   	 getCondition().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getCondition(),getBoolType());
   	 getThen().typeCheck(e);
   	 if (hasElse())
   		 getElse().typeCheck(e);

    }
    
    public void WhileStmt.typeCheck(SemanticErrorList e) {
   	 getCondition().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getCondition(),getBoolType());
   	 getBody().typeCheck(e);
    }
    
    public void SkipStmt.typeCheck(SemanticErrorList e) { 
        /* nothing to check */ }

    public void AssertStmt.typeCheck(SemanticErrorList e) {
   	  getCondition().typeCheck(e);
   	  TypeCheckerHelper.assertHasType(e,getCondition(),getBoolType());
    }

    // GUARDS
    public abstract void Guard.typeCheck(SemanticErrorList e);
    public void AndGuard.typeCheck(SemanticErrorList e) { 
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    
    public void ClaimGuard.typeCheck(SemanticErrorList e) { 
   	 getVar().typeCheck(e);
   	 Type t = getVar().getType();
   	 if (!t.isFutureType()) {
   		 e.add(new TypeError(getVar(),ErrorMessage.EXPECTED_FUT_TYPE, t));
   	 }
    }
    public void ExpGuard.typeCheck(SemanticErrorList e) { 
   	 getPureExp().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getPureExp(),getBoolType());
    }
    
    
    
    // EXPRESSIONS
    
    public void Exp.typeCheck(SemanticErrorList e) { }
    
    public void TypeUse.typeCheck(SemanticErrorList e) {
   	 if (getType().isUnknownType()) {
   		 e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
   	 }
    }
    
    public void Call.typeCheck(SemanticErrorList e) {
        Type t = getType();
        if (t.isUnknownType()) {
            e.add(new TypeError(this, ErrorMessage.METHOD_NOT_FOUND, getMethod()));
        } else {
            TypeCheckerHelper.typeCheckEqualParams(e,this,getMethodSig().getParams(),getParams());
        }
    }
    
    public void NewExp.typeCheck(SemanticErrorList e) {
        Decl d = lookup(getClassRef());
        if (d == null || !d.isClass()) {
            e.add(new TypeError(this, ErrorMessage.NO_CLASS_DECL, getClassRef()));
        }
    }
    

    public void GetExp.typeCheck(SemanticErrorList e) {  
   	 if (!getPureExp().getType().isFutureType()) {
   		 e.add(new TypeError(getPureExp(), ErrorMessage.EXPECTED_FUT_TYPE, getPureExp().getType())); 
   	 }
   	 getPureExp().typeCheck(e);
    }
    public void ArithmeticExp.typeCheck(SemanticErrorList e) {  
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getIntType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getIntType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    public void BoolExp.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getBoolType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getBoolType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    public void RelationalExpr.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getIntType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getIntType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }

    public void EqualityExpr.typeCheck(SemanticErrorList e) {
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    
    public void CaseExp.typeCheck(SemanticErrorList e) {  
   	 getExpr().typeCheck(e);
   	 Type et = getExpr().getType();
   	 if (!et.isDataType()) {
   		 e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
   		 return;
   	 }
   	 Type t = null;
   	 for (CaseBranch b : getBranchs()) {
   		 b.typeCheck(e,(DataTypeType) et);
   		 if (t == null) {
   			 t = b.getType();
   		 } else {
   			 Type t2 = b.getType();
   			 if (!t.isSubtypeOf(t2) && !t2.isSubtypeOf(t)) {
   				 e.add(new TypeError(this,ErrorMessage.BRANCH_INCOMPARABLE_TYPE,t,t2));
   			 } else {
   				 if (t.isSubtypeOf(t2))
   					 t = t2;
   			 }
   		 }
   	 }
    } 
    
    public void CaseBranch.typeCheck(SemanticErrorList e, DataTypeType t) {
   	     getLeft().typeCheck(e,t);
   	     getRight().typeCheck(e);
    }
    
    public void FnApp.typeCheck(SemanticErrorList e) {
        Decl d = getDecl();
        if (!d.isFunction()) {
            e.add(new TypeError(this,ErrorMessage.FUNCTION_NOT_RESOLVABLE,getName()));
        } else {
      	   if (d instanceof ParametricFunctionDecl) {
      	   	TypeCheckerHelper.typeCheckMatchingParams(e,this,((ParametricFunctionDecl)d),getParams());
      	   } else {
      	   	TypeCheckerHelper.typeCheckEqualParams(e,this,((FunctionDecl)d).getParams(),getParams());
      	   }
        }
    }
    
    public void DataConstructorExp.typeCheck(SemanticErrorList e) {
   	 DataConstructor c = getDecl();
   	 if (c == null) {
   		 e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
   	 } else {
    	   if (c.getDecl() instanceof ParametricDataTypeDecl) {
   	   	TypeCheckerHelper.typeCheckMatchingParams(e,this,c,getParams());
   	   } else {
    	     TypeCheckerHelper.typeCheckEqualDataTypeUses(e,this,c.getConstructorArgs(),getParams());
   	   }
   	 }
   	 
    }
    public void LetExp.typeCheck(SemanticErrorList e) {  
   	 getVar().typeCheck(e);
   	 getVal().typeCheck(e);
   	 getExp().typeCheck(e);
		 TypeCheckerHelper.checkAssignment(e,this,getVar().getAccess().getType(),getVal());
   	 
   	 
    }

    public void MinusExp.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getOperand(),getIntType());
       getOperand().typeCheck(e);
    }

    public void NegExp.typeCheck(SemanticErrorList e) {
   	 TypeCheckerHelper.assertHasType(e,getOperand(),getBoolType());
       getOperand().typeCheck(e);
    }
    
    
    // PATTERNS
    
    public void Pattern.typeCheck(SemanticErrorList e, DataTypeType t) {  }
    public void ConstructorPattern.typeCheck(SemanticErrorList e, DataTypeType t) { 
   	 DataConstructor c = lookupDataConstructor(getConstructor());
   	 if (c == null) {
   		 e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
   		 return;
   	 }
   	 if (c.getNumConstructorArg() != this.getNumParam()) {
   		 e.add(new TypeError(this,ErrorMessage.WRONG_NUMBER_OF_ARGS,c.getNumConstructorArg(),this.getNumParam()));
   		 return;
   	 }
   	 for (int i = 0; i < getNumParam(); i++) {
   		 Type argType = c.getConstructorArg(i).getType();
   		 Pattern p = getParam(i);
   		 if (argType instanceof DataTypeType) {
   			 p.typeCheck(e,(DataTypeType) argType);
   			 if (!p.getType().isSubtypeOf(argType)) {
   				 e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,argType,p.getType()));
   			 }
   		 }
   	 }
    }
    
    
}
