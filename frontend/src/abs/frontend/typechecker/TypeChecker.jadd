import abs.common.*;

import abs.frontend.analyser.ErrorMessage;
import abs.frontend.analyser.TypeError;
import abs.frontend.typechecker.*;

import abs.frontend.typechecker.TypeCheckerHelper;

import java.util.HashMap;


aspect TypeChecker {
    
    syn lazy boolean Model.hasTypeErrors() = !typeCheck().isEmpty();
    
    syn lazy SemanticErrorList Model.typeCheck() {
        SemanticErrorList res = new SemanticErrorList();
        try {
        	typeCheck(res);
        } catch (TypeCheckerException e) {
        	res.add(e.getTypeError());
        }
        return res;
    }
    
    public void Model.typeCheck(SemanticErrorList e) {
        for (CompilationUnit u : getCompilationUnits()) {
            u.typeCheck(e);
        }
    }

    public void ModuleDecl.typeCheck(SemanticErrorList e) {
    	for (Import i : getImports()) {
    	   i.typeCheck(e);
    	}

        for (Export ex : getExports()) {
    	  ex.typeCheck(e);
    	}
    
	    TypeCheckerHelper.checkForDuplicateDecls(this,e);
    
        for (Decl d : getDecls()) {
            d.typeCheck(e);
        }
        
        if (hasBlock()) {
            getBlock().typeCheck(e);
        }
    }
    
    public void CompilationUnit.typeCheck(SemanticErrorList e) {
        for (ModuleDecl d : getModuleDecls()) {
            d.typeCheck(e);
        }
    }
    
    
    public abstract void Import.typeCheck(SemanticErrorList e);

    public void NamedImport.typeCheck(SemanticErrorList e) {
    	
    	for (Name name : getNames()) {
    		if (name.isSimple()) {
    			e.add(new TypeError(this, ErrorMessage.ONLY_QUALIFIED_NAMES_ALLOWED, name.getName()));
    			continue;
    		}

	    	ModuleDecl d = lookupModule(name.getModuleName());
    		if (d == null) {
    			e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, name.getModuleName()));
    			continue;
    		}
    		
   			if (!d.exportsName(name.getSimpleName())) {
   				e.add(new TypeError(this, ErrorMessage.NAME_NOT_EXPORTED_BY_MODULE, name.getSimpleName(), name.getModuleName()));
   			}
    	}
    }
    
    public void StarImport.typeCheck(SemanticErrorList e) {
    	ModuleDecl d = lookupModule(getModuleName());
    	if (d == null) {
    		e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName()));
    	}
    }

    public void FromImport.typeCheck(SemanticErrorList e) {
    	ModuleDecl d = lookupModule(getModuleName());
    	if (d == null) {
    		e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName()));
    		return;
    	}
    	
    	for (Name name : getNames()) {
    		if (!name.isSimple()) {
    			e.add(new TypeError(this, ErrorMessage.ONLY_UNQUALIFIED_NAMES_ALLOWED, name.getName()));
    		} else {
    			if (!d.exportsName(name.getName())) {
    				e.add(new TypeError(this, ErrorMessage.NAME_NOT_EXPORTED_BY_MODULE, name.getName(), getModuleName()));
    			}
    		}
    	}
    }

    public abstract void Export.typeCheck(SemanticErrorList e);

    public void NamedExport.typeCheck(SemanticErrorList e) {
   		ModuleDecl mod = getModuleDecl();
    	for (Name name: getNames()) {
    	    String s = name.getName();
  	    if (!mod.isVisible(s)) {
    		e.add(new TypeError(this, ErrorMessage.NAME_NOT_RESOLVABLE, s));
    	    }
    	}
    }

    public void FromExport.typeCheck(SemanticErrorList e) {
    	ModuleDecl d = lookupModule(getModuleName());
    	if (d == null) {
    		e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName()));
    		return;
    	}

   		ModuleDecl mod = getModuleDecl();
    	for (Name name: getNames()) {
    		String s = d.getName()+"."+name.getName();
    		if (!mod.isVisible(s)) {
    			e.add(new TypeError(this, ErrorMessage.NAME_NOT_RESOLVABLE, s));
    		}
    	}
    }

    public void StarExport.typeCheck(SemanticErrorList e) {
    	if (hasModuleName()) {
    		ModuleDecl d = lookupModule(getModuleName().getName());
    		if (d == null) {
    			e.add(new TypeError(this, ErrorMessage.MODULE_NOT_RESOLVABLE, getModuleName().getName()));
    			return;
    		}
    	}
    }
    
    // DECLS
    public void InterfaceDecl.addAllMethodSigs(HashMap<String, MethodSig> sigs) {
        for (InterfaceTypeUse u : getExtendedInterfaceUses()) {
            Decl d = u.getDecl();
            if (d.isInterface()) {
                InterfaceDecl id = (InterfaceDecl) d;
                id.addAllMethodSigs(sigs);
            }    
        }
        
        for (MethodSig s : getBodys()) {
            sigs.put(s.getName(),s);
        }
    }
    
    public void ClassDecl.addAllMethodSigs(HashMap<String, MethodSig> sigs) {
        for (InterfaceTypeUse u : getImplementedInterfaceUses()) {
            Decl d = u.getDecl();
            if (d.isInterface()) {
                InterfaceDecl id = (InterfaceDecl) d;
                id.addAllMethodSigs(sigs);
            }
        }
    }
    
    public abstract void Decl.typeCheck(SemanticErrorList e);  
    
    public void ClassDecl.typeCheck(SemanticErrorList e) {
      Set<String> fields = new HashSet<String>();
      for (ParamDecl d : getParams()) {
          d.typeCheck(e);
          if (fields.contains(d.getName())) {
              e.add(new TypeError(d, ErrorMessage.DUPLICATE_FIELD_NAME, d.getName()));
		  } else { 
		  	  fields.add(d.getName());
		  }          
      }
      
      for (InterfaceTypeUse i : getImplementedInterfaceUses()) {
      	 i.typeCheck(e);
      }
      
      for (FieldDecl f : getFields()) {
   		  f.typeCheck(e);
   		  if (fields.contains(f.getName())) {
              e.add(new TypeError(f, ErrorMessage.DUPLICATE_FIELD_NAME, f.getName()));
          } else {
              fields.add(f.getName());
          }
   	  }

      if (hasInitBlock()) {
          getInitBlock().typeCheck(e);
      }
      
      HashMap<String, MethodSig> sigs = new HashMap<String, MethodSig>();
      addAllMethodSigs(sigs);  
      
      HashMap<String, MethodImpl> methodImpls = new HashMap<String, MethodImpl>(); 
      
   	  for (MethodImpl m : getMethods()) {
   		  m.typeCheck(e);
   		  String name = m.getMethodSig().getName();
   		  if (methodImpls.containsKey(name)) {
              e.add(new TypeError(m, ErrorMessage.DUPLICATE_METHOD_NAME, name));
   		  } else {
          	methodImpls.put(name,m);
          }
   		  if (sigs.containsKey(name)) {
   		      MethodSig s = sigs.get(name);
   		      MethodSig ms = m.getMethodSig();
   		      InterfaceDecl d = (InterfaceDecl) s.getParent().getParent();
   		      if (s.getNumParam() != ms.getNumParam()) {
   		          e.add(new TypeError(m,ErrorMessage.METHOD_IMPL_WRONG_NUM_PARAMS, name, d.getName(), ""+s.getNumParam(), ""+ms.getNumParam()));
   		      } else {
   		          for (int i = 0; i < s.getNumParam(); i++) {
   		              Type texpected = s.getParam(i).getType();
   		              Type t = ms.getParam(i).getType();
   		              if (!texpected.equals(t)) {
   		                  e.add(new TypeError(m,ErrorMessage.METHOD_IMPL_WRONG_PARAM_TYPE, 
   		                        ms.getParam(i).getName(), name, d.getName(), 
   		                        texpected.toString(), t.toString()));
   		              }
   		          }
   		      }
   		      
   		      Type expectedReturnType = s.getReturnType().getType();
   		      Type actualReturnType = ms.getReturnType().getType(); 
   		      if (!expectedReturnType.equals(actualReturnType)) {
                  e.add(new TypeError(m,ErrorMessage.METHOD_IMPL_WRONG_RETURN_TYPE, 
                          name, d.getName(),
                          expectedReturnType.toString(), actualReturnType.toString()));
   		          
   		      }
   		  }
   	  }
   	  
   	  for (MethodSig s : sigs.values()) {
   	      if (!methodImpls.containsKey(s.getName())) {
             InterfaceDecl d = (InterfaceDecl) s.getParent().getParent();
             e.add(new TypeError(this, ErrorMessage.METHOD_NOT_IMPLEMENTED, s.getName(), d.getName(), getName()));              
   	      }
   	  }
   	  
    }

    public void DeltaDecl.typeCheck(SemanticErrorList e) {
        // TODO type-checking goes here
    }

    public void FunctionDecl.typeCheck(SemanticErrorList e) {
        TypeCheckerHelper.typeCheckParamList(e,getParams());
        getTypeUse().typeCheck(e);
        if (getFunctionDef() instanceof ExpFunctionDef) {
            // built-in functions are assumed type-correct.
            ExpFunctionDef def = (ExpFunctionDef)getFunctionDef();
            def.getRhs().typeCheck(e);
            TypeCheckerHelper.checkAssignment(e,this,getTypeUse().getType(), def.getRhs());
        }
    }
    
    public void InterfaceDecl.typeCheck(SemanticErrorList e) {
        HashMap<String, MethodSig> names = new HashMap<String, MethodSig>();
        for (MethodSig s : getBodys()) {
            if (names.containsKey(s.getName())) {
                e.add(new TypeError(s, ErrorMessage.DUPLICATE_METHOD_NAME, s.getName()));
            } else {
                names.put(s.getName(),s);
            }
            s.typeCheck(e);
        }
        
        for (InterfaceTypeUse u : getExtendedInterfaceUses()) {
            Decl d = u.getDecl();
            if (!d.isInterface()) {
                e.add(new TypeError(u, ErrorMessage.ONLY_INTERFACE_EXTEND, d.getName()));
            } else {
                InterfaceDecl id = (InterfaceDecl) d;
                for (MethodSig s : id.getBodys()) {
                    if (names.containsKey(s.getName())) {
                        e.add(new TypeError(names.get(s.getName()), ErrorMessage.NO_METHOD_OVERRIDE, s.getName(), id.getName()));
                    }
                }
            }
        }
    }
    
    public void MethodSig.typeCheck(SemanticErrorList e) {
        getReturnType().typeCheck(e);
        TypeCheckerHelper.typeCheckParamList(e,getParams());
    }
     
    public void DataTypeDecl.typeCheck(SemanticErrorList e) {
        HashSet<String> names = new HashSet<String>();
        for (DataConstructor c : getDataConstructors()) {
            c.typeCheck(e);
            if (names.contains(c.getName())) {
                e.add(new TypeError(c, ErrorMessage.DUPLICATE_CONSTRUCTOR, c.getName()));
            } else {
                names.add(c.getName());
            }
        }
    }
    
    public void DataConstructor.typeCheck(SemanticErrorList e) {
        for (DataTypeUse d : getConstructorArgs()) {
            d.typeCheck(e);
        }
    }
    
    public void TypeSynDecl.typeCheck(SemanticErrorList e) {
        getValue().typeCheck(e);
    }
    
    public void TypeParameterDecl.typeCheck(SemanticErrorList e) {
        /* nothing to check */ }
    
    public void UnknownDecl.typeCheck(SemanticErrorList e) { 
        /* nothing to check */ }
    
    
    public void Block.typeCheck(SemanticErrorList e) {
        for (VarDecl v : getVars()) {
            v.typeCheck(e);
        }
        
        for (Stmt s : getStmts()) {
            s.typeCheck(e);
        }
    }
    
    public void MethodImpl.typeCheck(SemanticErrorList e) {
   	 Block b = getBlock();
   	 MethodSig sig = getMethodSig();
   	 int nerrors = e.size();
   	 sig.typeCheck(e);
   	 b.typeCheck(e);

     // skip other checks if already errors have occurred
	 //if (e.size() > nerrors)
	 	//return;
	 	
   	 Type lastType = getModel().getUnitType();
   	 ASTNode<?> errorNode = this;
   	 if (b.getNumStmt() > 0) {
   	 	 Stmt lastStmt = b.getStmt(b.getNumStmt()-1); 
   		 lastType = lastStmt.getType();
   		 
   		 // otherwise check is already done in ReturnStmt
   		 if (lastStmt instanceof ReturnStmt)
   		 	return;
   		 errorNode = lastStmt;
   	 }
   	 
   	 if (!lastType.isAssignable(sig.getReturnType().getType())) {
   		 e.add(new TypeError(errorNode,ErrorMessage.CANNOT_ASSIGN,lastType,sig.getReturnType().getType()));
   	 }
   	 
    }

    public void VarDecl.typeCheck(SemanticErrorList e) { 
   	 getAccess().typeCheck(e);

   	 Type t = getAccess().getType();
   	 if (hasInitExp()) {
   		 TypeCheckerHelper.checkAssignment(e,this,t,getInitExp());
   		 getInitExp().typeCheck(e);
   		 if (getInitExp().hasSideEffects()) {
   		     e.add(new TypeError(this, ErrorMessage.VAR_INIT_WITH_SIDE_EFFECTS, new String[0]));
   		 }
   	 } else {
   		 if (!t.isReferenceType() && !t.isFutureType()) {
 			 e.add(new TypeError(this, ErrorMessage.VAR_INIT_REQUIRED, new String[0]));
       		 }
   	 }
    }

    public void FieldDecl.typeCheck(SemanticErrorList e) { 
        getAccess().typeCheck(e);

        Type t = getAccess().getType();
        if (hasInitExp()) {
                TypeCheckerHelper.checkAssignment(e,this,t,getInitExp());
                getInitExp().typeCheck(e);
        } else {
                if (!t.isReferenceType() && !t.isFutureType()) {
                    e.add(new TypeError(this, ErrorMessage.FIELD_INIT_REQUIRED, new String[0]));
                }
        }
   }
    
    public void ParamDecl.typeCheck(SemanticErrorList e) {
   	 	getAccess().typeCheck(e);
    }
    
    // STMTS
    
    public abstract void Stmt.typeCheck(SemanticErrorList e);
    public void ExpressionStmt.typeCheck(SemanticErrorList e) {
   	   getExp().typeCheck(e);
    }
    
    public void VarDeclStmt.typeCheck(SemanticErrorList e) {
       getVarDecl().typeCheck(e); 
    }
    
    public void AssignStmt.typeCheck(SemanticErrorList e) {
   	 Type rht = getValue().getType();
   	 Type lht = getVar().getType();
   	 	
     int nerrors = e.size();   	 	
	 getValue().typeCheck(e);
	 getVar().typeCheck(e);

     if (e.size() > nerrors)
     	return;

	 if (!rht.isAssignable(lht)) {
		 e.add(new TypeError(this,ErrorMessage.CANNOT_ASSIGN,rht,lht));
	 }
    }
    
    public void ReturnStmt.typeCheck(SemanticErrorList e) {
   	 MethodImpl m = getContextMethod();
   	 Type lht = getModel().getUnitType();
   	 Block block = getContextBlock();

   	 if (m != null) {
   	     lht = m.getMethodSig().getReturnType().getType();
   	     block = m.getBlock();
   	 }
   	 
         Type rht = getRetExp().getType();
         if (!rht.isAssignable(lht)) {
             e.add(new TypeError(this,ErrorMessage.CANNOT_ASSIGN,rht,lht));
         }
   		 
   	 getRetExp().typeCheck(e);
   	 
   	 Stmt lastStmt = block.getStmt(block.getNumStmt()-1);
   	 if (lastStmt != this) {
   	     e.add(new TypeError(this, ErrorMessage.RETURN_STMT_MUST_BE_LAST, new String[0]));
   	 }
    }
    
    public void AwaitStmt.typeCheck(SemanticErrorList e) {
   	 getGuard().typeCheck(e);
    }

    public void SuspendStmt.typeCheck(SemanticErrorList e) { /* nothing to check */ }
    
    
    public void IfStmt.typeCheck(SemanticErrorList e) {
   	 getCondition().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getCondition(),getModel().getBoolType());
   	 getThen().typeCheck(e);
   	 if (hasElse())
   		 getElse().typeCheck(e);

    }
    
    public void WhileStmt.typeCheck(SemanticErrorList e) {
   	 getCondition().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getCondition(),getModel().getBoolType());
   	 getBody().typeCheck(e);
    }
    
    public void SkipStmt.typeCheck(SemanticErrorList e) { 
        /* nothing to check */ }

    public void AssertStmt.typeCheck(SemanticErrorList e) {
   	  getCondition().typeCheck(e);
   	  TypeCheckerHelper.assertHasType(e,getCondition(),getModel().getBoolType());
    }

    // GUARDS
    public abstract void Guard.typeCheck(SemanticErrorList e);
    public void AndGuard.typeCheck(SemanticErrorList e) { 
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    
    public void ClaimGuard.typeCheck(SemanticErrorList e) { 
   	 getVar().typeCheck(e);
   	 Type t = getVar().getType();
   	 if (!t.isFutureType()) {
   		 e.add(new TypeError(getVar(),ErrorMessage.EXPECTED_FUT_TYPE, t));
   	 }
    }
    public void ExpGuard.typeCheck(SemanticErrorList e) { 
   	 getPureExp().typeCheck(e);
   	 TypeCheckerHelper.assertHasType(e,getPureExp(),getModel().getBoolType());
    }
    
    
    
    // EXPRESSIONS
    
    public void Exp.typeCheck(SemanticErrorList e) { }
    
    public void TypeUse.typeCheck(SemanticErrorList e) {
   	 if (getType().isUnknownType()) {
   		 e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
   	 }
    }

    public void DataTypeUse.typeCheck(SemanticErrorList e) {
        if (getType().isUnknownType()) {
            e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
            return;
        }

        if (! (getType() instanceof DataTypeType))
            return;
        DataTypeType type = (DataTypeType) getType();
        if (type.getDecl() instanceof ParametricDataTypeDecl) {
            int expected = ((ParametricDataTypeDecl)type.getDecl()).getNumTypeParameter();
            if (expected != type.numTypeArgs()) {
                e.add(new TypeError(this,ErrorMessage.WRONG_NUMBER_OF_TYPE_ARGS,type.toString(),""+expected,"0"));
            } else {
            	if (this instanceof ParametricDataTypeUse) {
            		for (DataTypeUse du : ((ParametricDataTypeUse)this).getParams()) {
            			du.typeCheck(e);
            		}
            	} 
            }
        }
    }

    public void UnresolvedTypeUse.typeCheck(SemanticErrorList e) {
        e.add(new TypeError(this,ErrorMessage.TYPE_NOT_RESOLVABLE,getName()));
    }
    
    public void VarUse.typeCheck(SemanticErrorList e) {
    	if (getType().isUnknownType()) {
	        e.add(new TypeError(this,ErrorMessage.NAME_NOT_RESOLVABLE,getName()));
    	}
    	
    }
    
    public void Call.typeCheck(SemanticErrorList e) {
        Type t = getType();
        if (t.isUnknownType() || getMethodSig() == null) {
            e.add(new TypeError(this, ErrorMessage.METHOD_NOT_FOUND, getMethod()));
        } else {
            TypeCheckerHelper.typeCheckEqualParams(e,this,getMethodSig().getParams(),getParams());
        }
    }
    
    public void NewExp.typeCheck(SemanticErrorList e) {
        Decl d = lookup(new KindedName(Kind.CLASS,getClassName()));
        if (d == null || !d.isClass()) {
            e.add(new TypeError(this, ErrorMessage.NO_CLASS_DECL, getClassName()));
        } else {
            ClassDecl cd = (ClassDecl) d;
            TypeCheckerHelper.typeCheckEqualParams(e,this,cd.getParams(),getParams());
        }
    }
    

    public void GetExp.typeCheck(SemanticErrorList e) {  
   	 if (!getPureExp().getType().isFutureType()) {
   		 e.add(new TypeError(getPureExp(), ErrorMessage.EXPECTED_FUT_TYPE, getPureExp().getType())); 
   	 }
   	 getPureExp().typeCheck(e);
    }
    public void AddAddExp.typeCheck(SemanticErrorList e) {
        // Special case: can also "add" strings.
        if (!getLeft().getType().isStringType() && !getLeft().getType().isIntType()) {
            e.add(new TypeError(this, ErrorMessage.EXPECTED_ADDABLE_TYPE, getLeft().getType()));
        }
        if (!getRight().getType().isStringType() && !getRight().getType().isIntType()) {
            e.add(new TypeError(this, ErrorMessage.EXPECTED_ADDABLE_TYPE, getRight().getType()));
        }
        getLeft().typeCheck(e);
        getRight().typeCheck(e);
    }
    public void ArithmeticExp.typeCheck(SemanticErrorList e) {  
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getModel().getIntType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getModel().getIntType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    public void BoolExp.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getModel().getBoolType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getModel().getBoolType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }
    public void RelationalExpr.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getLeft(),getModel().getIntType());
   	 TypeCheckerHelper.assertHasType(e,getRight(),getModel().getIntType());
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
    }

    public void EqualityExpr.typeCheck(SemanticErrorList e) {
   	 getLeft().typeCheck(e);
   	 getRight().typeCheck(e);
         Type tl = getLeft().getType();
         Type tr = getRight().getType();
         if (!tl.isAssignable(tr) && !tr.isAssignable(tl)) {
             e.add(new TypeError(this, ErrorMessage.EQUALITY_INCOMPARABLE_TYPE, tl, tr));
         }
    }
    
    public void CaseExp.typeCheck(SemanticErrorList e) {  
   	 getExpr().typeCheck(e);
   	 Type et = getExpr().getType();
   	 if (!et.isDataType()) {
   		 e.add(new TypeError(getExpr(),ErrorMessage.CASE_NO_DATATYPE,et));
   		 return;
   	 }
   	 Type t = null;
   	 for (CaseBranch b : getBranchs()) {
   		 b.typeCheck(e,(DataTypeType) et);
   		 if (t == null) {
   			 t = b.getType();
   		 } else {
   			 Type t2 = b.getType();
   			 if (!t.isAssignable(t2) && !t2.isAssignable(t)) {
   				 e.add(new TypeError(this,ErrorMessage.BRANCH_INCOMPARABLE_TYPE,t,t2));
   			 } else {
   				 if (t.isAssignable(t2))
   					 t = t2;
   			 }
   		 }
   	 }
    } 
    
    public void CaseBranch.typeCheck(SemanticErrorList e, DataTypeType t) {
   	     getLeft().typeCheck(e,t);
   	     getRight().typeCheck(e);
    }
    
    public void FnApp.typeCheck(SemanticErrorList e) {
        Decl d = getDecl();
        if (!d.isFunction()) {
            e.add(new TypeError(this,ErrorMessage.FUNCTION_NOT_RESOLVABLE,getName()));
        } else {
      	   if (d instanceof ParametricFunctionDecl) {
      	   	TypeCheckerHelper.typeCheckMatchingParams(e,this,((ParametricFunctionDecl)d),getParams());
      	   } else {
      	   	TypeCheckerHelper.typeCheckEqualParams(e,this,((FunctionDecl)d).getParams(),getParams());
      	   }
        }
    }
    
    public void DataConstructorExp.typeCheck(SemanticErrorList e) {
   	 Decl decl = getDecl();
   	 if (decl == null || !(decl instanceof DataConstructor)) {
   		 e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
   	 } else {
   	 	DataConstructor c = (DataConstructor) decl;
    	   if (c.getDataTypeDecl() instanceof ParametricDataTypeDecl) {
   	   	TypeCheckerHelper.typeCheckMatchingParams(e,this,c,getParams());
   	   } else {
    	     TypeCheckerHelper.typeCheckEqualDataTypeUses(e,this,c.getConstructorArgs(),getParams());
   	   }
   	 }
   	 
    }
    public void LetExp.typeCheck(SemanticErrorList e) {  
   	 getVar().typeCheck(e);
   	 getVal().typeCheck(e);
   	 getExp().typeCheck(e);
		 TypeCheckerHelper.checkAssignment(e,this,getVar().getAccess().getType(),getVal());
   	 
   	 
    }

    public void MinusExp.typeCheck(SemanticErrorList e) { 
   	 TypeCheckerHelper.assertHasType(e,getOperand(),getModel().getIntType());
       getOperand().typeCheck(e);
    }

    public void NegExp.typeCheck(SemanticErrorList e) {
   	 TypeCheckerHelper.assertHasType(e,getOperand(),getModel().getBoolType());
       getOperand().typeCheck(e);
    }
    
    
    // PATTERNS
    
    public void Pattern.typeCheck(SemanticErrorList e, Type t) {  }
    
    public void PatternVarUse.typeCheck(SemanticErrorList e, Type t) {
        if (!getType().equals(t)) {
            e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,getType(),t));
        }
    }
    
    public void LiteralPattern.typeCheck(SemanticErrorList e, Type t) {
        if (!getType().equals(t)) {
            e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,getType(),t));
        }
    }
    
    public void ConstructorPattern.typeCheck(SemanticErrorList e, Type t) {
   	 Decl decl = lookup(new KindedName(Kind.DATA_CONSTRUCTOR,getConstructor()));
   	 if (decl == null || !(decl instanceof DataConstructor)) {
   		 e.add(new SemanticError(this,ErrorMessage.CONSTRUCTOR_NOT_RESOLVABLE,getConstructor()));
   		 return;
   	 }
	DataConstructor c = (DataConstructor) decl;
  	 if (c.getNumConstructorArg() != this.getNumParam()) {
   		 e.add(new TypeError(this,ErrorMessage.WRONG_NUMBER_OF_ARGS,c.getNumConstructorArg(),this.getNumParam()));
   		 return;
   	 }


     Type myType = getType();
     
     if (myType == null || !(myType instanceof DataTypeType))
         return;
         
  	 if (! (t instanceof DataTypeType)) {
         e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,myType,t));
         return;
     }
  	 
	 DataTypeType myDType = (DataTypeType) myType;          
  	 DataTypeType otherType = (DataTypeType) t;
  	 if (!myDType.getDecl().equals(otherType.getDecl())) {
         e.add(new TypeError(this,ErrorMessage.TYPE_MISMATCH,myDType,t));
         return;
  	 }
     
  	 TypeCheckerHelper.typeCheckMatchingParamsPattern(e,this,c,getParams());
    }
    
    
}
