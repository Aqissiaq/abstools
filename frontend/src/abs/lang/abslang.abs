module ABS.StdLib;
export *;

data Unit = Unit;               // builtin  
data String;                    // builtin  
data Int;                       // builtin
data Bool = True | False;       // builtin
data Fut<A>;                    // builtin

def Bool and(Bool a, Bool b) = a && b;
def Bool not(Bool a) = ~a;

def Int max(Int a, Int b) = 
    case a > b { True => a; False => b; };
    
def Int abs(Int x) = 
    case x > 0 { True => x; False => -x; };

data Maybe<A> = Nothing | Just(A);

def A fromJust<A>(Maybe<A> a) = case a { Just(j) => j; };
def Bool isJust<A>(Maybe<A> a) = 
    case a { Just(j) => True; Nothing => False; };

data Either<A, B> = Left(A) | Right(B);

def A left<A,B>(Either<A, B> val) = 
    case val { Left(x) => x; };
    
def B right<A,B>(Either<A, B> val) = 
    case val { Right(x) => x; };
    
def Bool isLeft<A,B>(Either<A, B> val) = 
    case val { Left(x) => True; _ => False; };
    
def Bool isRight<A,B>(Either<A, B> val) = ~isLeft(val);


data Pair<A, B> = Pair(A, B); 

def A fst<A, B>(Pair<A, B> p) = case p { Pair(s, f) => s; };
def B snd<A, B>(Pair<A, B> p) = case p { Pair(s, f) => f; };


data Triple<A, B, C> = Triple(A, B, C); 

def A fstT<A, B, C>(Triple<A, B, C> p) = 
    case p { Triple(s, f, g) => s; };
    
def B sndT<A, B, C>(Triple<A, B, C> p) = 
    case p { Triple(s, f, g) => f; };
    
def C trd<A, B, C>(Triple<A, B, C> p) = 
    case p { Triple(s, f, g) => g; };

// Sets
data Set<A> = EmptySet | Insert(A, Set<A>);

// set constructor helper
def Set<A> set<A>(List<A> l) = 
    case l { 
       Nil => EmptySet; 
       Cons(x,xs) => Insert(x,set(xs)); 
    };

/**
 * Returns True if set 'ss' contains element 'e', False otherwise.
 */
def Bool contains<A>(Set<A> ss, A e) =
  case ss {
    EmptySet => False ;
    Insert(e, _) => True;
    Insert(_, xs) => contains(xs, e);
  };
  
/**
 * Returns True if set 'xs' is empty, False  otherwise.
 */
def Bool emptySet<A>(Set<A> xs) = (xs == EmptySet); 

/**
 * Returns the size of set 'xs'.
 */
def Int size<A>(Set<A> xs) = 
   case xs { 
      EmptySet => 0 ; 
      Insert(s, ss) => 1 + size(ss); 
   };

def Set<A> union<A>(Set<A> set1, Set<A> set2) =
   case set1 {
      EmptySet => set2;
      Insert(a, s) => union(s,insertElement(set2,a));
   }; 

/**
 * Returns a set with all elements of set 'xs' plus element 'e'.
 * Returns 'xs' if 'xs' already containts 'e'.
 */
def Set<A> insertElement<A>(Set<A> xs, A e) =
  case contains(xs, e) {
    True => xs;
    False => Insert(e, xs);
  };

/**
 * Returns a set with all elements of set 'xs' except element 'e'.
 */
def Set<A> remove<A>(Set<A> xs, A e) = 
  case xs {
     EmptySet => EmptySet ;
     Insert(e, ss) => ss;
     Insert(s, ss) => Insert(s,remove(ss,e));
  };

// checks whether the input set has more elements to be iterated.
def Bool hasNext<A>(Set<A> s) = ~ emptySet(s); 

// Partial function to iterate over a set.
def Pair<Set<A>,A> next<A>(Set<A> s) = 
   case s { 
      Insert(e, set2) => Pair(set2,e); 
   };

// Lists
data List<A> = Nil | Cons(A, List<A>);

def List<A> list<A>(List<A> l) = l; // list constructor helper

/**
 * Returns the length of list 'list'.
 */
def Int length<A>(List<A> list) = 
   case list { 
      Nil => 0 ; 
      Cons(p, l) => 1 + length(l) ; 
   };

/**
 * Returns True if list 'list' is empty, False otherwise.
 */
def Bool isEmpty<A>(List<A> list) = list == Nil;

/**
 * Returns the first element of list 'list'.
 */
def A head<A>(List<A> list) = 
   case list { Cons(p,l) => p ; };

/**
 * Returns a (possibly empty) list containing all elements of 'list'
 * except the first one.
 */
def List<A> tail<A>(List<A> list) = 
   case list { Cons(p,l) => l ; };

/**
 * Returns element 'n' of list 'list'.
 */
def A nth<A>(List<A> list, Int n) = 
  case n { 
    0 => head(list) ; 
    _ => nth(tail(list), n-1); 
  };
  
/**
 * Returns a list where all occurrences of a have been removed
 */
def List<A> without<A>(List<A> list, A a) =
  case list {
     Nil => Nil;
     Cons(a, tail) => without(tail,a);
     Cons(x, tail) => Cons(x, without(tail,a));
  };  
  
/**
 * Returns a list containing all elements of list 'list1'
 * followed by all elements of list 'list2'.
 */
def List<A> concatenate<A>(List<A> list1, List<A> list2) =
  case list1 { 
    Nil => list2 ; 
    Cons(head, tail) =>  Cons(head, concatenate(tail, list2)); 
  };
  
/**
 * Returns a list containing all elements of list 'list' followed by 'p'.
 */
def List<A> appendright<A>(List<A> list, A p) = 
    concatenate(list, Cons(p, Nil));

/**
 * Returns a list containing all elements of 'list' in reverse order.
 */
def List<A> reverse<A>(List<A> list) =
  case list { 
     Cons(hd, tl) => appendright(reverse(tl), hd); 
     Nil => Nil; 
  };
  
/**
 * Returns a list of length 'n' containing 'p' n times.
 */
def List<A> copy<A>(A p, Int n) = 
   case n { 0 => Nil; m => Cons(p,copy(p,m-1)); };




// Maps
data Map<A, B> = EmptyMap | InsertAssoc(Pair<A, B>, Map<A, B>);
 // map constructor helper (does not preserve injectivity)
def Map<A, B> map<A, B>(List<Pair<A, B>> l) =
  case l { 
     Nil => EmptyMap; 
     Cons(hd, tl) => InsertAssoc(hd, map(tl)); 
  };
  
  
def Map<A, B> removeKey<A, B>(Map<A, B> map, A key) = // remove from the map
  case map {
    InsertAssoc(Pair(key, _), m) => m;
    InsertAssoc(pair, tail) => InsertAssoc(pair, removeKey(tail, key));
  };
    

def List<B> values<A, B>(Map<A, B> map) =
  case map {
    EmptyMap => Nil ;
    InsertAssoc(Pair(_, elem), tail) => Cons(elem, values(tail)) ;
  };

/**
 * Returns a set containing all keys of map 'map'.
 */
def Set<A> keys<A, B>(Map<A, B> map) =
  case map { 
    EmptyMap => EmptySet ;
    InsertAssoc(Pair(a, _), tail) => Insert(a, keys(tail)); 
  };
    
/**
 * Returns the value associated with key 'k' in map 'ms'.
 */
def B lookup<A, B>(Map<A, B> ms, A k) = // retrieve from the map
  case ms {
     InsertAssoc(Pair(k, y), _) => y;
     InsertAssoc(_, tm) => lookup(tm, k);
  };
  
/**
 * Returns the value associated with key 'k' in map 'ms', or the value 'd'
 * if 'k' has no entry in 'ms'.
 */
def B lookupDefault<A, B>(Map<A, B> ms, A k, B d) = // retrieve from the map
  case ms {
     InsertAssoc(Pair(k, y), _) => y;
     InsertAssoc(_, tm) => lookupDefault(tm, k, d);
     EmptyMap => d;
  };
  
/**
 * Returns a map with all entries of 'map' plus an entry 'p',
 * which might override but not remove another entry with the same key.
 */
def Map<A, B> insert<A, B>(Map<A, B> map, Pair<A, B> p) = InsertAssoc(p, map);

/**
 * Returns a map with all entries of 'ms' plus an entry mapping 'k' to 'v',
 * minus the first entry already mapping 'k' to a value.
 */  
def Map<A, B> put<A, B>(Map<A, B> ms, A k, B v) =
  case ms {
    EmptyMap => InsertAssoc(Pair(k, v),EmptyMap);
    InsertAssoc(Pair(k, _), ts) => InsertAssoc(Pair(k, v), ts);
    InsertAssoc(p, ts) => InsertAssoc(p, put(ts, k, v));
  };

/**
 * Returns a string with the base-10 textual representation of 'n'.
 */
def String intToString(Int n) =
  case n < 0 {
    True => "-" + intToStringPos(-n);
    False => intToStringPos(n);
  };

def String intToStringPos(Int n) =
  let (Int div) = (n / 10) in
  let (Int res) = (n % 10) in
  case n {
    0 => "0"; 1 => "1"; 2 => "2"; 3 => "3"; 4 => "4";
    5 => "5"; 6 => "6"; 7 => "7"; 8 => "8"; 9 => "9";
    _ => intToStringPos(div) + intToStringPos(res);
  };

/**
 * Returns a substring of string str of the given length starting from start (inclusive)
 * Where the first character has index 0
 * 
 * Example:
 *    substr("abcde",1,3) => "bcd"
 *     
 */
def String substr(String str, Int start, Int length) = builtin;

/**
 * Returns the length of the given string
 */
def Int strlen(String str) = builtin;

/**
 * Returns a random number between 0 (inclusive) and below (exclusive).
 */
def Int random(Int below) = builtin;


// Time and Duration datatypes.

// Time can be an integer value or InfTime.  Duration is aways an
// integer.
// 
// Durations can be added and subtracted from Times, and compared to
// each other.  Times can be compared to each other.
data Time = Time(Int);
def Int currentms() = builtin;
def Time now() = Time(currentms());
def Int timeval(Time t) = case t { Time(v) => v; };

// use this like so:
//   Time t = now(); await timeDifference(now(), t) > 5;
def Int timeDifference(Time t1, Time t2) =
  abs(timeval(t2) - timeval(t1));
def Bool timeLessThan(Time t1, Time t2) =
  timeval(t1) < timeval(t2);

data Duration = Duration(Int) | InfDuration;
def Int durationValue(Duration d) = case d { Duration(x) => x; };
def Bool isDurationInfinite(Duration d) = 
  case d { Duration(_) => False; InfDuration => True; };

def Time addDuration(Time t, Duration d) =
  Time(timeval(t) + durationValue(d));

def Time subtractDuration(Time t, Duration d) =
  Time(timeval(t) - durationValue(d));

def Bool durationLessThan(Duration d1, Duration d2) =
  case d1 {
      Duration(v1) => case d2 {
          Duration(v2) => v1 < v2; 
          InfDuration => False; };
      // If d1 and d2 are infinite, < is not antisymmetric ...
      InfDuration => False;
  };

// negative if no (i.e. infinite) deadline
def Int lowlevelDeadline() = builtin;
def Duration deadline() = 
  case lowlevelDeadline() < 0 {
      True => InfDuration;
      False => Duration(lowlevelDeadline());
  };

def Duration subtractFromDuration(Duration d, Int v) =
  case d {
      InfDuration => InfDuration;
      Duration(x) => Duration(max(x - v, 0));
  };

// Annotation data type to express deadlines:
// [Deadline: Duration(5)] o!m();
type Deadline = Duration;

/**
 * Annotation data type to define the type of annotations
 * currently only TypeAnnotation exists
 */
data Annotation = TypeAnnotation; 
 
[TypeAnnotation]
data LocationType = Far | Near | Somewhere | Infer;
 
/**
 * Can be used to annotated classes and to ensure that
 * classes are always instantiated in the right way.
 * I.e. classes annotated with [COG] must be created by using
 * new cog, class annotated with [Plain] must be created by using
 * just new, without cog.
 */
data ClassKindAnnotation = COG | Plain;

/**
 * Declare local variables to be final
 */
data FinalAnnotation = Final;

/**
 * Declare methods to be atomic, i.e., such methods must not
 * contain scheduling code and also no .get
 */ 
data AtomicityAnnotation = Atomic;

/**
 * Custom schedulers
 */
module ABS.Scheduler;
export *;
import * from ABS.StdLib;

data Scheduler;

// The Process datatype, passed to custom schedulers.
// 
// Pid has no constructor, so this datastructure can't be generated
// within Abs
data Pid;
data Process = Process(Pid pid, String method, Time arrival,
    Duration cost, Duration procdeadline, Time start, Time finish, Bool crit,
    Int value);

def Process defaultscheduler(List<Process> queue) = head(queue);

def Process randomscheduler(List<Process> queue) = nth(queue, random(length(queue)));

/**
 * Foreign language interface (FLI) definitions
 */
module ABS.FLI;
export *;

data FLIAnnotation = Foreign;


/** 
 * Deployment components
 * Used to model aspects of hardware configurations and deployment.
 */
module ABS.DC;
export DCData, DC, DeploymentComponent, thisDC, Cost, URL, CPUCapacity;
import * from ABS.StdLib;

data DCData = URL(String)
            | CPUCapacity(Int);


type Resourcename = String;

// Utility functions.
def Int min(Int x, Int y) = case (x<=y) { True => x ; False => y;};
def Int sum(List<Int> list, Int n) =
  if (n==0) 
  then 0
  else case list { Nil => 0; Cons(head,tail) => head + sum(tail, n-1);};

def Int average(List<Int> list, Int length) = 
          sum(list, min(length(list),length)) / min(length(list),length);

def Resourcename nameFor(DCData dcdata) =
  case dcdata {
      URL(s) => "URL";
      CPUCapacity(_) => "CPU";
  };

def Int contentFor(DCData dcdata) =
  case dcdata {
      URL(s) => 0;
      CPUCapacity(c) => c;
  };

def Map<Resourcename, Int> createDCInternalsMap(Set<DCData> datas) =
  case datas {
      EmptySet => EmptyMap;
      Insert(dcdata, rest) => InsertAssoc(
          Pair(nameFor(dcdata), contentFor(dcdata)), createDCInternalsMap(rest));
      };

def Map<String, Int> createTotals(Set<DCData> datas) =
  case datas {
      EmptySet => EmptyMap;
      Insert(dcdata, rest) => InsertAssoc(Pair(nameFor(dcdata), contentFor(dcdata)), createTotals(rest));
      };

def Map<Resourcename, List<Int>> createDCHistory(Set<DCData> datas) =
  case datas {
      EmptySet => EmptyMap;
      Insert(dcdata, rest) => InsertAssoc(
          Pair(nameFor(dcdata), Nil), createDCHistory(rest));
  };

// Internal function, called by the Maude interpreter: replenish
// resources in 'internalState' to the value given in 'totals'
def Map<Resourcename, Int> updateDCInternalsForTimeAdvance(Map<Resourcename, Int> internalState, Map<Resourcename, Int> totals) =
  case internalState {
      EmptyMap => EmptyMap;
      InsertAssoc(Pair(name, _), rest) => InsertAssoc(Pair(name, lookup(totals, name)), updateDCInternalsForTimeAdvance(rest, totals));
  };

// Internal function, called by the Maude interpreter: update
// 'history' lists for each resource
def Map<Resourcename, List<Int>> updateDCHistoryForTimeAdvance(Map<Resourcename, List<Int>> history, Map<Resourcename, Int> internalState, Map<Resourcename, Int> totals) =
  case internalState {
      EmptyMap => history;
      InsertAssoc(Pair(name, available), rest) =>
          updateDCHistoryForTimeAdvance(put(history, name, Cons(lookup(totals, name) - available, lookupDefault(history, name, Nil))), rest, totals);
  };


interface DeploymentComponent {
    Set<DCData> getConfiguration();
    Int available(Resourcename resourcename);
    Int load(Resourcename resourcename, Int periods);
    Int total(Resourcename resourcename);
}

class DeploymentComponent (String description, Set<DCData> configuration)
implements DeploymentComponent {
    Time creationTime = now();
    Map<String, List<Int>> history = createDCHistory(configuration);
    Map<String, Int> totals = createTotals(configuration);
    Map<String, Int> internalState = createDCInternalsMap(configuration);
    Bool initialized = False;
    {
        this.initialized = True;
    }
    Set<DCData> getConfiguration() { return configuration; }

    Int available(String resourcename) {
        return lookupDefault(internalState, resourcename, 0);
    }
    Int load(String resourcename, Int periods) {
        return (average(lookupDefault(history, resourcename, Nil), periods) * 100) / lookupDefault(totals, resourcename, 1);
    }
    Int total(Resourcename resourcename) {
        return lookupDefault(totals, resourcename, 0);
    }

}

// abbreviation for [DC: foo] annotations
type DC = DeploymentComponent;

def DeploymentComponent thisDC() = builtin;

// Annotation for method definitions: runtime cost specification
type Cost = Duration;
