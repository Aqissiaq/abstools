// -*- mode: java; tab-width: 4; -*-
import java.io.PrintStream;

aspect GenerateMaude {

    // New rule!  Everyone can expect sufficient whitespace to be set
    // up, but has to leave whitespace at the end if needed.

    public void Model.generateMaude(PrintStream stream, String module) {
        boolean hasClasses = false;
        stream.println("in abs-interpreter\n\nmod MODEL is\nprotecting "
                       + module + " .\n");
        for (Decl decl : getDecls()) {
            if (decl instanceof FunctionDecl)
                decl.generateMaude(stream);
        }
        stream.println("op classes : -> Configuration .");
        stream.print("eq classes =");
        for (Decl decl : getDecls()) {
            if (decl instanceof ClassDecl) {
                hasClasses = true;
                decl.generateMaude(stream);
            }
        }
        if (hasMainBlock()) getMainBlock().generateMaude(stream);
        stream.println(".");
        stream.println("\n--- Start the model with 'rew start .'");
        stream.println("op start : -> State .");
        stream.println("eq start = main(classes, \".Start\", emp) .");
        stream.println("\nendm");
    }

	abstract public void Decl.generateMaude(PrintStream stream);

    public void DataConstructor.generateMaude(PrintStream stream) { }

	public void InterfaceDecl.generateMaude(PrintStream stream) {
		stream.println("*** Interface code ...");
	}

	public void DataTypeDecl.generateMaude(PrintStream stream) {
		stream.println("*** Datatype " + getName());
	}

    public void TypeParameterDecl.generateMaude(PrintStream stream) {
        stream.println("*** Type parameter " + getName());
    }

	public void TypeSynDecl.generateMaude(PrintStream stream) {
		stream.println("*** Type synonym: Datatype " + getName());
	}

	
	public void FunctionDecl.generateMaude(PrintStream stream) {
		boolean inList = false;
        if (getFunctionDef() instanceof BuiltinFunctionDef) return;
        stream.print("eq fparams(\"" + getName() + "\") = ");
        if (getNumParam() == 0) {
            stream.println("noVid .");
        } else {
            for (VarOrFieldDecl param : getParams()) {
                if (inList == false) inList = true; else stream.print(", ");
                stream.print("@ \"" + param.getName() + "\" ");
            }
            stream.print(".\n");
        }
		stream.print("eq fdefn(\"" + getName() + "\") = ");
		getFunctionDef().generateMaude(stream);
        stream.println(".");
        stream.println();
	}

    abstract public void FunctionDef.generateMaude(PrintStream stream);
    public void ExpFunctionDef.generateMaude(PrintStream stream) {
        getRhs().generateMaude(stream);
    }
    public void BuiltinFunctionDef.generateMaude(PrintStream stream) {
        stream.println("--- Hey, I didn't expect this to be generated! " + getClass().toString());
    }

    abstract public void Exp.generateMaude(PrintStream stream);

    public void Access.generateMaude(PrintStream stream) {
        stream.println("--- Hey, I didn't expect this to be generated! " + getClass().toString());
    }

    abstract public void Exp.generateMaudeAsStatement(PrintStream stream, String var);
    
    public void PureExp.generateMaudeAsStatement(PrintStream stream, String var)
    {
        stream.print("noStmt");
    }

    public void EffExp.generateMaude(PrintStream stream) {
        stream.println("--- Hey, you used a side-effecting expression as a normal one! " + getClass().toString());
    }
    public void AsyncCall.generateMaudeAsStatement(PrintStream stream, String var)
    {
        boolean inlist = false;
        String effvar = var;
        if (!var.equals("_")) {
            // Invariant of asynchronous calls in an assignment:
            // (potentially null) futures are freed before overwriting
            // the variable's binding.
            stream.print("$free(@ \"" + var + "\"); ");
            stream.print("call(@ \"" + var + "\" ; ");
            getCallee().generateMaude(stream);
            stream.print(" ; \"" + getMethod() + "\" ; ");
            if (getNumParam() == 0) {
                stream.print("emp");
            } else {
                stream.print("(");
                for (PureExp param : getParams()) {
                    if (inlist) stream.print(":: "); else inlist = true;
                    param.generateMaude(stream);
                }
                stream.print(")");
            }
            stream.print(") ");
        } else {
            // Invariant of assignment-less async calls (and synchronous
            // calls): .staticfuture is freed after calling
            // (resp. receiving the value).  Some code duplication here,
            // but it's easier to read than setting up complicated
            // schemes about which variable to call to resp. free before
            // / after the call statement etc.
            stream.print("call(@ \".staticfuture\" ; ");
            getCallee().generateMaude(stream);
            stream.print(" ; \"" + getMethod() + "\" ; ");
            if (getNumParam() == 0) {
                stream.print("emp");
            } else {
                stream.print("(");
                for (PureExp param : getParams()) {
                    if (inlist) stream.print(":: "); else inlist = true;
                    param.generateMaude(stream);
                }
                stream.print(")");
            }
            stream.print(") ");
            stream.print("; $free(@ \".staticfuture\") ");
        }
    }

    public void SyncCall.generateMaudeAsStatement(PrintStream stream, String var)
    {
        boolean inlist = false;
        stream.print("call(@ \".staticfuture\" ; ");
        getCallee().generateMaude(stream);
        stream.print("; \"" + getMethod() + "\" ; ");
        if (getNumParam() == 0) {
            stream.print("emp");
        } else {
            stream.print("(");
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            stream.print(")");
        }
        stream.print(") ; get( @ \".staticfuture\" ; @ \"" + var + "\") ");
        stream.print("; $free(@ \".staticfuture\") ");
    }

    public void GetExp.generateMaudeAsStatement(PrintStream stream, String var)
    {
        stream.print("get(");
        getPureExp().generateMaude(stream);
        stream.print(" ; @ \"" + var + "\") ");        
    }

    public void NewExp.generateMaudeAsStatement(PrintStream stream, String var)
    {
        boolean inlist = false;
        stream.print("new(@ \"" + var + "\" ; \"" + getClassName() + "\" ; ");
        if (getNumParam() == 0) {
            stream.print("emp");
        } else {
            stream.print("(");
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            stream.print(")");
        }
        stream.print(") ");
    }

    abstract public void LiteralExp.generateMaude(PrintStream stream);

    public void StringLiteral.generateMaude(PrintStream stream) {
        stream.print("\"str\"[\"" + getContent() + "\"] ");
    }

    public void IntLiteral.generateMaude(PrintStream stream) {
        stream.print("\"int\"[" + getContent() + "] ");
    }

    syn String Unary.maudePrefixOperator();
    eq MinusExp.maudePrefixOperator() = "--";
    eq NegExp.maudePrefixOperator() = "~";
    public void Unary.generateMaude(PrintStream stream) {
        stream.print("\"" + maudePrefixOperator() + "\"( ");
        getOperand().generateMaude(stream);
        stream.print(") ");
    }

    syn String Binary.maudeInfixOperator();
    eq EqExp.maudeInfixOperator() = "==";
    eq NotEqExp.maudeInfixOperator() = "/=";
    eq AndBoolExp.maudeInfixOperator() = "&&";
    eq OrBoolExp.maudeInfixOperator() = "||";
    eq LTExp.maudeInfixOperator() = "<";
    eq GTExp.maudeInfixOperator() = ">";
    eq LTEQExp.maudeInfixOperator() = "<=";
    eq GTEQExp.maudeInfixOperator() = ">=";
    eq AddAddExp.maudeInfixOperator() = "+";
    eq SubAddExp.maudeInfixOperator() = "-";
    eq MultMultExp.maudeInfixOperator() = "*";
    eq DivMultExp.maudeInfixOperator() = "/";
    eq ModMultExp.maudeInfixOperator() = "%";
    public void Binary.generateMaude(PrintStream stream) {
        stream.print("\"" + maudeInfixOperator() + "\"( ");
        getLeft().generateMaude(stream);
        stream.print(":: ");
        getRight().generateMaude(stream);
        stream.print(") ");
    }

    public void ThisExp.generateMaude(PrintStream stream) {
        stream.print("@ \"this\" ");
    }

    public void NullExp.generateMaude(PrintStream stream) {
        stream.print("null ");
    }

    public void DataConstructorExp.generateMaude(PrintStream stream) {
       boolean inlist = false;
       stream.print("\"" + getConstructor() + "\"[ ");
       if (getNumParam() == 0) {
           stream.print("emp ");
       } else {
           for (PureExp param : getParams()) {
               if (inlist) stream.print(":: "); else inlist = true;
               param.generateMaude(stream);
           }
       }
       stream.print("] ");
    }

    public void VarOrFieldUse.generateMaude(PrintStream stream) {
        stream.println("--- Hey, I didn't expect this to be generated! " + getClass().toString());
    }

	public void VarUse.generateMaude(PrintStream stream) {
        stream.print("@ \"" + getName() + "\" ");
	}

	public void FieldUse.generateMaude(PrintStream stream) {
        stream.print("@@ \"" + getName() + "\" ");
	}

    public void FnApp.generateMaude(PrintStream stream) {
        boolean inlist = false;
        stream.print("\"" + getName() + "\"( ");
        if (getNumParam() == 0) {
            stream.print("emp ");
        } else {
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
        }
        stream.print(") ");
    }

    public void LetExp.generateMaude(PrintStream stream) {
        boolean inlist = false;
        stream.print("let @ \"" + getVar().getName() + "\" = ");
        getVal().generateMaude(stream);
        stream.print("in ");
        getExp().generateMaude(stream);
    }

	public void CaseExp.generateMaude(PrintStream stream) {
        boolean inlist = false;
		stream.print("case " );
		getExpr().generateMaude(stream);
		stream.print("of { ");
		for (CaseBranch branch : getBranchs()) {
            if (inlist) stream.print("; "); else inlist = true;
			branch.generateMaude(stream);
		}
		stream.print("} ");
	}
	
	public void CaseBranch.generateMaude(PrintStream stream) {
		getLeft().generateMaude(stream);
        stream.print("=> ( ");
        getRight().generateMaude(stream);
        stream.print(") ");
	}
	
	abstract public void Pattern.generateMaude(PrintStream stream);

    public void UnderscorePattern.generateMaude(PrintStream stream) {
        stream.print("@ \"_\" ");
    }

    public void PatternVar.generateMaude(PrintStream stream) {
        getVar().generateMaude(stream);
    }

    public void PatternVarUse.generateMaude(PrintStream stream) {
        stream.print("@ \"" + getName() + "\" ");
    }
    
    public void PatternVarDecl.generateMaude(PrintStream stream) {
        stream.print("@ \"" + getName() + "\" ");
    }

    public void LiteralPattern.generateMaude(PrintStream stream) {
        getLiteral().generateMaude(stream);
    }

    public void ConstructorPattern.generateMaude(PrintStream stream) {
        boolean inlist = false;
        stream.print("\"" + getConstructor() + "\"[ ");
        if (getNumParam() == 0) {
            stream.print("emp ");
        } else {
            for (Pattern pattern : getParamList()) {
                if (inlist) stream.print(":: "); else inlist = true;
                pattern.generateMaude(stream);
            }
        }
        stream.print("] ");
    }

	public void UnknownDecl.generateMaude(PrintStream stream) {
		stream.println("--- Unknown declaration " + getName());
	}

    public void ClassDecl.generateMaude(PrintStream stream) {
        boolean inlist = false;
		stream.println("\n\n< \"" + getName() + "\" : Class |");
        stream.print("  Param: ");
        if (getNumParam() == 0) {
            stream.print("noVid");
        } else {
            stream.print("(");
            for (ParamDecl param : getParams()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + param.getName() + "\"");
            }
            stream.print(")");
        }
        stream.print(",\n  Att: ");
        if (getNumField() == 0) {
            stream.print("noSubst");
        } else {
            inlist = false;
            for (FieldDecl field : getFields()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + field.getName() + "\" |-> null ");
            }
        }
        stream.print(",\n  Mtds: ");
        if (hasInitBlock()) {
            getInitBlock().generateMaude(stream, getFields(), isActiveClass());
        } else {
            // minimal init method - this block is not connected to the
            // AST so we pass in the field list in all cases.
            new InitBlock(new List<Annotation>(), new List<Stmt>()).generateMaude(stream, getFields(), isActiveClass());
        }
        for (MethodImpl method : getMethods()) {
            stream.print(",\n    ");
            method.generateMaude(stream);
        }
        stream.print(",\n  Ocnt: 0 > ");
	}
	
    public void MethodImpl.generateMaude(PrintStream stream) {
        boolean inlist = false;
        MethodSig sig = getMethodSig();
        boolean amRunMethod = sig.getName().equals("run");
        stream.print("< \"" + sig.getName() + "\" : Method | Param: ");
        if (sig.getNumParam() == 0) {
            stream.print("noVid");
        } else {
            stream.print("(");
            for (ParamDecl param : sig.getParams()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + param.getName() + "\"");
            }
            stream.print(")");
        }
        stream.print(", Att: ");
        inlist = false;
        stream.print("@ \".method\" |-> \"str\"[\"" + sig.getName() + "\"], ");
        stream.print("@ \".staticfuture\" |-> null, @ \"_\" |-> null");
        // All other variables get introduced via $vardecl as they are defined.
        stream.print(",\n      Code: ");
        if (getBlock().getNumStmt() == 0) {
            stream.print("return( null ) ");
        } else {
            inlist = false;    // value valid for statement emission as well
            for (Stmt stmt : getBlock().getStmts()) {
                if (inlist) stream.print("; "); else inlist = true;
                stmt.generateMaude(stream);
            }
            // Now release all labels
            for (Stmt stmt : getBlock().getStmts()) {
                if (stmt instanceof VarDeclStmt) {
                    VarDeclStmt vardecl = (VarDeclStmt)stmt;
                    Type t = vardecl.getVarDecl().getAccess().getType();
                    if (t.isFutureType()) {
                        if (inlist) stream.print("; "); else inlist = true;
                        stream.print("$free(@ \"" 
                                     + vardecl.getVarDecl().getName()
                                     + "\") ");
                    }
                }
            }
            // KLUDGE (rs 2010-06-15): Emit this for "Unit" methods for
            // now, since we don't have an empty `return' statement
            // currently.  Ideally we should flow-analyze where to
            // insert a dummy return statement for Void methods, and
            // give warnings about control paths not returning values
            // otherwise.
            Access returnType = sig.getReturnType();
            if (returnType instanceof IdUse
                && ((IdUse)returnType).getName().equals("Unit")
                // the run method has no place to return anything to
                && !amRunMethod)
            {
                stream.print("; return( null ) ");
            }
        }
        stream.print("> ");
    }

    abstract public void Stmt.generateMaude(PrintStream stream);

    public void VarDeclStmt.generateMaude(PrintStream stream) {
        // HACK FIXME: this should be an attribute
        boolean inMainBlock = getParent().getParent() instanceof MainBlock;

        VarDecl var = getVarDecl();
        if (inMainBlock) {
            if (var.hasInitExp()) {
                stream.print("assign( @@ \"" + var.getName() + "\" ; ");
                var.getInitExp().generateMaude(stream);
                stream.print(") ");
            } else {
                // nothing to do in this case, since the variable has
                // been converted into an object attribute.
                stream.print("noStmt ");
            }
        } else {
            stream.print("$vardecl( @ \"" + var.getName() + "\" ; ");
            if (var.hasInitExp()) {
                var.getInitExp().generateMaude(stream);
            } else {
                stream.print("null ");
            }
            stream.print(") ");
        }
    }
    
    public void SkipStmt.generateMaude(PrintStream stream) {
        stream.print("skip ");
    }

    public void AssignStmt.generateMaude(PrintStream stream) {
        if (getValue() instanceof PureExp) {
            Type t = getValue().getType();
            if (t.isFutureType()) {
                // Assigning one future to another.
                stream.print("$free( ");
                getVar().generateMaude(stream);
                stream.print("); ");
            }
            stream.print("assign( ");
            getVar().generateMaude(stream);
            stream.print("; ");
            getValue().generateMaude(stream);
            stream.print(") ");
            if (t.isFutureType()) {
                stream.print("$mark( ");
                getVar().generateMaude(stream);
                stream.print("); ");
            }
        } else {
            getValue().generateMaudeAsStatement(stream, ((VarOrFieldUse)getVar()).getName());
        }
    }

    public void ReturnStmt.generateMaude(PrintStream stream) {
        if (getRetExp() instanceof PureExp) {
            if (getRetExp().getType().isFutureType()) {
                stream.print("$mark( ");
                getRetExp().generateMaude(stream);
                stream.print(") ; ");
            }
            stream.print("return( ");
            getRetExp().generateMaude(stream);
            stream.print(") ");
        } else {
            getRetExp().generateMaudeAsStatement(stream, "_");
            stream.print("; return(@ \"_\") " );
        }
    }

    abstract public void Guard.generateMaude(PrintStream stream);

    public void ClaimGuard.generateMaude(PrintStream stream) {
        stream.print("?(");
        getVar().generateMaude(stream);
        stream.print(") ");
    }

    public void AndGuard.generateMaude(PrintStream stream) {
        stream.print("\"&&\"( ");
        getLeft().generateMaude(stream);
        stream.print(":: ");
        getRight().generateMaude(stream);
        stream.print(") ");
    }

    public void ExpGuard.generateMaude(PrintStream stream) {
        getPureExp().generateMaude(stream);
    }

    public void SuspendStmt.generateMaude(PrintStream stream) {
        stream.print("suspend ");
    }

    public void AwaitStmt.generateMaude(PrintStream stream) {
        stream.print("await ");
        getGuard().generateMaude(stream);
    }

    public void IfStmt.generateMaude(PrintStream stream) {
        stream.print("if ");
        getCondition().generateMaude(stream);
        stream.print("th ");
        getThen().generateMaude(stream);
        stream.print("el ");
        if (hasElse()) {
            getElse().generateMaude(stream);
        } else {
            stream.print("noStmt ");
        }
        stream.print("fi ");
    }

    public void ExpressionStmt.generateMaude(PrintStream stream) {
        getExp().generateMaudeAsStatement(stream, "_");
    }

    public void WhileStmt.generateMaude(PrintStream stream) {
        stream.print("while ");
        getCondition().generateMaude(stream);
        stream.print("do ");
        getBody().generateMaude(stream);
        stream.print("od ");
    }

    public void AssertStmt.generateMaude(PrintStream stream) {
        stream.print("assert ");
        getCondition().generateMaude(stream);
    }

    public void MainBlock.generateMaude(PrintStream stream) {
        boolean inlist = false;
        stream.println("\n\n< \".Start\" : Class |");
        stream.println("  Param: noVid,");
        stream.print("  Att: ");
        if (getNumVar() == 0) {
            stream.print("noSubst");
        } else {
            inlist = false;
            for (VarDecl var : getVars()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("@ \"" + var.getName() + "\" |-> null ");
            }
        }
        stream.print(",\n  Mtds: ");
        stream.print("< \".init\" : Method | Param: noVid, ");
        stream.print("Att: @ \".method\" |-> \"str\"[\".init\"], ");
        stream.print("@ \".staticfuture\" |-> null, @ \"_\" |-> null");
        stream.print(",\n      Code: ");
        inlist = false;
        if (!inlist && getNumStmt() == 0) {
            stream.print("noStmt ");
        } else {
            for (Stmt stmt : getStmts()) {
                if (inlist) stream.print("; "); else inlist = true;
                stmt.generateMaude(stream);
            }
        }
        stream.print(">,\n  Ocnt: 0 > ");
    }

	public void Block.generateMaude(PrintStream stream) {
        stream.print("$beginscope ");
        for (Stmt stmt : getStmts()) {
            stream.print("; ");
            stmt.generateMaude(stream);
        }
        // Now release all labels
        for (Stmt stmt : getStmts()) {
            if (stmt instanceof VarDeclStmt) {
                VarDeclStmt vardecl = (VarDeclStmt)stmt;
                Type t = vardecl.getVarDecl().getAccess().getType();
                if (t.isFutureType()) {
                    stream.print("; $free(@ \"" + vardecl.getVarDecl().getName()
                                 + "\") ");
                }
            }
        }
        stream.print("; $endscope ");
	}
	
    public void InitBlock.generateMaude(PrintStream stream,
                                        List<FieldDecl> fields,
                                        boolean isActiveClass) {
        boolean inlist = false;
        stream.print("< \".init\" : Method | Param: noVid, ");
        stream.print("Att: @ \".method\" |-> \"str\"[\".init\"], ");
        stream.print("@ \".staticfuture\" |-> null, @ \"_\" |-> null");
        stream.print(",\n      Code: ");
        // Process field initializers here
        for (FieldDecl field : fields) {
            if (field.hasInitExp()) {
                if (inlist) stream.print("; "); else inlist = true;
                stream.print("assign( @@ \"" + field.getName() + "\" ; ");
                field.getInitExp().generateMaude(stream);
                stream.print(") ");
            }
        }
        if (!inlist && getNumStmt() == 0) {
            // didn't emit anything until now - completely empty method
            stream.print("noStmt ");
        } else {
            for (Stmt stmt : getStmts()) {
                if (inlist) stream.print("; "); else inlist = true;
                stmt.generateMaude(stream);
            }
        }
        if (isActiveClass) stream.print("; selftailcall (\"run\" ; emp) ");
        stream.print("> ");
    }
}
