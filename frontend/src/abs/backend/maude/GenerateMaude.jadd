// -*- mode: java; tab-width: 4; -*-
import java.io.PrintStream;
import java.util.Set;
import java.util.TreeSet;
import abs.backend.maude.MaudeCompilerHelper;

aspect GenerateMaude {

    // New rule!  Everyone can expect sufficient whitespace to be set
    // up, but has to leave whitespace at the end if needed.

    public void Model.generateMaude(PrintStream stream, String module, int clocklimit) {
    	generateMaude(stream,module,null, clocklimit);
    }

    public void Model.generateMaude(PrintStream stream, String module, String mainBlock, int clocklimit) {
        boolean hasClasses = false;
        stream.println("in abs-interpreter\n\nmod MODEL is\nprotecting "
                       + module + " .\n");
        for (Decl decl : getDecls()) {
            if (decl instanceof FunctionDecl)
                decl.generateMaude(stream);
        }
        stream.println("op classes : -> Configuration .");
        stream.print("eq classes =");
        for (Decl decl : getDecls()) {
            if (decl instanceof ClassDecl) {
                hasClasses = true;
                decl.generateMaude(stream);
            }
        }
        if (mainBlock == null) {
            if (hasMainBlock()) {
                hasClasses = true;
                getMainBlock().generateMaude(stream);
            }
        } else {
            if (hasMainBlock(mainBlock)) {
                hasClasses = true;
                getMainBlock(mainBlock).generateMaude(stream);
            }
        }
        if (!hasClasses) {
            stream.print("none ");
        }
        stream.println(".\n");
        stream.println();
        stream.println("--- Start the main block with 'rew start .'");
        stream.println("op start : -> State .");
        stream.println("eq start = main(classes, \".Start\", emp, " + Integer.toString(clocklimit) + ") .");
        stream.println("\nendm");
    }

	abstract public void Decl.generateMaude(PrintStream stream);

    public void DataConstructor.generateMaude(PrintStream stream) { }

	public void InterfaceDecl.generateMaude(PrintStream stream) {
		stream.println("*** Interface code ...");
	}

	public void DataTypeDecl.generateMaude(PrintStream stream) {
		stream.println("*** Datatype " + qualifiedName());
	}

    public void TypeParameterDecl.generateMaude(PrintStream stream) {
        stream.println("*** Type parameter " + qualifiedName());
    }

	public void TypeSynDecl.generateMaude(PrintStream stream) {
		stream.println("*** Type synonym: Datatype " + qualifiedName());
	}

    public void DeltaDecl.generateMaude(PrintStream stream) {
		stream.println("*** Delta: " + qualifiedName());
    }
	
	public void FunctionDecl.generateMaude(PrintStream stream) {
		boolean inList = false;
        if (getFunctionDef() instanceof BuiltinFunctionDef) return;
        stream.print("eq fparams(\"" + qualifiedName() + "\") = ");
        if (getNumParam() == 0) {
            stream.println("noVid .");
        } else {
            for (VarOrFieldDecl param : getParams()) {
                if (inList == false) inList = true; else stream.print(", ");
                stream.print("'" + param.getName() + " ");
            }
            stream.print(".\n");
        }
		stream.print("eq fdefn(\"" + qualifiedName() + "\") = ");
		getFunctionDef().generateMaude(stream);
        stream.println(".");
        stream.println();
	}

    abstract public void FunctionDef.generateMaude(PrintStream stream);
    public void ExpFunctionDef.generateMaude(PrintStream stream) {
        getRhs().generateMaude(stream);
    }
    public void BuiltinFunctionDef.generateMaude(PrintStream stream) {
        stream.println("--- Hey, I didn't expect this to be generated! " + getClass().toString());
    }

    abstract public void Exp.generateMaude(PrintStream stream);
    abstract public int Exp.numberOfRandom(Set<String> visitedFunctions);

    public void IncompleteExp.generateMaude(PrintStream stream) {
        stream.println("--- Hey, I didn't expect this to be generated! " + getClass().toString());
    }
    public int IncompleteExp.numberOfRandom(Set<String> visitedFunctions) {
        return 0;
    }
    
    public void Access.generateMaude(PrintStream stream) {
        stream.println("--- Hey, I didn't expect this to be generated! " + getClass().toString());
    }
    public int Access.numberOfRandom(Set<String> visitedFunctions) {
        return 0;
    }

    abstract public void Exp.generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations);
    
    public void IncompleteExp.generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations) {
        stream.print("noStmt ");
    }
    
    public void PureExp.generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations)
    {
        stream.print("noStmt ");
    }

    public void EffExp.generateMaude(PrintStream stream) {
        stream.println("--- Hey, you used a side-effecting expression as a normal one! " + getClass().toString());
    }
    public void AsyncCall.generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations)
    {
        boolean inlist = false;
        String effvar = var;
        PureExp deadline = MaudeCompilerHelper.getAnnotationValue(annotations, "Deadline");
        stream.print("asynccall('"
                     + (var.equals("_") ? ".staticfuture" : var)
                     + " ; ");
        getCallee().generateMaude(stream);
        stream.print(" ; '" + getMethod() + " ; ");
        if (getNumParam() == 0) {
            stream.print("emp ");
        } else {
            stream.print("(");
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            stream.print(") ");
        }
        stream.print("; ");
        if (deadline != null) deadline.generateMaude(stream);
        else stream.print("\"InfDuration\"[ emp ]");
        stream.print(") ");
    }
    public int AsyncCall.numberOfRandom(Set<String> visitedFunctions) {
        int result = 0;
        for (PureExp param : getParams()) {
            result += param.numberOfRandom(visitedFunctions);
        }
        return result;
    }

    public void SyncCall.generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations)
    {
        boolean inlist = false;
        PureExp deadline = MaudeCompilerHelper.getAnnotationValue(annotations, "Deadline");
        stream.print("synccall('.staticfuture ; ");
        getCallee().generateMaude(stream);
        stream.print("; '" + getMethod() + " ; ");
        if (getNumParam() == 0) {
            stream.print("emp ");
        } else {
            stream.print("(");
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            stream.print(") ");
        }
        stream.print("; ");
        if (deadline != null) deadline.generateMaude(stream);
        else stream.print("\"InfDuration\"[ emp ]");
        stream.print(") ; get( '.staticfuture ; '" + var + ") ");
    }
    public int SyncCall.numberOfRandom(Set<String> visitedFunctions) {
        int result = 0;
        for (PureExp param : getParams()) {
            result += param.numberOfRandom(visitedFunctions);
        }
        return result;
    }

    public void OriginalCall.generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations)
    {
        stream.println("--- Hey, you forgot to flatten your model!");
    }
    public int OriginalCall.numberOfRandom(Set<String> visitedFunctions) {
        return 0;
    }


    public void GetExp.generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations)
    {
        stream.print("get(");
        getPureExp().generateMaude(stream);
        stream.print(" ; '" + var + ") ");
    }
    public int GetExp.numberOfRandom(Set<String> visitedFunctions) {
        return 0;
    }

    public void NewExp.generateMaudeAsStatement(PrintStream stream, String var, List<Annotation> annotations)
    {
        boolean inlist = false;
        if (hasCog()) {
            stream.print("newcog(");
        } else {
            stream.print("new(");
        }
        stream.print("'" + var + " ; '" + (((UnionType)getType()).getOriginatingClass()).qualifiedName() + " ; ");
        if (getNumParam() == 0) {
            stream.print("emp ");
        } else {
            stream.print("(");
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            stream.print(") ");
        }
        if (hasCog()) {
            PureExp dc = MaudeCompilerHelper.getAnnotationValue(annotations, "DC");
            stream.print("; ");
            if (dc != null) {
                dc.generateMaude(stream);
            } else {
                stream.print("'.comp ");
            }
        }
        stream.print(") ");
    }
    public int NewExp.numberOfRandom(Set<String> visitedFunctions) {
        int result = 0;
        for (PureExp param : getParams()) {
            result += param.numberOfRandom(visitedFunctions);
        }
        return result;
    }

    abstract public void LiteralExp.generateMaude(PrintStream stream);
    public int LiteralExp.numberOfRandom(Set<String> visitedFunctions) {
        return 0;
    }

    public void StringLiteral.generateMaude(PrintStream stream) {
        stream.print("\"str\"[\"" + getContent() + "\"] ");
    }

    public void IntLiteral.generateMaude(PrintStream stream) {
        stream.print("\"int\"[" + getContent() + "] ");
    }

    syn String Unary.maudePrefixOperator();
    eq MinusExp.maudePrefixOperator() = "--";
    eq NegExp.maudePrefixOperator() = "~";
    public void Unary.generateMaude(PrintStream stream) {
        stream.print("\"" + maudePrefixOperator() + "\"( ");
        getOperand().generateMaude(stream);
        stream.print(") ");
    }
    public int Unary.numberOfRandom(Set<String> visitedFunctions) {
        return getOperand().numberOfRandom(visitedFunctions);
    }

    syn String Binary.maudeInfixOperator();
    eq EqExp.maudeInfixOperator() = "==";
    eq NotEqExp.maudeInfixOperator() = "/=";
    eq AndBoolExp.maudeInfixOperator() = "&&";
    eq OrBoolExp.maudeInfixOperator() = "||";
    eq LTExp.maudeInfixOperator() = "<";
    eq GTExp.maudeInfixOperator() = ">";
    eq LTEQExp.maudeInfixOperator() = "<=";
    eq GTEQExp.maudeInfixOperator() = ">=";
    eq AddAddExp.maudeInfixOperator() = "+";
    eq SubAddExp.maudeInfixOperator() = "-";
    eq MultMultExp.maudeInfixOperator() = "*";
    eq DivMultExp.maudeInfixOperator() = "/";
    eq ModMultExp.maudeInfixOperator() = "%";
    public void Binary.generateMaude(PrintStream stream) {
        stream.print("\"" + maudeInfixOperator() + "\"( ");
        getLeft().generateMaude(stream);
        stream.print(":: ");
        getRight().generateMaude(stream);
        stream.print(") ");
    }
    public int Binary.numberOfRandom(Set<String> visitedFunctions) {
        return getLeft().numberOfRandom(visitedFunctions) + getRight().numberOfRandom(visitedFunctions);
    }

    public void ThisExp.generateMaude(PrintStream stream) {
        stream.print("'this ");
    }
    public int ThisExp.numberOfRandom(Set<String> visitedFunctions) {
        return 0;
    }

    public void NullExp.generateMaude(PrintStream stream) {
        stream.print("null ");
    }
    public int NullExp.numberOfRandom(Set<String> visitedFunctions) {
        return 0;
    }

    public void DataConstructorExp.generateMaude(PrintStream stream) {
       boolean inlist = false;
       stream.print("\"" + getConstructor() + "\"[ ");
       if (getNumParam() == 0) {
           stream.print("emp ");
       } else {
           for (PureExp param : getParams()) {
               if (inlist) stream.print(":: "); else inlist = true;
               param.generateMaude(stream);
           }
       }
       stream.print("] ");
    }
    public int DataConstructorExp.numberOfRandom(Set<String> visitedFunctions) {
        int result = 0;
        for (PureExp param : getParams()) {
            result += param.numberOfRandom(visitedFunctions);
        }
        return result;
    }

    public void VarOrFieldUse.generateMaude(PrintStream stream) {
        stream.println("--- Hey, I didn't expect this to be generated! " + getClass().toString());
    }

	public void VarUse.generateMaude(PrintStream stream) {
        stream.print("'" + getName() + " ");
	}

	public void FieldUse.generateMaude(PrintStream stream) {
        stream.print("@ '" + getName() + " ");
	}

    public void FnApp.generateMaude(PrintStream stream) {
        boolean inlist = false;
        String fnName = getDecl().getModuleDecl().getName() + "." + getName();
        stream.print("\"" + fnName + "\"( ");
        if (getNumParam() == 0) {
            stream.print("emp ");
        } else {
            for (PureExp param : getParams()) {
                if (inlist) stream.print(":: "); else inlist = true;
                param.generateMaude(stream);
            }
            if (fnName.equals("ABS.StdLib.random")) {
                stream.print(" :: \"int\"[0] ");
            }
        }
        stream.print(") ");
    }
    public int FnApp.numberOfRandom(Set<String> visitedFunctions) {
        int result = 0;
        String fnName = getDecl().getModuleDecl().getName() + "." + getName();
        if (fnName.equals("ABS.StdLib.random")) {
            result = 1;
        } else {
            for (PureExp param : getParams()) {
                result += param.numberOfRandom(visitedFunctions);
            }
            if (!visitedFunctions.contains(fnName)) {
                visitedFunctions.add(fnName);
                FunctionDef def = ((FunctionDecl)getDecl()).getFunctionDef();
                if (def instanceof ExpFunctionDef) {
                    PureExp rhs = ((ExpFunctionDef)def).getRhs();
                    result += rhs.numberOfRandom(visitedFunctions);
                }
                visitedFunctions.remove(fnName);
            }
        }
        return result;
    }

    public void LetExp.generateMaude(PrintStream stream) {
        boolean inlist = false;
        stream.print("let '" + getVar().getName() + " = ");
        getVal().generateMaude(stream);
        stream.print("in ");
        getExp().generateMaude(stream);
    }
    public int LetExp.numberOfRandom(Set<String> visitedFunctions) {
        return getVal().numberOfRandom(visitedFunctions)
            + getExp().numberOfRandom(visitedFunctions);
    }

    public void IfExp.generateMaude(PrintStream stream) {
        stream.print("if ");
        getCondExp().generateMaude(stream);
        stream.print("th ");
        getThenExp().generateMaude(stream);
        stream.print("el ");
        getElseExp().generateMaude(stream);
        stream.print("fi ");
    }
    public int IfExp.numberOfRandom(Set<String> visitedFunctions) {
        return getCondExp().numberOfRandom(visitedFunctions)
            + java.lang.Math.max(getThenExp().numberOfRandom(visitedFunctions),
                                 getElseExp().numberOfRandom(visitedFunctions));
    }

	public void CaseExp.generateMaude(PrintStream stream) {
        boolean inlist = false;
		stream.print("case " );
		getExpr().generateMaude(stream);
		stream.print("of { ");
		for (CaseBranch branch : getBranchs()) {
            if (inlist) stream.print("; "); else inlist = true;
			branch.generateMaude(stream);
		}
		stream.print("} ");
	}
    public int CaseExp.numberOfRandom(Set<String> visitedFunctions) {
        int acc = 0;
        for (CaseBranch branch : getBranchs()) {
            acc = java.lang.Math.max(acc, branch.numberOfRandom(visitedFunctions));
        }
        return acc + getExpr().numberOfRandom(visitedFunctions);
    }
	
	public void CaseBranch.generateMaude(PrintStream stream) {
		getLeft().generateMaude(stream);
        stream.print("=> ( ");
        getRight().generateMaude(stream);
        stream.print(") ");
	}
    public int CaseBranch.numberOfRandom(Set<String> visitedFunctions) {
        return getRight().numberOfRandom(visitedFunctions);
    }
	
	abstract public void Pattern.generateMaude(PrintStream stream);

    public void UnderscorePattern.generateMaude(PrintStream stream) {
        stream.print("'_ ");
    }

    public void PatternVar.generateMaude(PrintStream stream) {
        getVar().generateMaude(stream);
    }

    public void PatternVarUse.generateMaude(PrintStream stream) {
        stream.print("'" + getName() + " ");
    }
    
    public void PatternVarDecl.generateMaude(PrintStream stream) {
        stream.print("'" + getName() + " ");
    }

    public void LiteralPattern.generateMaude(PrintStream stream) {
        getLiteral().generateMaude(stream);
    }

    public void ConstructorPattern.generateMaude(PrintStream stream) {
        boolean inlist = false;
        stream.print("\"" + getConstructor() + "\"[ ");
        if (getNumParam() == 0) {
            stream.print("emp ");
        } else {
            for (Pattern pattern : getParamList()) {
                if (inlist) stream.print(":: "); else inlist = true;
                pattern.generateMaude(stream);
            }
        }
        stream.print("] ");
    }

	public void UnknownDecl.generateMaude(PrintStream stream) {
		stream.println("--- Unknown declaration " + getName());
	}

    public void ClassDecl.generateMaude(PrintStream stream) {
        boolean inlist = false;
        PureExp scheduler = MaudeCompilerHelper.getAnnotationValue(this.getAnnotationList(), "Scheduler");
		stream.println("\n\n< '" + qualifiedName() + " : Class | Param: ");
        if (getNumParam() == 0) {
            stream.print("noVid");
        } else {
            stream.print("(");
            for (ParamDecl param : getParams()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("'" + param.getName() + "");
            }
            stream.print(")");
        }
        stream.print(",\n  Att: ");
        if (getNumField() == 0) {
            stream.print("noSubst");
        } else {
            inlist = false;
            for (FieldDecl field : getFields()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("'" + field.getName() + " |-> null ");
            }
        }
        stream.print(",\n  Sched: ");
        if (scheduler != null) scheduler.generateMaude(stream);
        else stream.print("\"ABS.Scheduler.defaultscheduler\"('queue)");
        stream.print(",\n  Mtds: ");
        if (hasInitBlock()) {
            getInitBlock().generateMaude(stream, getFields(), isActiveClass());
        } else {
            // minimal init method - this block is not connected to the
            // AST so we pass in the field list in all cases.
            new InitBlock(new List<Annotation>(), new List<Stmt>()).generateMaude(stream, getFields(), isActiveClass());
        }
        for (MethodImpl method : getMethods()) {
            stream.print(",\n    ");
            method.generateMaude(stream);
        }
        stream.print(",\n  Ocnt: 0 > ");
	}

    public void MethodImpl.generateMaude(PrintStream stream) {
        boolean inlist = false;
        MethodSig sig = getMethodSig();
        stream.print("< '" + sig.getName() + " : Method | Param: ");
        if (sig.getNumParam() == 0) {
            stream.print("noVid");
        } else {
            stream.print("(");
            for (ParamDecl param : sig.getParams()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("'" + param.getName() + "");
            }
            stream.print(")");
        }
        stream.print(",\n      Cost: \"Duration\"[\"int\"[0]]");
        stream.print(",\n      Code: ");
        if (getBlock().getNumStmt() == 0) {
            stream.print("return( null ) ");
        } else {
            inlist = false;    // value valid for statement emission as well
            for (Stmt stmt : getBlock().getStmts()) {
                if (inlist) stream.print("; "); else inlist = true;
                stmt.generateMaude(stream);
            }
            // KLUDGE (rs 2010-06-15): Emit this for "Unit" methods for
            // now, since we don't have an empty `return' statement
            // currently.  Ideally we should flow-analyze where to
            // insert a dummy return statement for Void methods, and
            // give warnings about control paths not returning values
            // otherwise.
            Access returnType = sig.getReturnType();
            if (returnType instanceof IdUse
                && ((IdUse)returnType).getName().equals("Unit"))
            {
                stream.print("; return( null ) ");
            }
        }
        stream.print("> ");
    }

    abstract public void Stmt.generateMaude(PrintStream stream);

    public void IncompleteStmt.generateMaude(PrintStream stream) {
        // ignore
    }
    
    public void VarDeclStmt.generateMaude(PrintStream stream) {
        // HACK FIXME: this should be an attribute
        boolean inMainBlock = getParent().getParent() instanceof MainBlock
            || getParent().getParent().getParent() instanceof Product;

        VarDecl var = getVarDecl();
        if (inMainBlock) {
            if (var.hasInitExp()) {
                int randomcount = var.getInitExp().numberOfRandom(new TreeSet<String>());
                MaudeCompilerHelper.emitPushRandomInst(stream, randomcount);
                if (var.getInitExp() instanceof PureExp) {
                    stream.print("assign( @ '" + var.getName() + " ; ");
                    var.getInitExp().generateMaude(stream);
                    stream.print(") ");
                } else {
                    var.getInitExp().generateMaudeAsStatement(stream, var.getName(), getAnnotations());
                }
                MaudeCompilerHelper.emitPopRandomInst(stream, randomcount);
            } else {
                // nothing to do in this case, since the variable has
                // been converted into an object attribute.
                stream.print("noStmt ");
            }
        } else {
            if (var.hasInitExp()) {
                int randomcount = var.getInitExp().numberOfRandom(new TreeSet<String>());
                MaudeCompilerHelper.emitPushRandomInst(stream, randomcount);
                if (var.getInitExp() instanceof PureExp) {
                    stream.print("$vardecl( '" + var.getName() + " ; ");
                    if (var.hasInitExp()) {
                        var.getInitExp().generateMaude(stream);
                    } else {
                        stream.print("null ");
                    }
                    stream.print(") ");
                } else {
                    stream.print("$vardecl( '" + var.getName() + " ; null ) ; ");
                    var.getInitExp().generateMaudeAsStatement(stream, var.getName(), getAnnotations());
                }
                MaudeCompilerHelper.emitPopRandomInst(stream, randomcount);
            } else {
                stream.print("$vardecl( '" + var.getName() + " ; null ) ");
            }
        }
    }
    
    public void SkipStmt.generateMaude(PrintStream stream) {
        stream.print("skip ");
    }

    public void AssignStmt.generateMaude(PrintStream stream) {
        int randomcount = getValue().numberOfRandom(new TreeSet<String>());
        MaudeCompilerHelper.emitPushRandomInst(stream, randomcount);
        if (getValue() instanceof PureExp) {
            stream.print("$pushrandom ; ");
            stream.print("assign( ");
            getVar().generateMaude(stream);
            stream.print("; ");
            getValue().generateMaude(stream);
            stream.print(") ");
            stream.print("; $poprandom ");
        } else {
            getValue().generateMaudeAsStatement(stream, ((VarOrFieldUse)getVar()).getName(), getAnnotations());
        }
        MaudeCompilerHelper.emitPopRandomInst(stream, randomcount);
    }

    public void ReturnStmt.generateMaude(PrintStream stream) {
        if (getRetExp() instanceof PureExp) {
            stream.print("return( ");
            getRetExp().generateMaude(stream);
            stream.print(") ");
        } else {
            String var = "_";
            // AsyncCall discards its Future immediately if result
            // assigned to dummy variable _
            if (getRetExp() instanceof AsyncCall) var = ".staticfuture";
            getRetExp().generateMaudeAsStatement(stream, var, getAnnotations());
            stream.print("; return('" + var + ") " );
        }
    }

    abstract public void Guard.generateMaude(PrintStream stream);

    public void ClaimGuard.generateMaude(PrintStream stream) {
        stream.print("?(");
        getVar().generateMaude(stream);
        stream.print(") ");
    }

    public void AndGuard.generateMaude(PrintStream stream) {
        stream.print("\"&&\"( ");
        getLeft().generateMaude(stream);
        stream.print(":: ");
        getRight().generateMaude(stream);
        stream.print(") ");
    }

    public void ExpGuard.generateMaude(PrintStream stream) {
        getPureExp().generateMaude(stream);
    }

    public void DurationGuard.generateMaude(PrintStream stream) {
        stream.print("?duration( ");
        getMin().generateMaude(stream);
        stream.print("; ");
        getMax().generateMaude(stream);
        stream.print(") ");
    }

    public void SuspendStmt.generateMaude(PrintStream stream) {
        stream.print("suspend ");
    }

    public void DurationStmt.generateMaude(PrintStream stream) {
        stream.print("duration(");
        getMin().generateMaude(stream);
        stream.print("; ");
        getMax().generateMaude(stream);
        stream.print(") ");
    }

    public void AwaitStmt.generateMaude(PrintStream stream) {
        stream.print("await ");
        getGuard().generateMaude(stream);
    }

    public void IfStmt.generateMaude(PrintStream stream) {
        stream.print("if ");
        getCondition().generateMaude(stream);
        stream.print("th ");
        getThen().generateMaude(stream);
        stream.print("el ");
        if (hasElse()) {
            getElse().generateMaude(stream);
        } else {
            stream.print("noStmt ");
        }
        stream.print("fi ");
    }

    public void ExpressionStmt.generateMaude(PrintStream stream) {
        getExp().generateMaudeAsStatement(stream, "_", getAnnotations());
    }

    public void WhileStmt.generateMaude(PrintStream stream) {
        stream.print("while ");
        getCondition().generateMaude(stream);
        stream.print("do ");
        getBody().generateMaude(stream);
        stream.print("od ");
    }

    public void AssertStmt.generateMaude(PrintStream stream) {
        stream.print("assert ");
        getCondition().generateMaude(stream);
    }

    public void MainBlock.generateMaude(PrintStream stream) {
        boolean inlist = false;
        stream.println("\n\n< '.Start : Class | Param: noVid,");
        stream.print("  Att: ");
        if (getNumVar() == 0) {
            stream.print("noSubst");
        } else {
            inlist = false;
            for (VarDecl var : getVars()) {
                if (inlist) stream.print(", "); else inlist = true;
                stream.print("'" + var.getName() + " |-> null ");
            }
        }
        stream.print(",\n  Sched: \"ABS.Scheduler.defaultscheduler\"('queue)");
        stream.print(",\n  Mtds: ");
        stream.print("< '.init : Method | Param: noVid,\n");
        stream.print("      Cost: \"Duration\"[\"int\"[0]],\n");
        stream.print("      Code: ");
        inlist = false;
        if (!inlist && getNumStmt() == 0) {
            stream.print("return(null) ");
        } else {
            for (Stmt stmt : getStmts()) {
                if (inlist) stream.print("; "); else inlist = true;
                stmt.generateMaude(stream);
            }
            stream.print("; return(null) ");
        }
        stream.print(">,\n  Ocnt: 0 > ");
    }

	public void Block.generateMaude(PrintStream stream) {
        stream.print("$beginscope ");
        for (Stmt stmt : getStmts()) {
            stream.print("; ");
            stmt.generateMaude(stream);
        }
        stream.print("; $endscope ");
	}
	
    public void InitBlock.generateMaude(PrintStream stream,
                                        List<FieldDecl> fields,
                                        boolean isActiveClass) {
        boolean inlist = false;
        stream.print("< '.init : Method | Param: noVid,\n");
        stream.print("      Cost: \"Duration\"[\"int\"[0]],\n");
        stream.print("      Code: ");
        // Process field initializers here
        for (FieldDecl field : fields) {
            if (field.hasInitExp()) {
                if (inlist) stream.print("; "); else inlist = true;
                stream.print("assign( @ '" + field.getName() + " ; ");
                field.getInitExp().generateMaude(stream);
                stream.print(") ");
            }
        }
        for (Stmt stmt : getStmts()) {
            if (inlist) stream.print("; "); else inlist = true;
            stmt.generateMaude(stream);
        }
        if (inlist) stream.print("; "); else inlist = true;
        stream.print("return(null) ");
        if (isActiveClass) {
            stream.print("; asynccall('.staticfuture ; 'this ; 'run ; emp ; \"InfDuration\"[ emp ]) ");
        }
        stream.print("> ");
    }

    public int TypeUse.numberOfRandom(Set<String> visitedFunctions) {
        return 0; // bogus
    }
}
