// -*- mode: java; tab-width: 4; -*-

import java.io.*;
import abs.backend.prolog.*;
import abs.frontend.ast.*;

aspect GenerateProlog {

    public void ASTNode.generateProlog(PrintStream s){
    	if (children != null)
    		for (ASTNode<?> child : children) 
    			if (child != null) child.generateProlog(s);
    }
    
    
    // data (Data type declarations)
    /*   E.g., for a data type "data List = Nil | Cons(Int,List) ;"
     *   we generate the Prolog term 
     *   "data('List',['Nil','Cons'('Int','List')])"
     */   
    public void ParametricDataTypeDecl.generateProlog(PrintStream s){
    	s.print("data(" + quote(getName()) + ",[");
    	List<?> cs = (List<?>) getChild(0);
    	int n = cs.getNumChild();
    	for (int i = 0; i < n; i++){
    		cs.getChild(i).generateProlog(s); // cons here is a DataConstructor
    		if (i != n-1) s.print(",");
    	}
    	// child(1) and child(2) are resp. annotations and type parameters. By now, I ignore them.
    	s.println("]).");
    }

    public void DataConstructor.generateProlog(PrintStream s){
    	s.print(quote(getName()));
    	List<?> uses = (List<?>) getChild(0); // ? = DataTypeUse
    	int n = uses.getNumChild();
    	if (n == 0) return;
    	else {
    		s.print("(");
    		for (int i = 0; i < n; i++){
    			uses.getChild(i).generateProlog(s);
    			if (i != n-1) s.print(",");
    		}
    		s.print(")");
    	}
    }


    public void DataTypeUse.generateProlog(PrintStream s){
    	s.print(quote(getName()));
    }


    // type (Type synonyms declarations)
    /* E.g., for a declaration "type Data = Int ;"
     *   we generate the Prolog term 
     *   "type('Data','Int')"
     */   
    public void TypeSynDecl.generateProlog(PrintStream s){
    	s.print("type(" + quote(getName()) + ",");
    	getChild(1).generateProlog(s);
    	s.println(").");
    	// child(0) is a list of annotations and is ignored
    }


    // def (Function declarations)
    /*   E.g., for a function "def ..."
     *   we generate the Prolog terms 
     *   "def(...)"
     *   ...
     */
    public void FunctionDecl.generateProlog(PrintStream s){
    	s.print("def(" + quote(getName()) + ",");
    	// child(0) is a list of annotations and is ignored
    	getChild(1).generateProlog(s);
    	List<?> params = (List<?>) getChild(2);
    	int n = params.getNumChild();
    	s.print(",[");
    	for (int i = 0; i < n; i++){
    		params.getChild(i).generateProlog(s);
    		if (i != n-1) s.print(",");
    	}
    	s.print("],");
    	getChild(3).generateProlog(s);
    	s.println(").");
    }

    public void ParametricFunctionDecl.generateProlog(PrintStream s){
    	s.print("def(" + quote(getName()) + ",");
    	getChild(0).generateProlog(s);
    	List<?> params = (List<?>) getChild(1);
    	int n = params.getNumChild();
    	s.print(",[");
    	for (int i = 0; i < n; i++){
    		params.getChild(i).generateProlog(s);
    		if (i != n-1) s.print(",");
    	}
    	s.print("],");
    	getChild(2).generateProlog(s);
    	s.println(").");
    }


    public void ParamDecl.generateProlog(PrintStream s){
    	s.print("(");
    	getChild(0).generateProlog(s);
    	s.print("," + initialToUpperCase(getName()) + ")");
    }

    public void ExpFunctionDef.generateProlog(PrintStream s){
    	// child(0) is a PureExp, i.e., a CaseExp, LetExp, FnApp, DataConstructoreExp, etc (see ABS.ast)
    	((PureExp) getChild(0)).generateProlog(s);
    }
    
    public void BuiltinFunctionDef.generateProlog(PrintStream s){
    	// child(0) is a PureExp (I guess it can be used for its interpretation afterwards)
    	// But it has no content after parsing (I think ...)
    	s.print("builtin");
    }


    // Pure expressions

    public void PureExp.generateProlog(PrintStream s){
    	// This method will be overwritten by all PureExp concrete subclasses
    	// Therefore this is run only when a PureExp is not supported
    	throw new PrologBackendException("PureExp not supported by PrologBackend (" + this + ")");
    }

    public void VarUse.generateProlog(PrintStream s){
    	s.print(initialToUpperCase(getName()));
    }

    public void AndBoolExp.generateProlog(PrintStream s){
    	s.print("and(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void OrBoolExp.generateProlog(PrintStream s){
    	s.print("or(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void NegExp.generateProlog(PrintStream s){
    	s.print("neg(");
		getChild(0).generateProlog(s);
    	s.print(")");
    }

    public void EqExp.generateProlog(PrintStream s){
    	s.print("eq(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void GTExp.generateProlog(PrintStream s){
    	s.print("gt(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void GTEQExp.generateProlog(PrintStream s){
    	s.print("gteq(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void LTExp.generateProlog(PrintStream s){
    	s.print("lt(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void LTEQExp.generateProlog(PrintStream s){
    	s.print("lteq(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void MinusExp.generateProlog(PrintStream s){
    	s.print("minus(");
		getChild(0).generateProlog(s);
    	s.print(")");
    }

    public void AddAddExp.generateProlog(PrintStream s){
    	s.print("add(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void SubAddExp.generateProlog(PrintStream s){
    	s.print("sub(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void MultMultExp.generateProlog(PrintStream s){
    	s.print("mul(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void DivMultExp.generateProlog(PrintStream s){
    	s.print("div(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void ModMultExp.generateProlog(PrintStream s){
    	s.print("mod(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(")");
    }

    public void StringLiteral.generateProlog(PrintStream s){
    	s.print(quote(getContent()));
    }

    public void IntLiteral.generateProlog(PrintStream s){
    	s.print(getContent());
    }

    public void DataConstructorExp.generateProlog(PrintStream s){
    	s.print("cons(" + quote(getConstructor()));
    	List<?> subExps = (List<?>) getChild(0); // ? = PureExp
    	int n = subExps.getNumChild();
    	if (n > 0) {
    		s.print("(");
    		for (int i = 0; i < n; i++){
    			subExps.getChild(i).generateProlog(s);
    			if (i != n-1) s.print(",");
    		}
    		s.print(")");
    	}
    	s.print(")");
    }

    public void FnApp.generateProlog(PrintStream s){
    	s.print("apply(" + quote(getName()));
    	List<?> args = (List<?>) getChild(0); // ? = PureExp
    	int n = args.getNumChild();
    	if (n > 0){
    		s.print("(");
    		for (int i = 0; i < n; i++){
    			args.getChild(i).generateProlog(s);
    			if (i != n-1) s.print(",");
    		}
    		s.print(")");
    	}
    	s.print(")");
    }

    public void LetExp.generateProlog(PrintStream s){
    	s.print("let(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	getChild(1).generateProlog(s);
    	s.print(",");
    	getChild(2).generateProlog(s);
    	s.print(")");    	
    }


    // Case expressions

    public void CaseExp.generateProlog(PrintStream s){
    	s.print("case(");
    	getChild(0).generateProlog(s);
    	s.print(",");
    	List<?> branches = (List<?>) getChild(1); // ? = CaseBranch
    	int n = branches.getNumChild();
    	s.print("[");
    	for (int i = 0; i < n; i++){
    		branches.getChild(i).generateProlog(s);
    		if (i != n-1) s.print(",");
    	}
    	s.print("])");
    }

    public void CaseBranch.generateProlog(PrintStream s){
    	s.print("branch(");
    	getChild(0).generateProlog(s); // child(0) is a Pattern
    	s.print(",");
        getChild(1).generateProlog(s); // child(1) is a PureExp
    	s.print(")"); // This closes the "casebranch" term
    }


    // Patterns

    public void PatternVarDecl.generateProlog(PrintStream s){
    	s.print(initialToUpperCase(getName()));
    }

    public void PatternVarUse.generateProlog(PrintStream s){
    	s.print(initialToUpperCase(getName()));
    }

    public void ConstructorPattern.generateProlog(PrintStream s){
    	s.print(quote(getConstructor()));
    	List<?> subterms = (List<?>) getChild(0); // ? = Pattern
    	int n = subterms.getNumChild();
    	if (n == 0) return;
    	else {
    		s.print("(");
    		for (int i = 0; i < n; i++){
    			subterms.getChild(i).generateProlog(s);
    			if (i != n-1) s.print(",");
    		}
    		s.print(")");
    	}
    }

    public void UnderscorePattern.generateProlog(PrintStream s){
    	s.print("_");
    }

    public void NullExp.generateProlog(PrintStream s){
    	s.print("null");
    }
    
    
    // Class and Interface declarations (Not yet supported)
    
    public void ClassDecl.generateProlog(PrintStream s){
    }

    public void InterfaceDecl.generateProlog(PrintStream s){
    }
    
    
    // Main block (This is like the main in Pascal, I think ...)
    public void MainBlock.generateProlog(PrintStream s){
    }
    
    // Auxiliary methods

    protected static String ASTNode.initialToUpperCase(String s){
    	char[] cs = s.toCharArray();
    	cs[0] = Character.toUpperCase(cs[0]);
    	return new String(cs);
    }
    
    protected static String ASTNode.quote(String s){
    	return "'" + s + "'";
    }

}
