import java.util.LinkedList;
import abs.backend.scala.*;

aspect GenerateScala {
	public void Model.generateScala(File outputDir) throws IOException {
		for (CompilationUnit unit: getCompilationUnits())
			unit.generateScala(outputDir);
	}
	
	public void CompilationUnit.generateScala(File outputDir) throws IOException {
		for (ModuleDecl decl: getModuleDecls()) {			
			File moduleDir = new File(outputDir, decl.getName().replace('.', File.separatorChar));
			moduleDir.mkdirs();
			decl.generateScala(moduleDir);
		}
	}
	
	public void ModuleDecl.generateScala(File dir) throws IOException {
		// are we compiling the standard library?
		//if (!Constants.STDLIB_NAME.equals(getName())) {
		PrintWriter moduleWriter = new PrintWriter(new File(dir, "module.scala"));
		
		// stuff that's supposed to go into the package object
		final int lastDot = getName().lastIndexOf('.');
		final String parentPackage = lastDot > 0 ? getName().substring(0, lastDot) : "";
		final String thisPackage = lastDot > 0 ? getName().substring(lastDot + 1) : getName();
		
		if (lastDot > 0)
			moduleWriter.format("package %s%n", parentPackage);
		moduleWriter.println();
		moduleWriter.println("import akka.actor.{Actor, ActorRef}");
		moduleWriter.println("import abs.backend.scala.runtime._");
		moduleWriter.println("import scala.util.continuations._");
		//if (!getName().equals("ABS.StdLib"))
		//	moduleWriter.println("import ABS.StdLib._");
		moduleWriter.println();
		moduleWriter.format("package object %s {%n", thisPackage);
		for (Decl decl: getDecls())
			if (!decl.isClass() && !decl.isDataType() && !decl.isInterface())
				decl.generateScala("\t", moduleWriter);
		
		// quick hack, an extractor for URL string
		/*
		if (getName().equals("ABS.DC")) {
			moduleWriter.format(
					"\tdef _getDCConfiguration(dc: ActorRef): ABS.StdLib.DSet[ABS.DC.DDCDataElement] = %n" +
					"\t\t(dc !! ABS.DC.IDeploymentComponent.GetConfiguration) match {%n" +
					"\t\t\tcase None => throw new RuntimeException(\"No response from DC\")%n" +
					"\t\t\tcase Some(x) => x.asInstanceOf[ABS.DC.DCData].i1%n" +
					"\t\t}%n" +
					"\tdef _getURL(x: ABS.StdLib.DSet[ABS.DC.DDCDataElement]): Option[String] = x match {%n" +
					"\t\tcase ABS.StdLib.EmptySet() => None%n" +
					"\t\tcase ABS.StdLib.Insert(y, xs) => y match {%n" +
					"\t\t\tcase ABS.DC.URL(z) => Some(z)%n" +
					"\t\t\tcase _ => _getURL(xs)%n" +
					"\t\t}%n" +
					"\t}");
		}
		*/
		moduleWriter.println("}");
		
		moduleWriter.close();
		
		PrintWriter otherWriter = new PrintWriter(new File(dir, "classes.scala"));
		
		otherWriter.format("package %s%n", getName());
		otherWriter.println();
		otherWriter.println("import akka.actor.{Actor, ActorRef}");
		otherWriter.println("import abs.backend.scala.runtime._");
		otherWriter.println("import scala.util.continuations._");
		//if (!getName().equals("ABS.StdLib"))
		//	otherWriter.println("import ABS.StdLib._");
		otherWriter.println();
		
		for (Decl decl: getDecls())
			if (decl.isClass() || decl.isDataType() || decl.isInterface())
				decl.generateScala("", otherWriter);
	
		if (hasBlock()) {
			getBlock().generateScala("", otherWriter, getBlock().isSuspendable());
		}
		
		otherWriter.close();
			
		//} else {
			// yup, hack it!
		//}
	}
	
	public void MainBlock.generateScala(String prefix, PrintWriter writer, boolean isSuspendable) {
		writer.print(
				"class Main(private val cog: ActorRef) extends MyObject(cog) {\n" +
				"\tdef init(args: Array[Any]) {\n" +
				"\t}\n" +
				"\n" +
				"\tprivate def run(): Unit");
		
		boolean suspendable = isSuspendable();
		
		if (suspendable)
			writer.print(" @suspendable");
		
		writer.print(" = ");
		
		super.generateScala(prefix, writer, suspendable);
		
		writer.println(
				"\toverride def resolve: MyObject.Resolve = {\n" +
				"\t\tcase MyObject.Run => (\"Run\", () => { run() })\n" + 
				//"\t\tcase x => throw new RuntimeException(\"Unknown message received: \" + x)" +
				"\t}\n" +
				"}");
		/*
		writer.println(
				"\tdef receive = {\n" +
				"\t\tcase MyObject.Run => submit(\"run\")(() => { run() })\n" + 
				//"\t\tcase x => throw new RuntimeException(\"Unknown message received: \" + x)" +
				"\t}\n" +
				"}");
		*/		
		writer.print(
				"object Main {\n" +
				"  def main(argv : Array[String]) {\n" +
				"    abs.backend.scala.runtime.NodeManager.bootstrap(classOf[Main], argv)\n" +
				"  }\n" +
				"}");
				
		/*
		writer.print(
				"object Main {\n" +
				"  def main(argv: Array[String]) {\n" +
				"    val node = abs.backend.scala.runtime.NodeManager.newNode(argv(1))\n" +
				"    val cog = node ! abs.backend.scala.runtime.NodeManager.NewCog match {\n" +
				"      case None => throw new RuntimeException(\"No reply from initial node manager\")\n" +
				"      case Some(x) => x.asInstanceOf[Pair[akka.actor.ActorRef, Array[Byte]]]\n" +
				"    }\n" +
				"    cog ! new abs.backend.scala.runtime.Cog.New(classOf[Main], Seq.empty)\n" +
				"  }\n" +
				"}"); */
		/*
				"    val node = akka.actor.Actor.actorOf(new abs.backend.scala.runtime.NodeManager(\"\", 0)).start()\n" +
				"    val (cog, remoteCog) = node !! abs.backend.scala.runtime.NodeManager.NewLocalCog match {\n" +
				"      case None => throw new RuntimeException(\"No reply from initial node manager\")\n" +
				"      case Some(x) => x.asInstanceOf[Pair[akka.actor.ActorRef, Array[Byte]]]\n" +
				//"x.asInstanceOf[Array[Byte]] // RemoteActorSerialization.fromBinaryToRemoteActorRef(x.asInstanceOf[Array[Byte]])\n" +
				"    }\n" +
				"    cog ! new abs.backend.scala.runtime.Cog.Run(() => ");
		super.generateScala("      ", writer);
		writer.println(
				"  )}\n" +
				"}");
		*/
	}
	
	public abstract void Decl.generateScala(String prefix, PrintWriter output);
	
	public void DeltaDecl.generateScala(String prefix, PrintWriter output) {
		throw new RuntimeException("Should not happen: deltas should be gone by now");
	}

	public void FunctionDecl.generateScala(String prefix, PrintWriter writer) {
		writer.format(prefix + "def %s", ScalaUtils.mangleName(getName()));
		ScalaUtils.generateTypeParameters(this, writer);
		writer.write("(");
		boolean f = false;
		for (ParamDecl param: getParams()) {
			if (f) writer.write(", ");
			writer.write(abs.backend.scala.ScalaUtils.mangleName(param.getName()));
			writer.write(": "); 
			param.getAccess().generateScala(prefix, writer, new List<Annotation>());					
			f = true;
		}
		writer.write("): ");
		getTypeUse().generateScala(prefix, writer, getAnnotations());
		
		//StringWriter body = new StringWriter();
		boolean suspendable = getFunctionDef().isSuspendable();
		
		if (suspendable) 
			writer.write(" @suspendable");
		writer.println(" = ");
		getFunctionDef().generateScala("\t" + prefix, writer, suspendable);
		writer.println();
	}
	
	public abstract boolean FunctionDef.isSuspendable();
	public abstract void FunctionDef.generateScala(String prefix, PrintWriter writer, boolean suspendable);
	
	public boolean BuiltinFunctionDef.isSuspendable() {
		return false;
	}
	public void BuiltinFunctionDef.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
        final FunctionDecl decl = ((FunctionDecl)getContextDecl());
        final String functionName = decl.getName();
        final String moduleName = decl.getModule().getName();
        if (moduleName.equals(Constants.STDLIB_NAME)) {
            if (functionName.equals("substr")) {
                writer.write(prefix + "str.substring(start, start + length)");
                return;
            }
            if (functionName.equals("strlen")) {
                writer.write(prefix + "str.length()");
                return;
            }
            if (functionName.equals("currentms")) {
                writer.write("System.currentTimeMillis().toInt");
                return;
            }
            if (functionName.equals("toString")) {
                writer.write(prefix + "t.toString()");
                return;
            }
            if (functionName.equals("random")) {
                // FIXME this should be slightly more random
                writer.write("0");
                return;
            }
            
            // unsupported ones that we nonetheless handle by providing default values
            if (functionName.equals("currentms")) {
                writer.write("System.currentTimeMillis");
                return;
            }
            if (functionName.equals("lowlevelDeadline")) {
                writer.write("0");
                return;
            }
        }
        
        if (moduleName.equals("ABS.Meta")) {
            // if (decl.getName().equals("reflect")) {
                // unsupported
                writer.write("null");
                return;
            // }
        }
        
        if (moduleName.equals("ABS.DC")) {
            if (functionName.equals("thisDC")) {
                // FIXME
                writer.write(prefix + "null");
                return;
            }
        }
        
        final String fullFunctionName = moduleName + "." + functionName;
        
        // Functional break points not supported - just ignore the "watch" function:
        if (Constants.isFunctionalBreakPointFunctionName(fullFunctionName)) {
            writer.write(prefix + "val");
            return;
        }
                    
        throw new RuntimeException("Unsupported builtin function: " + fullFunctionName);
	}
	
	public boolean ExpFunctionDef.isSuspendable() {
		return getRhs().isSuspendable(new List<Annotation>());
	}
	public void ExpFunctionDef.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.write(prefix);
		getRhs().generateScala("\t" + prefix, writer, new List<Annotation>());
	}

	public void TypeDecl.generateScala(String prefix, PrintWriter writer) {
		writer.format("%stype %s = %s", prefix, getName(), getScalaType());
		writer.println();
	}

	public void UnknownDecl.generateScala(String prefix, PrintWriter writer) {
		throw new RuntimeException("Cowardly refusing to generate Scala for broken code.");
	}
	
	private void ClassDecl.generateScalaActorInvocation(String className, MethodSig s, PrintWriter writer) {
		String name = s.getName();
		writer.format("\t\tcase %s.%s", className, StringUtils.capitalize(name));
		if (s.getNumParam() > 0) {
			writer.print("(");
			
			for (int i = 0; i < s.getNumParam(); i++)
				writer.format("%sarg%d", i > 0 ? ", " : "", i);
			
			writer.print(")");
		}
		
		/*
		writer.format(" => log.debug(\"received %%s\".format(self)); submit(\"%s\") { %s(", StringUtils.capitalize(name), name);
		for (int i = 0; i < s.getNumParam(); i++)
			writer.format("%sarg%d", i > 0 ? ", " : "", i);
		writer.println(") }");
		*/		
		
		writer.format(" => log.debug(\"received %%s\".format(self)); (\"%s\", () => { %s(", StringUtils.capitalize(name), ScalaUtils.mangleName(name));
		for (int i = 0; i < s.getNumParam(); i++)
			writer.format("%sarg%d", i > 0 ? ", " : "", i);
		writer.println(") })");
	}
	public void ClassDecl.generateScala(String prefix, PrintWriter writer) {
		// messages for asynchronous calls to self
		writer.format(prefix + "object %s {%n", getName());
		
		// why oh why doesn't Java have a proper List.map :(
		ScalaUtils.generateMessages(new Iterable<MethodSig>() {
			@Override
			public Iterator<MethodSig> iterator() {
				final Iterator<MethodImpl> it = getMethods().iterator();
					
				return new Iterator<MethodSig>() {
					@Override
					public boolean hasNext() { return it.hasNext(); }
					
					@Override
					public MethodSig next() { return it.next().getMethodSig(); }
					
					@Override
					public void remove() { it.remove(); }
				};
			}
		}, writer, new List<Annotation>());
		writer.println(prefix + "}");
		writer.println(prefix);
		
		writer.format(prefix + "class %s(private val cog: ActorRef) extends MyObject(cog) {%n", getName());
		
		// import all messages from interfaces
		//for (InterfaceTypeUse intf: getImplementedInterfaceUses())
		//	intf.generateScala(prefix + "\t", writer);
		//writer.println();
		
		writer.println();
		
		// fields
		for (FieldDecl f: getFields())
			f.generateScala(prefix + "\t", writer, new List()); 
		for (ParamDecl p: getParams())
			p.generateScala(prefix + "\t", writer);
			
		writer.println();
		
		// fake constructor
		writer.println(prefix + "\tdef init(args: Array[Any]) {");
		// arguments
		for (int i = 0; i < getNumParam(); i++)
			getParam(i).generateScalaConstructor(i, writer);		
		writer.println(prefix + "\t}");
		writer.println(prefix);
		
		// TODO handle (ABS) init blocks
		
		for (MethodImpl m: getMethods())
			m.generateScala(prefix + "\t", writer);
		
		// methods
		//writer.println(prefix + "\tdef receive = {");
		writer.println(prefix + "\toverride def resolve: MyObject.Resolve = {");
		
		// standard stuff
		writer.print(prefix + "\t\tcase MyObject.Run => log.debug(\"%s: received Run\".format(self)); (\"Run\", () => { ");
		for (MethodImpl m: getMethods()) {
			if (m.getMethodSig().getName().equals("run") && m.getMethodSig().getNumParam() == 0) {
				//writer.print("submit(\"run\") { run() }");
				writer.print("run()");
				break;
			}
		}
		writer.println("})");
		
		// iterate over all the interfaces
		for (InterfaceTypeUse intf: getImplementedInterfaceUses())
			for (MethodSig sig: ((InterfaceDecl)intf.getDecl()).getBodys())
				generateScalaActorInvocation(intf.getDecl().getModule().getName() + ".I" + intf.getName(), sig, writer);
			
		// iterate over all the methods
		for (MethodImpl m: getMethods())
			generateScalaActorInvocation(getName(), m.getMethodSig(), writer);
		
		writer.println(prefix + "\t\tcase e => throw new RuntimeException(\"Unknown incoming message: %s\".format(e.toString))");
		writer.println(prefix + "\t}");
		
		writer.println(prefix);
		writer.println(prefix + "}");
		writer.println(prefix);
	}
	
	
	protected InitExpMetadata TypedVarOrFieldDecl.generateScalaInitExp(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) 
	{
		return new InitExpMetadata();
	}
	
	protected String TypedVarOrFieldDecl.getScalaName() {
		return ScalaUtils.mangleName(getName());
	}
	
	public boolean TypedVarOrFieldDecl.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		InitExpMetadata metadata = generateScalaInitExp("", new PrintWriter(new StringWriter()), annotations);
		
		return metadata.initExpSuspends();
	}
	public void TypedVarOrFieldDecl.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.format(prefix + "var %s: ", getScalaName());
		getAccess().generateScala(prefix, writer, annotations);
		
		InitExpMetadata metadata = generateScalaInitExp(prefix, writer, annotations);
		
		if (!metadata.hasInitExp())
			writer.print(" = null ");
		writer.println();
	}
	
	protected String FieldDecl.getScalaName() {
		return "f" + super.getScalaName();
	}
	
	protected InitExpMetadata FieldDecl.generateScalaInitExp(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		if (!hasInitExp())
			return new InitExpMetadata(false, false);
		
		writer.print(" = ");
		getInitExp().generateScala(prefix, writer, annotations);
		return new InitExpMetadata(true, getInitExp().isSuspendable(annotations));
	}
	
	protected InitExpMetadata VarDecl.generateScalaInitExp(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		if (!hasInitExp())
			return new InitExpMetadata(false, false);

		writer.print(" = ");
		getInitExp().generateScala(prefix, writer, annotations);
		return new InitExpMetadata(true, getInitExp().isSuspendable(annotations));
	}
	
	public void ParamDecl.generateScalaConstructor(int offset, PrintWriter writer) {
		writer.format("\t\tthis.%s = ", abs.backend.scala.ScalaUtils.mangleName(getName()));
		String type = getAccess().getScalaType();
		writer.format("args(%d).asInstanceOf[%s]", offset, type);
		writer.println();
	}
	
	public boolean ParamDecl.generateScala(String prefix, PrintWriter writer) {
		writer.format(prefix + "private var %s: ", abs.backend.scala.ScalaUtils.mangleName(getName()));
		getAccess().generateScala(prefix, writer, new List<Annotation>());
		writer.println(" = _");
		return false;
	}

	public void InterfaceDecl.generateScala(String prefix, PrintWriter writer) {
		writer.format("object I%s {%n", getName());
		writer.println("\tsealed trait Message");
		for (MethodSig s: getBodys()) {
			// run method is special, that will be handled by MyObject.Run
			//if (s.getName().equals("run"))
			//	continue;
			
			writer.format("\tcase %s %s", 
					(s.getNumParam() == 0 ? "object" : "class"),
					StringUtils.capitalize(s.getName()));
			
			if (s.getNumParam() > 0) {
				boolean f = false;
				int i = 0;
				
				writer.write("(");
				
				for (ParamDecl param: s.getParams()) {
					if (f)
						writer.write(", ");
					writer.write(ScalaUtils.mangleName(param.getName()) + ": "); param.getAccess().generateScala("", writer, new List<Annotation>());					
					f = true;
				}
				
				writer.write(")");
			}
			
			writer.println(" extends Message");
		}
		writer.println("}");
		writer.println();
	}
	
	public void ParametricDataTypeDecl.generateScala(String prefix, PrintWriter writer) {
		// specific hacks for standard library
		if (getModule().getName().equals("ABS.StdLib")) {
			if (getName().equals("Unit") || getName().equals("Int") ||
					getName().equals("String") || getName().equals("Bool") ||
					getName().equals("Fut"))
				return;
			
			/*
			if (getName().equals("Unit")) {
				writer.println("type Unit = scala.Unit");
				return;
			} else if (getName().equals("Int")) {
				writer.println("type Int = scala.Int");
				return;
			} else if (getName().equals("String")) {
				writer.println("type String = java.lang.String");
				return;
			} else if (getName().equals("Bool")) {
				writer.println("type Bool = scala.Boolean");
				return;
		 	} else if (getName().equals("Maybe")) {
				writer.println("type Maybe[A] = scala.Option[A]");
				return;
			} else if (getName().equals("Either")) {
				writer.println("type Either[A, B] = scala.Either[A, B]");
				return;
			} else if (getName().equals("Pair")) {
				writer.println("type Pair[A, B] = (A, B)");
				return;
			} else if (getName().equals("Triple")) {
				writer.println("type Triple[A, B, C] = (A, B, C)");
				return;
			}
			*/
		}
		
		
		writer.format(prefix + "sealed trait D%s", getName());
		abs.backend.scala.ScalaUtils.generateTypeParameters(this, writer);
		writer.println();
		for (DataConstructor constructor: getDataConstructors())
			constructor.generateScala(prefix, writer);
		writer.println(prefix);
	}
	
	public void DataConstructor.generateScala(String prefix, PrintWriter writer) {
		writer.format("case class %s", getName());
		abs.backend.scala.ScalaUtils.generateTypeParameters(((DataTypeType)getType()).getDecl(), writer);
		writer.print("(");
		
		boolean f = false;
		int i = 0;

		for (ConstructorArg arg: getConstructorArgs()) {
			if (f)
				writer.write(", ");
			writer.format("i%d: ", ++i); arg.getDataTypeUse().generateScala(prefix, writer, new List<Annotation>());
			f = true;
		}
		writer.print(") extends D" + getDataTypeDecl().getName());
		abs.backend.scala.ScalaUtils.generateTypeParameters(((DataTypeType)getType()).getDecl(), writer);
		writer.println();
	}

	public abstract boolean Access.isSuspendable(abs.frontend.ast.List<Annotation> annotations);
	public abstract void Access.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations);
	public abstract String Access.getScalaType();
	
	public String Decl.getScalaType() {
		// hacks for types in standard library
		if (getModule().getName().equals("ABS.StdLib")) {
			if (getName().equals("Unit") || getName().equals("Int") ||
					getName().equals("String"))
				return getName();
			if (getName().equals("Bool"))
				return "Boolean";
		}
		
		if (isInterface())
			return "ActorRef";
		if (isFuture())
			return "ActorRef";
		if (isDataType())
			return getModule().getName() + ".D" + getName();
		if (isTypeParameter())
			return getName();
		if (isTypeSyn())
			return ((TypeSynDecl)this).getValue().getScalaType();
		else
			throw new NotImplementedYetException(this);
			// FIXME
			//throw new NotImplementedYetException("Unimplemented decl type: " + getDecl().getClass().getName());
	}
	
	public String DataTypeUse.getScalaType() {
		return getDecl().getScalaType();
	}
	
	public boolean DataTypeUse.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return false;
	}
	public void DataTypeUse.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		writer.write(getScalaType());
	}
	
	
	public String ParametricDataTypeUse.getScalaType() {
		// hacks for types in standard library
		if (getDecl().getModule().getName().equals("ABS.StdLib")) {
			if (getDecl().getName().equals("Fut"))
				return "ActorRef";
		}
		
		StringBuilder builder = new StringBuilder();
		builder.append(getDecl().getModule().getName());
		builder.append(".");
		
		if (getDecl().isDataType())
			builder.append("D");
		builder.append(getName());
		
		if (getNumParam() > 0) {
			builder.append("[");
			boolean f = false;
			for (DataTypeUse t: getParams()) {
				if (f) builder.append(", ");
				builder.append(t.getScalaType());
				f = true;
			}
			builder.append("]");
		}
		
		return builder.toString();
	}
	
	public String InterfaceTypeUse.getScalaType() {
		throw new NotImplementedYetException(this);
		// FIXME
	}
	
	public boolean InterfaceTypeUse.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return false;
	}
	public void InterfaceTypeUse.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		for (InterfaceTypeUse intf: ((InterfaceDecl)getDecl()).getExtendedInterfaceUses())
			intf.generateScala(prefix, writer, annotations);

		//writer.format(prefix + "import %s._%n", getName());
	}
	
	public String TypeParameterUse.getScalaType() {
		throw new NotImplementedYetException(this);
		// FIXME
	}
	
	public boolean TypeParameterUse.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		throw new NotImplementedYetException(this);
	}
	public void TypeParameterUse.generateScala(String prefix, PrintWriter output, List<Annotation> annotations) {
		throw new NotImplementedYetException(this);
		// FIXME
	}
	
	public String UnresolvedTypeUse.getScalaType() {
		throw new RuntimeException("This should not happen");
	}
	
	
	public boolean UnresolvedTypeUse.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		throw new RuntimeException("This should not happen");
	}
	public void UnresolvedTypeUse.generateScala(String prefix, PrintWriter output, List<Annotation> annotations) {
		throw new RuntimeException("This should not happen");
	}
	
	public String FieldUse.getScalaType() {
		throw new NotImplementedYetException(this);
		// FIXME
	}
	
	public boolean FieldUse.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return false;
	}
	public void FieldUse.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		writer.format("this.f%s", abs.backend.scala.ScalaUtils.mangleName(getName()));
	}
	
	public String VarUse.getScalaType() {
		throw new NotImplementedYetException(this);
		// FIXME
	}
	
	public boolean VarUse.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return false;
	}
	@Override
	public void VarUse.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		//writer.print("/* "); writer.print(getDecl().getClass().getName()); writer.print("*/");
		if (getDecl() instanceof FieldDecl)
			writer.print("f");
		writer.print(abs.backend.scala.ScalaUtils.mangleName(getName()));
	}
		
	public void MethodImpl.generateScala(String prefix, PrintWriter writer) {
		writer.format(prefix + "private def %s(", ScalaUtils.mangleName(getMethodSig().getName()));
		
		boolean f = false;
		
		for (ParamDecl param: getMethodSig().getParams()) {
			if (f)
				writer.write(", ");
			writer.write(abs.backend.scala.ScalaUtils.mangleName(param.getName()) + ": "); param.getAccess().generateScala("", writer, new List<Annotation>());					
			f = true;
		}
		
		writer.print("): ");
		getMethodSig().getReturnType().generateScala(prefix, writer, new List<Annotation>());
		
		boolean suspendable = getBlock().isSuspendable();
		 
		if (suspendable)
			writer.print(" @suspendable");
		
		writer.print(" = ");
		
		getBlock().generateScala(prefix, writer, suspendable);
		
		writer.println();
	}

	public abstract boolean Stmt.isSuspendable();	
	public abstract void Stmt.generateScala(String prefix, PrintWriter writer, boolean suspendable);
	
	public boolean Block.isSuspendable() {
		for (Stmt stmt: getStmts()) {
			if (stmt.isSuspendable())
				return true;
		}
		
		return false;
	}
	
	public void Block.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.println("{");
		
		for (Stmt stmt: getStmts())
			stmt.generateScala(prefix + "\t", writer, suspendable); 
		
		writer.println(prefix + "}");
	}
	
	public boolean ReturnStmt.isSuspendable() {
		return getRetExp().isSuspendable(getAnnotations());
	}
	public void ReturnStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.write(prefix + "return ");
		boolean expSuspendable = isSuspendable();
		
		if (suspendable && !expSuspendable)
			writer.write("wrap(");
		getRetExp().generateScala(prefix, writer, getAnnotations());
		
		if (suspendable && !expSuspendable)
			writer.write(")");
		
		writer.println();
	}
	
	public boolean AssignStmt.isSuspendable() {
		return getValue().isSuspendable(getAnnotations());
	}
	public void AssignStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.write(prefix);
		getVar().generateScala(prefix, writer, getAnnotations());
		writer.write(" = ");
		getValue().generateScala(prefix, writer, getAnnotations());
		writer.println();
	}
	
	public boolean AssertStmt.isSuspendable() {
		return getCondition().isSuspendable(getAnnotations());
	}
	public void AssertStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.print(prefix + "if (!("); 
		getCondition().generateScala(prefix + "\t", writer, getAnnotations()); 
		writer.println("))");
		writer.format(prefix + "\tthrow new AssertionError(\"%sAssert failed\");%n", new Position(this).getPositionString());
	}
	
	public boolean WhileStmt.isSuspendable() {
		return getCondition().isSuspendable(getAnnotations()) || getBody().isSuspendable();
	} 
	public void WhileStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.print(prefix + "while (");
		getCondition().generateScala(prefix, writer, getAnnotations());
		writer.println(")");
		getBody().generateScala(prefix + "\t", writer, suspendable);
	}
	
	public boolean VarDeclStmt.isSuspendable() {
		return getVarDecl().isSuspendable(getAnnotations());
	}
	public void VarDeclStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		getVarDecl().generateScala(prefix, writer, getAnnotations());
	}
	
	public boolean SuspendStmt.isSuspendable() {
		return true;
	}
	public void SuspendStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.println(prefix + "suspend()");
	}

	public boolean IfStmt.isSuspendable() {
		return getCondition().isSuspendable(getAnnotations()) || getThen().isSuspendable() || (hasElse() && getElse().isSuspendable());
	}
	public void IfStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.write(prefix + "if (");
		getCondition().generateScala(prefix + "\t", writer, getAnnotations());
		writer.write(")");
		
		StringWriter thenWriter = new StringWriter();
		StringWriter elseWriter = new StringWriter();
		
		getThen().generateScala(getThen() instanceof Block ? prefix : prefix + "\t", new PrintWriter(thenWriter), isSuspendable());
		boolean thenFlag = getThen().isSuspendable();
		boolean elseFlag = false;
		
		if (hasElse()) {
			getElse().generateScala(getElse() instanceof Block ? prefix : prefix + "\t", new PrintWriter(elseWriter), isSuspendable());
			elseFlag = getElse().isSuspendable();
		}
		
		// mash things together
		if (!(getThen() instanceof Block) || (elseFlag && !thenFlag))
			writer.println("{");
		writer.write(thenWriter.getBuffer().toString());
		if (elseFlag && !thenFlag)
			writer.println(prefix + "\tnoop");
		if (!(getThen() instanceof Block) || (elseFlag && !thenFlag))
			writer.println(prefix + "}");
		
		if (hasElse() || (thenFlag && !elseFlag)) {
			writer.write(prefix + "else ");
			
			if ((hasElse() && !(getElse() instanceof Block)) || (thenFlag && !elseFlag))
				writer.println("{");
			writer.write(elseWriter.getBuffer().toString());
			if (thenFlag && !elseFlag)
				writer.println(prefix + "\tnoop");
			if ((hasElse() && !(getElse() instanceof Block)) || (thenFlag && !elseFlag))
				writer.println(prefix + "}");
		}
	}
	
	public boolean ExpressionStmt.isSuspendable() {
		return getExp().isSuspendable(getAnnotations());
	}
	public void ExpressionStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.write(prefix);
		writer.write("ignore(");
		//writer.write("val _ = ");
		getExp().generateScala(prefix, writer, getAnnotations());
		writer.write(")");
		writer.println();
	}
	
	public boolean AwaitStmt.isSuspendable() {
		return true;
	}
	public void AwaitStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.write(prefix + "await(");
		getGuard().generateScala(prefix, writer, getAnnotations());
		writer.println(")");
	}
	
	public abstract void Guard.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations);
	
	public void AndGuard.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		getLeft().generateScala(prefix, writer, annotations);
		writer.write(" && ");
		getRight().generateScala(prefix, writer, annotations);
	}
	
	public void ClaimGuard.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		writer.write("fut2bool("); getVar().generateScala(prefix, writer, annotations); writer.write(")");
	}
	
	public void DurationGuard.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		writer.write("true");
	}
	
	public void ExpGuard.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		getPureExp().generateScala(prefix, writer, annotations);
	}
	
	public boolean IncompleteStmt.isSuspendable() {
		throw new RuntimeException("This should not happen: can't compile IncompleteStmt, go fix the frontend!");
	}
	public void IncompleteStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		throw new RuntimeException("This should not happen: can't compile IncompleteStmt, go fix the frontend!");
	}
	
	public boolean SkipStmt.isSuspendable() {
		return false;
	}
	public void SkipStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.println(prefix + "{}");
	}
	
	public boolean MoveCogToStmt.isSuspendable() {
		return false;
	}
	public void MoveCogToStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		writer.println(prefix + "{}");
	}

	public boolean DurationStmt.isSuspendable() {
		return false;
	}
	public void DurationStmt.generateScala(String prefix, PrintWriter writer, boolean suspendable) {
		System.err.println("Warning: Duration statements are not supported by the Scala backend");
		writer.println(prefix + "{}");
	}
	
	/*
	 * @return true if the expression includes something that may block (resolving a future); false otherwise
	 */
	public abstract boolean Exp.isSuspendable(abs.frontend.ast.List<Annotation> annotations);
	public abstract void Exp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations);
	
	public boolean ThisExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return false;
	}
	public void ThisExp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.write("self");
	}
	
	public boolean DataConstructorExp.isSuspendable(List<Annotation> annotations) {
		return false;
	}
	public void DataConstructorExp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		if (getDecl().getModule().getName().equals("ABS.StdLib")) {
			if (getDecl().getName().equals("True")) {
				writer.write("true");
				return;
			}
			if (getDecl().getName().equals("False")) {
				writer.write("false");
				return;
			}
		}
		
		writer.write("new ");
		writer.write(getDataConstructor().getType().getModuleName());
		writer.write(".");
		writer.write(getConstructor());
		    
			writer.write("(");
			boolean f = false;
			for (PureExp param: getParams()) {
				if (f) writer.write(", ");
				param.generateScala(prefix, writer, annotations);
				f = true;
			}
			writer.write(")");
	}
	
	public boolean CaseExp.isSuspendable(List<Annotation> annotations) {
		if (getExpr().isSuspendable(annotations))
			return true;
			
		for (CaseBranch branch: getBranchs())
			if (branch.isSuspendable(annotations))
				return true;
		
		return false;
	}
	public void CaseExp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		getExpr().generateScala(prefix, writer, annotations);
		writer.println(" match { ");
		for (CaseBranch branch: getBranchs())
			branch.generateScala("\t" + prefix, writer, annotations);
			 
		writer.print(prefix + "}");
	}
	
	public boolean CaseBranch.isSuspendable(List<Annotation> annotations) {
		return getRight().isSuspendable(annotations);
	}
	public void CaseBranch.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.print(prefix + "case ");
		Collection<PatternVarUse> varUses = new LinkedList<PatternVarUse>();
		getLeft().generateScala(prefix, writer, varUses, annotations);
		if (!varUses.isEmpty()) {
			writer.print(" if ");
			boolean b = false;
			for (PatternVarUse varUse: varUses) {
				if (b) writer.print(" && ");
				writer.format("_%s == %s", 
						abs.backend.scala.ScalaUtils.mangleName(varUse.getName()), 
						abs.backend.scala.ScalaUtils.mangleName(varUse.getName()));
				b = true;
			}
		}
		writer.print(" => ");
		getRight().generateScala(prefix, writer, annotations);
		writer.println();
	}
	
	public boolean LetExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return getVal().isSuspendable(annotations) || getExp().isSuspendable(annotations);
	}
	public void LetExp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.print("let (");
		getVal().generateScala(prefix, writer, annotations);
		writer.print(") {");
		writer.print(abs.backend.scala.ScalaUtils.mangleName(getVar().getName()));
		writer.print(": ");
	    getVar().getAccess().generateScala(prefix, writer, annotations);
		writer.print(" => ");
		getExp().generateScala(prefix, writer, annotations);
		writer.print("}");
	}
	
	public abstract void Pattern.generateScala(String prefix, PrintWriter writer, Collection<PatternVarUse> varUses, abs.frontend.ast.List<Annotation> annotations);
	
	public void UnderscorePattern.generateScala(String prefix, PrintWriter writer, Collection<PatternVarUse> varUses, abs.frontend.ast.List<Annotation> annotations) {
		writer.write("_");
	}
	
	public void ConstructorPattern.generateScala(String prefix, PrintWriter writer, Collection<PatternVarUse> varUses, abs.frontend.ast.List<Annotation> annotations) {
		//if (getContextDecl().getModule().getName().equals("ABS.StdLib")) {
		if (getDataConstructor().getModule().getName().equals("ABS.StdLib")) {
			if (getConstructor().equals("True")) {
				writer.write("true");
				return;
			}
			
			if (getConstructor().equals("False")) {
				writer.write("false");
				return;
			}
		}
		
		writer.write(getDataConstructor().getModule().getName());
		writer.write(".");
		writer.write(getConstructor());
		
		
		//if (getNumParam() > 0) {
			writer.write("(");
			boolean b = false;
			for (Pattern p: getParams()) {
				if (b) writer.write(", ");
				p.generateScala(prefix, writer, varUses, annotations);
				b = true;
			}
			writer.write(")");
		//}
	}
	
	public void LiteralPattern.generateScala(String prefix, PrintWriter writer, Collection<PatternVarUse> varUses, abs.frontend.ast.List<Annotation> annotations) {
		getLiteral().generateScala(prefix, writer, annotations);
	}
	
	public void PatternVar.generateScala(String prefix, PrintWriter writer, Collection<PatternVarUse> varUses, abs.frontend.ast.List<Annotation> annotations) {
		writer.write(abs.backend.scala.ScalaUtils.mangleName(getVar().getName()));
	}
	
	public void PatternVarUse.generateScala(String prefix, PrintWriter writer, Collection<PatternVarUse> varUses, abs.frontend.ast.List<Annotation> annotations) {
		writer.write("_" + abs.backend.scala.ScalaUtils.mangleName(abs.backend.scala.ScalaUtils.mangleName(getName())));
		varUses.add(this);
	}
	
	protected abstract String Unary.getScalaOperator();
	
	public final boolean Unary.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return getOperand().isSuspendable(annotations);
	}
	public final void Unary.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.write(getScalaOperator());
		writer.write("(");
		getOperand().generateScala(prefix, writer, annotations);
		writer.write(")");
	}
	
	protected final String NegExp.getScalaOperator() { return "!"; }
	protected final String MinusExp.getScalaOperator() { return "-"; }
	
	protected abstract String Binary.getScalaOperator();
	
	public final boolean Binary.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return getLeft().isSuspendable(annotations) || 
		       getRight().isSuspendable(annotations);
	}
	public final void Binary.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.write("(");
		getLeft().generateScala(prefix, writer, annotations);
		writer.format(") %s (", getScalaOperator());
		getRight().generateScala(prefix, writer, annotations);
		writer.write(")");
	}
	
	protected final String AndBoolExp.getScalaOperator() { return "&&"; }
	protected final String OrBoolExp.getScalaOperator() { return "||"; }
	protected final String EqExp.getScalaOperator() { return "=="; }
	protected final String NotEqExp.getScalaOperator() { return "!="; }
	protected final String GTEQExp.getScalaOperator() { return ">="; }
	protected final String GTExp.getScalaOperator() { return ">"; }
	protected final String LTEQExp.getScalaOperator() { return "<="; }
	protected final String LTExp.getScalaOperator() { return "<"; }
	protected final String AddAddExp.getScalaOperator() { return "+"; }
	protected final String SubAddExp.getScalaOperator() { return "-"; }
	protected final String MultMultExp.getScalaOperator() { return "*"; }
	protected final String DivMultExp.getScalaOperator() { return "/"; }
	protected final String ModMultExp.getScalaOperator() { return "%"; }
	
	public boolean LiteralExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return false;
	}
	public void IntLiteral.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.write(getContent());
	}
	
	public void StringLiteral.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.write("\"");
		writer.write(getContent());
		writer.write("\"");
	}
	
	public abstract boolean PureExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations);
	public abstract void PureExp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations); 

	public boolean FnApp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		for (PureExp p: getParams())
			if (p.isSuspendable(annotations))
				return true;
		return false;
	}
	public void FnApp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.format("%s(", getDecl().moduleName() + "." + ScalaUtils.mangleName(getName()));
		boolean f = false;
		for (PureExp p: getParams()) {
			if (f) writer.write(", ");
			p.generateScala(prefix, writer, annotations); 
			f = true;
		}
		writer.write(")");
	}
			
	// EffExp
	public boolean NewExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		if (hasCog()) {
			PureExp dc = null;
			
			for (Annotation a: annotations) {
				if (!(a instanceof TypedAnnotation))
					continue;
				
				TypedAnnotation ta = (TypedAnnotation)a;
				
				if (!(ta.getAccess() instanceof DataTypeUse))
					continue;
				
				Decl d = ((DataTypeUse)ta.getAccess()).getDecl();
				
				if (d instanceof TypeSynDecl)
					d = ((TypeSynDecl)d).getValue().getDecl();
				
				if (d.qualifiedName().equals("ABS.DC.CogLocation")) {
					// score!
					dc = a.getValue();
					break;
				}
			}
			
			if (dc != null)
				return true;
		}
		
		for (PureExp param: getParams())
			if (param.isSuspendable(annotations))
				return true;
				
		return false;
	}
	
	public void NewExp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.print("_new");
		
		if (hasCog()) {
			PureExp dc = null;
			
			for (Annotation a: annotations) {
				if (!(a instanceof TypedAnnotation))
					continue;
				
				TypedAnnotation ta = (TypedAnnotation)a;
				
				if (!(ta.getAccess() instanceof DataTypeUse))
					continue;
				
				Decl d = ((DataTypeUse)ta.getAccess()).getDecl();
				
				if (d.qualifiedName().equals("ABS.DC.CogLocation")) {
					// score!
					dc = a.getValue();
				}
			}
			writer.print("cog(");
						
			if (dc != null) {
				writer.print("Some(");
				dc.generateScala(prefix, writer, annotations);
				writer.print("), ");
			}
			else
				writer.print("None, "); 
		}
		else
			writer.print("(");
		
		writer.format("classOf[_root_.%s]", (((UnionType)getType()).getOriginatingClass()).qualifiedName());
		
		
		for (PureExp param: getParams()) {
			writer.write(", ");
			param.generateScala(prefix, writer, annotations); 
		}
		
		writer.println(")");
	}
	
	// EffExp
	public boolean GetExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return true;
	}
	public void GetExp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		writer.write("getFuture(");
		getPureExp().generateScala(prefix, writer, annotations);
		writer.format(")"); // .asInstanceOf[%s]", getType().getDecl().getScalaType());
	}
	
	// EffExp
	public boolean OriginalCall.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		throw new RuntimeException("Should not happen: deltas haven't been flattened away, go fix the frontend!");
	}
	public void OriginalCall.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		throw new RuntimeException("Should not happen: deltas haven't been flattened away, go fix the frontend!");
	}
	
	// Call	
	public boolean Call.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		if (getCallee().isSuspendable(annotations))
			return true;
		
		for (PureExp args: getParams())
			if (args.isSuspendable(annotations))
				return true;
		
		return false;
	}
	public void Call.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
	
		if (this instanceof SyncCall)
			writer.write("syncCall(");
		else
			writer.write("asyncCall(");
		getCallee().generateScala(prefix, writer, annotations);
		writer.write(", ");
		
		if (getNumParam() > 0)
			writer.write("new ");
					
		writer.format("%s.%s%s.%s",
				getMethodSig().getContextDecl().getModule().getName(),
				getMethodSig().getContextDecl().isInterface() ? "I" : "", getMethodSig().getContextDecl().getName(),
				StringUtils.capitalize(getMethod()));

		if (getNumParam() > 0) {
			writer.write("(");
			boolean f = false;
			for (PureExp args: getParams()) {
				if (f)
					writer.write(", ");
				args.generateScala(prefix, writer, annotations);
				f = true;
			}
			writer.write(")");
		}
		writer.write(")");
	}
	
	public boolean IfExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return getCondExp().isSuspendable(annotations) || getThenExp().isSuspendable(annotations) || getElseExp().isSuspendable(annotations);
	}
	public void IfExp.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		writer.write("if (");
		getCondExp().generateScala(prefix, writer, annotations);
		writer.write(") ");
		getThenExp().generateScala(prefix, writer, annotations);
		writer.write(" else ");
		getElseExp().generateScala(prefix, writer, annotations);
	}
	
	public boolean NullExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		return false;
	}
	public void NullExp.generateScala(String prefix, PrintWriter writer, List<Annotation> annotations) {
		writer.write("null");
	}

	public final boolean IncompleteExp.isSuspendable(abs.frontend.ast.List<Annotation> annotations) {
		throw new RuntimeException("Should not happen: incomplete expression, go fix the frontend!");
	}		
	public final void IncompleteExp.generateScala(String prefix, PrintWriter writer, abs.frontend.ast.List<Annotation> annotations) {
		throw new RuntimeException("Should not happen: incomplete expression, go fix the frontend!");
	}
}