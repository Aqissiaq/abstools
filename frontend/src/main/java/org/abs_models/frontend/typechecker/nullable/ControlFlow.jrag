import org.abs_models.frontend.typechecker.nullable.SimpleSet;

aspect ControlFlow {

	public interface CFGNode {
   	
  }

	Stmt implements CFGNode;
	CaseBranchStmt implements CFGNode;

	//== Entry / Exit ==
	
	syn nta Stmt MethodImpl.entry() = new SkipStmt();
	syn nta Stmt MethodImpl.exit() = new SkipStmt();

	eq MethodImpl.entry().following() = new SimpleSet<CFGNode>(getBlock());
	eq MethodImpl.getBlock().following() = new SimpleSet<CFGNode>(exit());
	eq MethodImpl.exit().following() = new SimpleSet<CFGNode>();
	
	inh Stmt Stmt.exit();
	eq MethodImpl.getBlock().exit() = exit();
	eq MethodImpl.entry().exit() = exit();
	eq MethodImpl.exit().exit() = null;

	//== Predecessors ==
	
	coll SimpleSet<CFGNode> CFGNode.pred() with add root MethodImpl;
	// Stmt contributes this to CFGNode.pred() for each succ();

	// NTAs are not, in general, included in the collection attribute traversal; we have to fudge around this
  protected void MethodImpl.collect_contributors_CFGNode_pred(MethodImpl _root, java.util.Map<ASTNode, java.util.Set<ASTNode>> _map) {
  	entry().collect_contributors_CFGNode_pred(_root, _map);
  	exit().collect_contributors_CFGNode_pred(_root, _map);
  	super.collect_contributors_CFGNode_pred(_root, _map);
  }

	// Do this manually because of a bug in JastAdd
	protected void Stmt.collect_contributors_CFGNode_pred(MethodImpl _root, java.util.Map<ASTNode, java.util.Set<ASTNode>> _map) {
    for (CFGNode target : (Iterable<? extends CFGNode>) (succ())) {
      ASTNode _targetRoot = (ASTNode) target;
      ASTNode _targetParent = (ASTNode) target;
      while (_targetParent != null) {
        _targetParent = _targetParent.getParent();
        if (_targetParent instanceof MethodImpl) {
          _targetRoot = _targetParent;
        }
      }
      ASTNode _sourceRoot = _root;
      ASTNode _sourceParent = _root;
      while (_sourceParent != null) {
        _sourceParent = _sourceParent.getParent();
        if (_sourceParent instanceof MethodImpl) {
          _sourceRoot = _sourceParent;
        }
      }
      if (_targetRoot != _sourceRoot) {
        throw new RuntimeException("Contribution source and target do not share a common collection "
            + "root node for collection attribute CFGNode.pred().");
      }
      java.util.Set<ASTNode> contributors = _map.get(target);
      if (contributors == null) {
        contributors = new java.util.LinkedHashSet<ASTNode>();
        _map.put((ASTNode) target, contributors);
      }
      contributors.add(this);
    }
    super.collect_contributors_CFGNode_pred(_root, _map);
  }

	protected void Stmt.contributeTo_CFGNode_pred(SimpleSet<CFGNode> collection) {
    super.contributeTo_CFGNode_pred(collection);
    collection.add(this);
  }

	// Do this manually because of a bug in JastAdd
	protected void CaseBranchStmt.collect_contributors_CFGNode_pred(MethodImpl _root, java.util.Map<ASTNode, java.util.Set<ASTNode>> _map) {
    for (CFGNode target : (Iterable<? extends CFGNode>) (succ())) {
      ASTNode _targetRoot = (ASTNode) target;
      ASTNode _targetParent = (ASTNode) target;
      while (_targetParent != null) {
        _targetParent = _targetParent.getParent();
        if (_targetParent instanceof MethodImpl) {
          _targetRoot = _targetParent;
        }
      }
      ASTNode _sourceRoot = _root;
      ASTNode _sourceParent = _root;
      while (_sourceParent != null) {
        _sourceParent = _sourceParent.getParent();
        if (_sourceParent instanceof MethodImpl) {
          _sourceRoot = _sourceParent;
        }
      }
      if (_targetRoot != _sourceRoot) {
        throw new RuntimeException("Contribution source and target do not share a common collection "
            + "root node for collection attribute CFGNode.pred().");
      }
      java.util.Set<ASTNode> contributors = _map.get(target);
      if (contributors == null) {
        contributors = new java.util.LinkedHashSet<ASTNode>();
        _map.put((ASTNode) target, contributors);
      }
      contributors.add(this);
    }
    super.collect_contributors_CFGNode_pred(_root, _map);
  }

	protected void CaseBranchStmt.contributeTo_CFGNode_pred(SimpleSet<CFGNode> collection) {
    super.contributeTo_CFGNode_pred(collection);
    collection.add(this);
  }

	//== Successors ==
	
	// TODO: Handle exceptions

	/**
	 * All possible Statements that could follow this one
	 */
	syn SimpleSet<CFGNode> CFGNode.succ() = following();
	/**
	 * The next statement in the AST
	 */
	inh SimpleSet<CFGNode> CFGNode.following();

	// TODO: AssertStmt

	eq Block.succ() = getNumStmt() != 0
		? SimpleSet.<CFGNode>empty().union(getStmt(0)) 
		: following();
	eq Block.getStmt(int i).following() = i != getNumStmt() - 1
		? SimpleSet.<CFGNode>empty().union(getStmt(i+1))
		: following();

	
	// TODO: A more granular control flow cannot be modelled right now, because we would need a common interface for Stmt/Exp/CaseBranchStmt(/Pattern)
	// That currently results in an error in the generated code, but maybe I'm doing it wrong?
	inh CaseStmt CaseBranchStmt.parentCase();
	eq CaseStmt.getBranch(int i).parentCase() = this;
	eq CaseBranchStmt.getRight().following() = parentCase().following();

	// TODO: What is a DieStmt?

	// TODO: ForeachStmt

	eq IfStmt.succ() = hasElse()
		? SimpleSet.<CFGNode>empty().union(getThen()).union(getElse())
		: following().union(getThen());

	// TODO: What is a MoveCogToStmt?

	// ReturnStmt does not need extra handling. It has to be the last stmt

	// TODO: ThrowStmt

	// TODO: TryCatchFinally
	eq TryCatchFinallyStmt.getBody().following() = hasFinally()
		? new SimpleSet<CFGNode>(getFinally())
		: following();
	eq TryCatchFinallyStmt.getFinally().following() = following();

	eq WhileStmt.succ() = following().union(getBody());
	eq WhileStmt.getBody().following() = SimpleSet.<CFGNode>empty().union(this);

	inh Stmt Exp.parentStmt();

	eq AssertStmt.getCondition().parentStmt() = this;

	eq AssignStmt.getVar().parentStmt() = this;
	eq AssignStmt.getValue().parentStmt() = this;

	// TODO: await

	eq CaseStmt.getExpr().parentStmt() = this;
	// TODO: Handle patterns

	eq DieStmt.getReason().parentStmt() = this;

	eq DurationStmt.getMin().parentStmt() = this;
	eq DurationStmt.getMax().parentStmt() = this;

	eq ExpressionStmt.getExp().parentStmt() = this;

	eq ForeachStmt.getListExp().parentStmt() = this;

	eq IfStmt.getCondition().parentStmt() = this;

	eq MoveCogToStmt.getTarget().parentStmt() = this;

	eq ReturnStmt.getRetExp().parentStmt() = this;

	eq ThrowStmt.getReason().parentStmt() = this;

	inh Stmt VarDecl.parentStmt();
	eq VarDeclStmt.getVarDecl().parentStmt() = this;

	eq WhileStmt.getCondition().parentStmt() = this;
}
