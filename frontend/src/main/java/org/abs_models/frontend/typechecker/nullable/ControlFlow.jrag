import org.abs_models.frontend.typechecker.nullable.SimpleSet;

aspect ControlFlow {

	public interface CFGNode {
   	
  }

	Stmt implements CFGNode;
	CaseBranchStmt implements CFGNode;

	//== Entry / Exit ==
	
	syn nta CFGEntry MethodImpl.entry() = new CFGEntry();
	syn nta CFGExit MethodImpl.exit() = new CFGExit();
	syn String CFGEntry.toString() = "Entry";
	syn String CFGExit.toString() = "Exit";

	eq MethodImpl.entry().following() = new SimpleSet<CFGNode>(getBlock());
	eq MethodImpl.getBlock().following() = new SimpleSet<CFGNode>(exit());
	eq MethodImpl.exit().following() = new SimpleSet<CFGNode>();
	
	inh Stmt Stmt.exit();
	eq MethodImpl.getBlock().exit() = exit();
	eq MethodImpl.entry().exit() = exit();
	eq MethodImpl.exit().exit() = null;

	//== Predecessors ==
	
	coll SimpleSet<CFGNode> CFGNode.pred() with add root ClassDecl;
	// Stmt contributes this to CFGNode.pred() for each succ();

	// NTAs are not, in general, included in the collection attribute traversal; we have to fudge around this
  protected void MethodImpl.collect_contributors_CFGNode_pred(ClassDecl _root, java.util.Map<ASTNode, java.util.Set<ASTNode>> _map) {
  	entry().collect_contributors_CFGNode_pred(_root, _map);
  	exit().collect_contributors_CFGNode_pred(_root, _map);
  	super.collect_contributors_CFGNode_pred(_root, _map);
  }

	// Do this manually because of a bug in JastAdd
	protected void Stmt.collect_contributors_CFGNode_pred(ClassDecl _root, java.util.Map<ASTNode, java.util.Set<ASTNode>> _map) {
    for (CFGNode target : (Iterable<? extends CFGNode>) (succ())) {
      ASTNode _targetRoot = (ASTNode) target;
      ASTNode _targetParent = (ASTNode) target;
      while (_targetParent != null) {
        _targetParent = _targetParent.getParent();
        if (_targetParent instanceof ClassDecl) {
          _targetRoot = _targetParent;
        }
      }
      ASTNode _sourceRoot = _root;
      ASTNode _sourceParent = _root;
      while (_sourceParent != null) {
        _sourceParent = _sourceParent.getParent();
        if (_sourceParent instanceof ClassDecl) {
          _sourceRoot = _sourceParent;
        }
      }
      if (_targetRoot != _sourceRoot) {
        throw new RuntimeException("Contribution source and target do not share a common collection "
            + "root node for collection attribute CFGNode.pred().");
      }
      java.util.Set<ASTNode> contributors = _map.get(target);
      if (contributors == null) {
        contributors = new java.util.LinkedHashSet<ASTNode>();
        _map.put((ASTNode) target, contributors);
      }
      contributors.add(this);
    }
    super.collect_contributors_CFGNode_pred(_root, _map);
  }

	protected void Stmt.contributeTo_CFGNode_pred(SimpleSet<CFGNode> collection) {
    super.contributeTo_CFGNode_pred(collection);
    collection.add(this);
  }

	// Do this manually because of a bug in JastAdd
	protected void CaseBranchStmt.collect_contributors_CFGNode_pred(ClassDecl _root, java.util.Map<ASTNode, java.util.Set<ASTNode>> _map) {
    for (CFGNode target : (Iterable<? extends CFGNode>) (succ())) {
      ASTNode _targetRoot = (ASTNode) target;
      ASTNode _targetParent = (ASTNode) target;
      while (_targetParent != null) {
        _targetParent = _targetParent.getParent();
        if (_targetParent instanceof ClassDecl) {
          _targetRoot = _targetParent;
        }
      }
      ASTNode _sourceRoot = _root;
      ASTNode _sourceParent = _root;
      while (_sourceParent != null) {
        _sourceParent = _sourceParent.getParent();
        if (_sourceParent instanceof ClassDecl) {
          _sourceRoot = _sourceParent;
        }
      }
      if (_targetRoot != _sourceRoot) {
        throw new RuntimeException("Contribution source and target do not share a common collection "
            + "root node for collection attribute CFGNode.pred().");
      }
      java.util.Set<ASTNode> contributors = _map.get(target);
      if (contributors == null) {
        contributors = new java.util.LinkedHashSet<ASTNode>();
        _map.put((ASTNode) target, contributors);
      }
      contributors.add(this);
    }
    super.collect_contributors_CFGNode_pred(_root, _map);
  }

	protected void CaseBranchStmt.contributeTo_CFGNode_pred(SimpleSet<CFGNode> collection) {
    super.contributeTo_CFGNode_pred(collection);
    collection.add(this);
  }

	//== Successors ==

	/**
	 * All possible Statements that could follow this one
	 */
	syn SimpleSet<CFGNode> CFGNode.succ() = following();
	
	/**
	 * The next statement in the AST
	 */
	inh SimpleSet<CFGNode> CFGNode.following();

	eq AssertStmt.succ() = following().union(throwTarget());

	eq AssignStmt.succ() = getValue().canThrow() ? following().union(throwTarget()) : following();

	eq AwaitStmt.succ() = getGuard().canThrow() ? following().union(throwTarget()) : following();

	eq Block.succ() = getNumStmt() != 0
		? SimpleSet.<CFGNode>empty().union(getStmt(0)) 
		: following();
	eq Block.getStmt(int i).following() = i != getNumStmt() - 1
		? SimpleSet.<CFGNode>empty().union(getStmt(i+1))
		: following();

	
	eq CaseStmt.succ() {
		SimpleSet<CFGNode> normalSucc = hasBranch()
			? new SimpleSet<CFGNode>(getBranch(0))
			: following();
		
		if (getExpr().canThrow()) {
			return normalSucc.union(throwTarget());
		}
		return normalSucc;
	}
	eq CaseStmt.getBranch(int i).following() = i + 1 < getNumBranch()
		? new SimpleSet<CFGNode>(getBranch(i).getRight()).union(getBranch(i + 1))
		// We don't need to add the throwTarget, because the compiler generates a pattern for exceptions where needed
		: new SimpleSet<CFGNode>(getBranch(i).getRight()).union(following());
	// Parent CaseStmt or TryCatchFinallyStmt
	inh Stmt CaseBranchStmt.parentStmt();
	eq CaseBranchStmt.getRight().following() = parentStmt().following();

	eq DieStmt.succ() = new SimpleSet<>(exit());

	eq DurationStmt.succ() = getMin().canThrow() || getMax().canThrow() ? following().union(throwTarget()) : following();

	eq ExpressionStmt.succ() = getExp().canThrow() ? following().union(throwTarget()) : following();

	// TODO: ForeachStmt

	eq IfStmt.succ() {
		SimpleSet<CFGNode> normalSucc = hasElse()
			? SimpleSet.<CFGNode>empty().union(getThen()).union(getElse())
			: following().union(getThen());

		if (getCondition().canThrow()) {
			return normalSucc.union(throwTarget());
		}
		return normalSucc;
	}

	eq MoveCogToStmt.succ() = getTarget().canThrow() ? following().union(throwTarget()) : following();

	// ReturnStmt does not need extra handling. It has to be the last stmt

	eq ThrowStmt.succ() = new SimpleSet<CFGNode>(throwTarget());

	eq TryCatchFinallyStmt.getBody().following() = hasFinally()
		? new SimpleSet<CFGNode>(getFinally())
		: following();
	eq TryCatchFinallyStmt.getFinally().following() = following();
	eq TryCatchFinallyStmt.getBody().throwTarget() = getCatch(0);
	eq TryCatchFinallyStmt.getCatch(int i).following() = new SimpleSet<CFGNode>(getCatch(i).getRight())
		.union(i + 1 < getNumCatch() 
			// Next catch branch
			? new SimpleSet<CFGNode>(getCatch(i + 1)) 
			// Either finally, the next stmt, or throw again
			: getBody().following().union(throwTarget()));

	eq VarDeclStmt.succ() = getVarDecl().hasInitExp() && getVarDecl().getInitExp().canThrow() 
		? following().union(throwTarget()) 
		: following();

	eq WhileStmt.succ() = following().union(getBody()).union(getCondition().canThrow() ? new SimpleSet<>(throwTarget()) : new SimpleSet<>());
	eq WhileStmt.getBody().following() = SimpleSet.<CFGNode>empty().union(this);

	inh Stmt Exp.parentStmt();

	eq AssertStmt.getCondition().parentStmt() = this;

	eq AssignStmt.getVar().parentStmt() = this;
	eq AssignStmt.getValue().parentStmt() = this;

	eq AwaitStmt.getChild(int i).parentStmt() = this;

	eq CaseStmt.getExpr().parentStmt() = this;
	eq CaseStmt.getBranch(int i).parentStmt() = this;

	eq DieStmt.getReason().parentStmt() = this;

	eq DurationStmt.getMin().parentStmt() = this;
	eq DurationStmt.getMax().parentStmt() = this;

	eq ExpressionStmt.getExp().parentStmt() = this;

	eq ForeachStmt.getListExp().parentStmt() = this;

	eq IfStmt.getCondition().parentStmt() = this;

	eq MoveCogToStmt.getTarget().parentStmt() = this;

	eq ReturnStmt.getRetExp().parentStmt() = this;

	eq ThrowStmt.getReason().parentStmt() = this;

	inh Stmt VarDecl.parentStmt();
	eq VarDeclStmt.getVarDecl().parentStmt() = this;

	eq WhileStmt.getCondition().parentStmt() = this;

	//== Exceptions ==

	// The closest surrounding catch or the exit node
	inh CFGNode CFGNode.throwTarget();
	eq MethodImpl.getChild(int i).throwTarget() = exit();

	// Some exps can throw (e.g. division, incomplete patterns, etc.)
	syn boolean Exp.canThrow() = false;

	eq AsExp.canThrow() = getExp().canThrow();

	eq Binary.canThrow() = getLeft().canThrow() || getRight().canThrow();

	eq DivMultExp.canThrow() {
		PureExp r = getRight();
		// TODO: Only throw for /0\.0+/ float lits
		if (r instanceof IntLiteral) {
			IntLiteral l = (IntLiteral) r;
			return l.getContent().equals("0");
		}
		return true;
	}

	eq CaseExp.canThrow() {
		boolean underscore = false;

		for (CaseBranch cb : getBranchs()) {
			if (cb.getLeft() instanceof UnderscorePattern) {
				underscore = true;
			}
		}

		if (!underscore) {
			return true;
		}

		for (CaseBranch cb : getBranchs()) {
			if (cb.getRight().canThrow()) {
				return true;
			}
		}

		return false;
	}

	eq DataConstructorExp.canThrow() {
		for (PureExp p : getParams()) {
			if (p.canThrow()) {
				return true;
			}
		}
		return false;
	}


	eq FnApp.canThrow() {
		for (PureExp p : getParams()) {
			if (p.canThrow()) {
				return true;
			}
		}

		if (!(getDecl() instanceof FunctionDecl)) {
			return true;
		}

		FunctionDef def = ((FunctionDecl) getDecl()).getFunctionDef();

		if (def instanceof BuiltinFunctionDef) {
			// TODO: We assume it can't throw, that should be checked;
			return false;
		}

		if (def instanceof ExpFunctionDef) {
			return ((ExpFunctionDef) def).getRhs().canThrow();
		}

		return true;
	}

	eq IfExp.canThrow() = getCondExp().canThrow() || getThenExp().canThrow() || getElseExp().canThrow();

	eq ImplementsExp.canThrow() = getExp().canThrow();

	eq LetExp.canThrow() = getVal().canThrow() || getExp().canThrow();

	eq ListLiteral.canThrow() {
		for (PureExp p : getPureExps()) {
			if (p.canThrow()) {
				return true;
			}
		}

		return false;
	}

	eq ParFnApp.canThrow() {
		for (PureExp p : getParams()) {
			if (p.canThrow()) {
				return true;
			}
		}

		for (ParFnAppParam p : getFuncParams()) {
			if (p instanceof AnonymousFunctionDecl) {
				AnonymousFunctionDecl a = (AnonymousFunctionDecl) p;
				if (a.getPureExp().canThrow()) {
					return true;
				}
			}
		}

		return false;
	}

	eq Unary.canThrow() = getOperand().canThrow();

	eq Call.canThrow() = true;

	eq GetExp.canThrow() = true;

	eq NewExp.canThrow() {
		for (PureExp p : getParams()) {
			if (p.canThrow()) {
				return true;
			}
		}

		return false;
	}

	eq OriginalCall.canThrow() = true;

	syn boolean Guard.canThrow() = true;

	eq AndGuard.canThrow() = getLeft().canThrow() || getRight().canThrow();

	eq ClaimGuard.canThrow() = false;

	eq DurationGuard.canThrow() = getMin().canThrow() || getMax().canThrow();

	eq ExpGuard.canThrow() = getPureExp().canThrow();
}
