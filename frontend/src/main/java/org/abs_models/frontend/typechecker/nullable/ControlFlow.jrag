import org.abs_models.frontend.typechecker.nullable.SimpleSet;

aspect ControlFlow {

	//== Entry / Exit ==
	
	syn nta Stmt MethodImpl.entry() = new SkipStmt();
	syn nta Stmt MethodImpl.exit() = new SkipStmt();

	eq MethodImpl.entry().following() = new SimpleSet<Stmt>(getBlock());
	eq MethodImpl.getBlock().following() = new SimpleSet<Stmt>(exit());
	eq MethodImpl.exit().following() = new SimpleSet<Stmt>();
	
	inh Stmt Stmt.exit();
	eq MethodImpl.getBlock().exit() = exit();
	eq MethodImpl.entry().exit() = exit();
	eq MethodImpl.exit().exit() = null;

	//== Predecessors ==
	
	coll SimpleSet<Stmt> Stmt.pred() with add root MethodImpl;
	Stmt contributes this to Stmt.pred() for each succ();

	// NTAs are not, in general, included in the collection attribute traversal; we have to fudge around this
  protected void MethodImpl.collect_contributors_Stmt_pred(MethodImpl _root, java.util.Map<ASTNode, java.util.Set<ASTNode>> _map) {
  	entry().collect_contributors_Stmt_pred(_root, _map);
  	exit().collect_contributors_Stmt_pred(_root, _map);
  	super.collect_contributors_Stmt_pred(_root, _map);
  }

	//== Successors ==
	
	// TODO: Handle exceptions

	/**
	 * All possible Statements that could follow this one
	 */
	syn SimpleSet<Stmt> Stmt.succ() = following();
	/**
	 * The next statement in the AST
	 */
	inh SimpleSet<Stmt> Stmt.following();

	// TODO: AssertStmt

	eq Block.succ() = getNumStmt() != 0
		? SimpleSet.<Stmt>empty().union(getStmt(0)) 
		: following();
	eq Block.getStmt(int i).following() = i != getNumStmt() - 1
		? SimpleSet.<Stmt>empty().union(getStmt(i+1))
		: following();

	
	// TODO: A more granular control flow cannot be modelled right now, because we would need a common interface for Stmt/Exp/CaseBranchStmt(/Pattern)
	// That currently results in an error in the generated code, but maybe I'm doing it wrong?
	inh CaseStmt CaseBranchStmt.parentCase();
	CaseStmt.getBranch(i).parentCase() = this;
	CaseBranchStmt.following() = parentCase().following();

	// TODO: What is a DieStmt?

	// TODO: ForeachStmt

	eq IfStmt.succ() = hasElse()
		? SimpleSet.<Stmt>empty().union(getThen()).union(getElse())
		: following().union(getThen());

	// TODO: What is a MoveCogToStmt?

	// ReturnStmt does not need extra handling. It has to be the last stmt

	// TODO: ThrowStmt

	// TODO: TryCatchFinally
	eq TryCatchFinally.getBody().following = hasFinally()
		? new SimpleSet<Stmt>(getFinally())
		: following();
	eq TryCatchFinally.getFinally().following() = following();

	eq WhileStmt.succ() = following().union(getBody());
	eq WhileStmt.getBody().following() = SimpleSet.<Stmt>empty().union(this);

	inh Stmt Exp.parentStmt();

	eq AssertStmt.getCondition().parentStmt() = this;

	eq AssignStmt.getVar().parentStmt() = this;
	eq AssignStmt.getValue().parentStmt() = this;

	// TODO: await

	eq CaseStmt.getExpr().parentStmt() = this;
	// TODO: Handle patterns

	eq DieStmt.getReason().parentStmt() = this;

	eq DurationStmt.getMin().parentStmt() = this;
	eq DurationStmt.getMax().parentStmt() = this;

	eq ExpressionStmt.getExp().parentStmt() = this;

	eq ForeachStmt.getListExp().parentStmt() = this;

	eq IfStmt.getCondition().parentStmt() = this;

	eq MoveCogToStmt.getTarget().parentStmt() = this;

	eq ReturnStmt.getRetExp().parentStmt() = this;

	eq ThrowStmt.getReason().parentStmt() = this;

	inh Stmt VarDecl.parentStmt();
	eq VarDeclStmt.getVarDecl().parentStmt() = this;

	eq WhileStmt.getCondition().parentStmt() = this;
}
