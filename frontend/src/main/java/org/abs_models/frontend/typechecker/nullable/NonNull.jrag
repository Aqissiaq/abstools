import org.abs_models.frontend.typechecker.nullable.NullableInfo;
import org.abs_models.frontend.typechecker.nullable.SimpleSet;

aspect NonNull {
  // == NonNull in ==
  /* coll is broken right now
   * coll SimpleSet<VarOrFieldDecl> Stmt.nonNull_in() circular [SimpleSet.<VarOrFieldDecl>empty()] with add;
   * Stmt contributes nonNull_out() to Stmt.nonNull_in() for each succ();
   */
  syn SimpleSet<VarOrFieldDecl> Stmt.nonNull_in() circular [SimpleSet.<VarOrFieldDecl>empty()] {
    SimpleSet<VarOrFieldDecl> s = new SimpleSet();
    for (Stmt stmt : pred()) {
      s = s.union(stmt.nonNull_out());
    }
    return s;
  }
  

  // == NonNull out ==
  // For most stmts out = in
  syn SimpleSet<VarOrFieldDecl> Stmt.nonNull_out() = nonNull_in();

  // TODO: AssertStmt

  eq AssignStmt.nonNull_out() {
    SimpleSet<VarOrFieldDecl> in = nonNull_in();

    Exp e = getValue();
    VarOrFieldUse var = getVar();

    VarOrFieldDecl d = var.getDecl();

    if (e.nonNull(in)) {
      return in.union(d);
    } else {
      return in.comp(d);
    }
  }

  eq ExpressionStmt.nonNull_out() = nonNull_in().union(getExp().nonNull_added());

  eq VarDeclStmt.nonNull_out() {
    VarDecl d = getVarDecl();

    SimpleSet<VarOrFieldDecl> in = nonNull_in();

    if (!(d.getType().isReferenceType())) {
      return in;
    }

    if (!d.hasInitExp()) {
      // Because we have no init, the value is null
      return in;
    }

    Exp init = d.getInitExp();
    if (init.nonNull(in)) {
      return in.union(d).union(init.nonNull_added());
    } else {
      // We don't have to remove d, as it has not existed yet
      return in.union(init.nonNull_added());
    }
  }

  // == Exp ==

  // Set of decls that are added to nonNull by this expr
  syn SimpleSet<VarOrFieldDecl> Exp.nonNull_added();

  eq Exp.nonNull_added() = SimpleSet.<VarOrFieldDecl>empty();

  eq Call.nonNull_added() {
    PureExp callee = getCallee();

    // TODO: Add more cases? Actually, only Paren would make sense, right?
    if (callee instanceof VarOrFieldUse) {
      VarOrFieldUse c = (VarOrFieldUse) callee;
      return new SimpleSet<VarOrFieldDecl>(c.getDecl());
    }

    return SimpleSet.<VarOrFieldDecl>empty();
  }

  syn boolean Exp.nonNull(SimpleSet<VarOrFieldDecl> set);

  // TODO: refine using annotations
  eq Call.nonNull(SimpleSet<VarOrFieldDecl> set) = false;

  // TODO: refine using annotations
  eq GetExp.nonNull(SimpleSet<VarOrFieldDecl> set) = false;

  eq NewExp.nonNull(SimpleSet<VarOrFieldDecl> set) = true;

  // TODO: refine using annotations (Is that even possible?)
  eq OriginalCall.nonNull(SimpleSet<VarOrFieldDecl> set) = false;

  eq Access.nonNull(SimpleSet<VarOrFieldDecl> set) = false;
  eq VarOrFieldUse.nonNull(SimpleSet<VarOrFieldDecl> set) = set.contains(getDecl());

  eq AsExp.nonNull(SimpleSet<VarOrFieldDecl> set) = false;

  // Binary expr can't be a reference
  eq Binary.nonNull(SimpleSet<VarOrFieldDecl> set) = true;

  // TODO
  eq CaseExp.nonNull(SimpleSet<VarOrFieldDecl> set) = false;

  // Can't be a reference
  eq DataConstructorExp.nonNull(SimpleSet<VarOrFieldDecl> set) = true;

  // Can't be a reference
  eq FnApp.nonNull(SimpleSet<VarOrFieldDecl> set) = true;

  eq IfExp.nonNull(SimpleSet<VarOrFieldDecl> set) = getThenExp().nonNull(set) && getElseExp().nonNull(set);

  eq ImplementsExp.nonNull(SimpleSet<VarOrFieldDecl> set) = true;

  // TODO
  eq LetExp.nonNull(SimpleSet<VarOrFieldDecl> set) = false;

  eq LiteralExp.nonNull(SimpleSet<VarOrFieldDecl> set) = true;

  eq NullExp.nonNull(SimpleSet<VarOrFieldDecl> set) = false;

  eq ParFnApp.nonNull(SimpleSet<VarOrFieldDecl> set) = true;

  eq ThisExp.nonNull(SimpleSet<VarOrFieldDecl> set) = true;

  eq Unary.nonNull(SimpleSet<VarOrFieldDecl> set) = true;
}