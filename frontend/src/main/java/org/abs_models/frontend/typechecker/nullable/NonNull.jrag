import org.abs_models.frontend.typechecker.nullable.NullableInfo;
import org.abs_models.frontend.typechecker.nullable.SimpleSet;

aspect NonNull {
  // == NonNull in ==
  syn SimpleSet<VarOrFieldDecl> CFGNode.nonNull_in() circular [SimpleSet.<VarOrFieldDecl>empty()] {
    // Special case: if we have exactly one pred, we might extract extra info
    if (pred().size() == 1) {
      CFGNode p = null;
      for (CFGNode n : pred()) {
        p = n;
      }

      SimpleSet<VarOrFieldDecl> in = p.nonNull_out();

      PureExp cond;
      CFGNode self = this;
      boolean assumeTrue = false;

      if (p instanceof IfStmt) {
        IfStmt i = (IfStmt) p;
        cond = i.getCondition();

        if (self == i.getThen()) {
          assumeTrue = true;
        }
      } else if (p instanceof AssertStmt) {
        AssertStmt a = (AssertStmt) p;
        cond = a.getCondition();

        if (self != a.throwTarget()) {
          assumeTrue = true;
        }
      } else {
        return in;
      }

      // TODO: Expand and put in own method/attribute
      if (cond instanceof EqualityExpr) {
        if (cond instanceof NotEqExp) {
          assumeTrue = !assumeTrue;
        }
        EqualityExpr ee = (EqualityExpr) cond;
        PureExp left = ee.getLeft();
        PureExp right = ee.getRight();
        if (left instanceof NullExp) {
          PureExp e = left;
          left = right;
          right = e;
        }
        if (right instanceof NullExp && left instanceof VarOrFieldUse) {
          VarOrFieldDecl d = ((VarOrFieldUse) left).getDecl();
          if (assumeTrue) {
            // If cond is true, then left must be null
            // We can safely do this without intersection, because we know we are in an IfStmt
            return in.comp(d);
          } else {
            return in.union(d);
          }
        }
      }
    }

    SimpleSet<VarOrFieldDecl> s = new SimpleSet();
    for (CFGNode n : pred()) {
      s = s.union(n.nonNull_out());
    }

    for (CFGNode n : pred()) {
      s = s.intersection(n.nonNull_out());
    }
    return s;
  }
  

  // == NonNull out ==
  // For most stmts out = in
  syn SimpleSet<VarOrFieldDecl> CFGNode.nonNull_out() = nonNull_in();

  // Handle params
  eq CFGEntry.nonNull_out() {
    SimpleSet<VarOrFieldDecl> s = new SimpleSet<>();

    if (getParent() instanceof MethodImpl) {
      MethodImpl met = (MethodImpl) getParent();
      for (ParamDecl p : met.getMethodSig().getParams()) {
        if (p.nonNull()) {
          s.add(p);
        }
      }
    }

    return s;
  }

  eq AssertStmt.nonNull_out() = nonNull_in();

  eq AssignStmt.nonNull_out() {
    SimpleSet<VarOrFieldDecl> in = nonNull_in();

    Exp e = getValue();
    VarOrFieldUse var = getVar();

    VarOrFieldDecl d = var.getDecl();

    if (e.nonNull()) {
      return in.union(d);
    } else {
      return in.comp(d);
    }
  }

  eq ExpressionStmt.nonNull_out() = getExp().nonNull_out();

  eq VarDeclStmt.nonNull_out() {
    VarDecl d = getVarDecl();

    SimpleSet<VarOrFieldDecl> in = nonNull_in();

    if (!d.hasInitExp()) {
      // Because we have no init, the value is null
      return in;
    }

    Exp init = d.getInitExp();
    if (init.nonNull()) {
      return init.nonNull_out().union(d);
    } else {
      // We don't have to remove d, as it has not existed yet
      return init.nonNull_out();
    }
  }

  // == Exp ==

  syn SimpleSet<VarOrFieldDecl> Exp.nonNull_in() = parentStmt().nonNull_in();

  syn SimpleSet<VarOrFieldDecl> Exp.nonNull_out();

  eq Exp.nonNull_out() = nonNull_in();

  eq Call.nonNull_out() {
    SimpleSet<VarOrFieldDecl> in = nonNull_in();
    PureExp callee = getCallee();

    if (callee instanceof VarOrFieldUse) {
      VarOrFieldUse c = (VarOrFieldUse) callee;
      return in.union(c.getDecl());
    }

    return in;
  }
  
  syn boolean Exp.nonNull();

  // TODO: refine using annotations
  eq Call.nonNull() = getMethodSig().nonNull();

  eq GetExp.nonNull() = getPureExp().nonNull();

  eq NewExp.nonNull() = true;

  // TODO: refine using annotations (Is that even possible?)
  eq OriginalCall.nonNull() = false;

  eq Access.nonNull() = false;
  eq VarOrFieldUse.nonNull() = nonNull_in().contains(getDecl());

  eq AsExp.nonNull() = false;

  // Binary expr can't be a reference
  eq Binary.nonNull() = true;

  eq CaseExp.nonNull() {
    for (CaseBranch b : getBranchs()) {
      if (!b.getRight().nonNull()) {
        return false;
      }
    }
    return true;
  }

  // Can't be a reference
  eq DataConstructorExp.nonNull() = true;

  // Can't be a reference
  eq FnApp.nonNull() = true;

  eq IfExp.nonNull() = getThenExp().nonNull() && getElseExp().nonNull();

  eq ImplementsExp.nonNull() = true;

  // TODO
  eq LetExp.nonNull() = false;

  eq LiteralExp.nonNull() = true;

  eq NullExp.nonNull() = false;

  eq ParFnApp.nonNull() = true;

  eq ThisExp.nonNull() = true;

  eq Unary.nonNull() = true;

  // == Parameters ==
  syn boolean ParamDecl.nonNull() {
    for (Annotation a : getAnnotations()) {
      PureExp e = a.getValue();
      if (e instanceof DataConstructorExp) {
        DataConstructorExp d = (DataConstructorExp) e;
        String name = d.getConstructor();
        if (name.equals("NonNull") && !d.hasParam()) {
          return true;
        }
      }
    }

    return false;
  }

  // == MethodSig ==
  syn boolean MethodSig.nonNull() {
    for (Annotation a : getAnnotations()) {
      PureExp e = a.getValue();
      if (e instanceof DataConstructorExp) {
        DataConstructorExp d = (DataConstructorExp) e;
        String name = d.getConstructor();
        if (name.equals("NonNull") && !d.hasParam()) {
          return true;
        }
      }
    }

    return false;
  }
}