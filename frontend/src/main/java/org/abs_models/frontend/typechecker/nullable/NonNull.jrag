import org.abs_models.frontend.typechecker.nullable.NullableType;
import org.abs_models.frontend.analyser.BitVec;
import org.abs_models.frontend.typechecker.nullable.NullCheckerExtension;

/**
 * Computes whether references (or futures) are NonNull using data flow analysis
 */
aspect NonNull {

  /**
   *  Gathers all declarations relevant to the nullable type analysis
   *  These differ depending on the node this entry belongs to:
   *    - MethodImpl: All parameters and all declarations in the body
   *    - If the node is in a ClassDecl: All parameters and fields
   *    - MainBlock: All declarations in the block
   */
  syn lazy BitVec<VarOrFieldDecl> CFGEntry.getAllVarOrFieldDecls() {
    BitVec<VarOrFieldDecl> decls = new BitVec<>();
    ASTNode parent = getParent();

    if (parent instanceof MethodImpl) {
      MethodImpl met = (MethodImpl) parent;
      java.util.List<VarOrFieldDecl> d = met.findChildren(VarOrFieldDecl.class);
      decls.addAll(d);
      for (ParamDecl p : met.getMethodSig().getParams()) {
        decls.add(p);
      }
    }

    ASTNode n = parent;
    ClassDecl c = null;
    while (n != null && !(n instanceof ModuleDecl)) {
      if (n instanceof ClassDecl) {
        c = (ClassDecl) n;
        break;
      }
      n = n.getParent();
    }

    if (c != null) {
      for (ParamDecl p : c.getParams()) {
        decls.add(p);
      }
      for (FieldDecl f : c.getFields()) {
        decls.add(f);
      }
    }

    if (parent instanceof MainBlock) {
      MainBlock mb = (MainBlock) parent;
      java.util.List<VarOrFieldDecl> d = mb.findChildren(VarOrFieldDecl.class);
      decls.addAll(d);
    }

    return decls;
  }

  // == NonNull in ==
  /**
   * Used to compute nonNull, do not use directly
   */
  syn BitVec<VarOrFieldDecl> CFGNode.nonNull_in() circular [entry().getAllVarOrFieldDecls()] {
    CFGNode self = this;

    boolean isCatch = self instanceof CaseBranchStmt 
      && ((CaseBranchStmt) self).parentStmt() instanceof TryCatchFinallyStmt;

    // Special case: if we have exactly one pred, we might extract extra info
    if (pred().size() == 1) {
      CFGNode p = null;
      for (CFGNode n : pred()) {
        p = n;
      }
      if (p instanceof IfStmt) {
        IfStmt i = (IfStmt) p;
        if (self == i.getThen()) {
          return p.nonNull_out_then();
        } else {
          return p.nonNull_out_else();
        }
      } else if(p instanceof WhileStmt) {
        WhileStmt w = (WhileStmt) p;
        if (self == w.getBody()) {
          return p.nonNull_out_then();
        } else {
          return p.nonNull_out_else();
        }
      } else if(p instanceof AssertStmt) {
        AssertStmt a = (AssertStmt) p;
        if (self instanceof CaseBranchStmt) {
          return p.nonNull_out_else();
        } else {
          return p.nonNull_out_then();
        }
      } else {
        return isCatch ? p.nonNull_in() : p.nonNull_out();
      }
    }

    BitVec<VarOrFieldDecl> s = entry().getAllVarOrFieldDecls();
    
    for (CFGNode n : pred()) {
      if (!isCatch && n instanceof IfStmt && !((IfStmt) n).hasElse()) {
        // We are in a stmt that follows an if without else and we have > 1 preds
        // This means that we can use the else information
        s = s.intersect(n.nonNull_out_else());
        continue;
      }
      s = s.intersect(isCatch ? n.nonNull_in() : n.nonNull_out());
    }
    return s;
  }
  

  // == NonNull out ==
  /**
   * Used to compute nonNull, do not use directly
   * For most stmts out = in
   */
  syn BitVec<VarOrFieldDecl> CFGNode.nonNull_out() circular [entry().getAllVarOrFieldDecls()] = nonNull_in();
  /**
   * Used to compute nonNull, do not use directly
   * What gets propagated to the `then` successors of a conditional node (if, while)
   */
  syn BitVec<VarOrFieldDecl> CFGNode.nonNull_out_then() circular [entry().getAllVarOrFieldDecls()] = new BitVec<>();
  /**
   * Used to compute nonNull, do not use directly
   * What gets propagated to the `else` successors of a conditional node (if, while)
   */
  syn BitVec<VarOrFieldDecl> CFGNode.nonNull_out_else() circular [entry().getAllVarOrFieldDecls()] = new BitVec<>();

  // Add all declarations to the entry that we know are NonNull (i.e., relevant params and fields)
  eq CFGEntry.nonNull_out() {
    BitVec<VarOrFieldDecl> s = new BitVec<>();

    ASTNode parent = getParent();

    ASTNode n = parent;
    ClassDecl c = null;
    while (n != null && !(n instanceof ModuleDecl)) {
      if (n instanceof ClassDecl) {
        c = (ClassDecl) n;
        break;
      }
      n = n.getParent();
    }
    
    if (c != null) {
      for (ParamDecl p : c.getParams()) {
        if (p.nonNull()) {
          s.add(p);
        }
      }
    }

    if (parent instanceof MethodImpl) {
      MethodImpl met = (MethodImpl) getParent();
      for (ParamDecl p : met.getMethodSig().getParams()) {
        if (p.nonNull()) {
          s.add(p);
        }
      }

      // Fields can only surely be initialized in methods
      for (FieldDecl f : c.getFields()) {
        if (f.nonNull()) {
          s.add(f);
        }
      }
    }

    return s;
  }

  // AssertStmt can propagate conditional information
  eq AssertStmt.nonNull_out_then() {
    VarOrFieldDecl d = getCondition().testsNotNull();
    if (d != null) {
      return nonNull_in().union(d);
    }
    return nonNull_in();
  }
  eq AssertStmt.nonNull_out_else() {
    VarOrFieldDecl d = getCondition().testsNull();
    if (d != null) {
      return nonNull_in().union(d);
    }
    return nonNull_in();
  }

  // Add or remove the corresponding decl depending on the assigned value
  eq AssignStmt.nonNull_out() {
    Exp e = getValue();
    BitVec<VarOrFieldDecl> out = e.nonNull_out();

    VarOrFieldUse var = getVar();

    VarOrFieldDecl d = var.getDecl();

    if (e.nonNull()) {
      return out.union(d);
    } else {
      return out.compl(d);
    }
  }

  // Get information from the expression an propagate it
  eq ExpressionStmt.nonNull_out() = getExp().nonNull_out();

  // Give conditional information if applicable
  eq IfStmt.nonNull_out_then() {
    VarOrFieldDecl d = getCondition().testsNotNull();
    if (d != null) {
      return nonNull_in().union(d);
    }
    return nonNull_in();
  }
  eq IfStmt.nonNull_out_else() {
    VarOrFieldDecl d = getCondition().testsNull();
    if (d != null) {
      return nonNull_in().union(d);
    }
    return nonNull_in();
  }

  // Add decl if the value is NonNull
  eq VarDeclStmt.nonNull_out() {
    VarDecl d = getVarDecl();

    BitVec<VarOrFieldDecl> out = nonNull_in();

    if (!d.hasInitExp()) {
      // Because we have no init, the value is null
      return out.compl(d);
    }

    Exp init = d.getInitExp();
    if (init.nonNull()) {
      return init.nonNull_out().union(d);
    } else {
      return init.nonNull_out().compl(d);
    }
  }

  // Give conditional information if applicable
  eq WhileStmt.nonNull_out_then() {
    VarOrFieldDecl d = getCondition().testsNotNull();
    if (d != null) {
      return nonNull_in().union(d);
    }
    return nonNull_in();
  }
  eq WhileStmt.nonNull_out_else() {
    VarOrFieldDecl d = getCondition().testsNull();
    if (d != null) {
      return nonNull_in().union(d);
    }
    return nonNull_in();
  }

  // == Exp ==

  // Expressions can alter nullability, but most don't

  /**
   * Used to compute nonNull, do not use directly
   *
   * We get the current nullability from the parent stmt.
   * We could just make expressions nodes, but that would complicate the analysis
   * We also could just pass the current nonNull-set to the `nonNull` attribute, but we that would make the API more difficult to use
   */
  syn BitVec<VarOrFieldDecl> Exp.nonNull_in() = parentStmt().nonNull_in();

  /**
   * Used to compute nonNull, do not use directly
   */
  syn BitVec<VarOrFieldDecl> Exp.nonNull_out();

  // Most expressions don't change the set
  eq Exp.nonNull_out() = nonNull_in();

  // Calls make the callee NonNull
  eq Call.nonNull_out() {
    BitVec<VarOrFieldDecl> in = nonNull_in();
    PureExp callee = getCallee();

    if (callee instanceof VarOrFieldUse) {
      VarOrFieldUse c = (VarOrFieldUse) callee;
      return in.union(c.getDecl());
    }

    return in;
  }
  
  /**
    * True iff the expression is ensured to be NonNull
    */
  syn boolean Exp.nonNull() circular [true];

  eq Call.nonNull() = getMethodSig().nonNull();

  eq GetExp.nonNull() = getPureExp().nonNull();

  eq NewExp.nonNull() = true;

  eq OriginalCall.nonNull() = false;

  eq Access.nonNull() = false;
  eq VarOrFieldUse.nonNull() = nonNull_in().contains(getDecl());

  eq AsExp.nonNull() = false;

  // Binary expr can't be a reference
  eq Binary.nonNull() = false;

  eq CaseExp.nonNull() {
    for (CaseBranch b : getBranchs()) {
      if (!b.getRight().nonNull()) {
        return false;
      }
    }
    return true;
  }

  // Can't be a reference
  eq DataConstructorExp.nonNull() = false;

  eq FnApp.nonNull() {
    // We cannot get the NullableType from the decl, because of generics
    Type t = getType();
    NullableType nt = NullCheckerExtension.getNullableType(t);
    if (nt == null) return false;
    return nt.isNonNull();
  }

  eq IfExp.virtualThenStmt().nonNull_in() {
    VarOrFieldDecl d = getCondExp().testsNotNull();
    if (d != null) {
      return nonNull_in().union(d);
    }
    return nonNull_in();
  }

  eq IfExp.virtualElseStmt().nonNull_in() {
    VarOrFieldDecl d = getCondExp().testsNull();
    if (d != null) {
      return nonNull_in().union(d);
    }
    return nonNull_in();
  }

  eq IfExp.nonNull() = getThenExp().nonNull() && getElseExp().nonNull();

  eq ImplementsExp.nonNull() = false;

  inh BitVec<VarOrFieldDecl> VirtualStmt.nonNull_in();
  eq LetExp.virtualStmt().nonNull_in() {
    BitVec<VarOrFieldDecl> in = nonNull_in();
    ParamDecl d = getVar();

    if (getVal().nonNull()) {
      return in.union(d);
    }

    return in;
  }
  eq LetExp.nonNull() = getExp().nonNull();

  eq ExpFunctionDef.virtualStmt().nonNull_in() {
    FunctionDecl d = (FunctionDecl) getParent();

    BitVec<VarOrFieldDecl> in = new BitVec<>();

    for (ParamDecl p : d.getParams()) {
      if (p.nonNull()) {
        in.add(p);
      }
    }

    return in;
  }

  eq LiteralExp.nonNull() = false;

  eq NullExp.nonNull() = false;

  eq ParFnApp.nonNull() {
    // We cannot get the NullableType from the decl, because of generics
    Type t = getType();
    NullableType nt = NullCheckerExtension.getNullableType(t);
    if (nt == null) return false;
    return nt.isNonNull();
  }

  eq ThisExp.nonNull() = true;

  eq Unary.nonNull() = false;

  /**
   * Whether this expr is `id == null` or `null == id`
   */
  syn VarOrFieldDecl PureExp.testsNull() = null;
  eq EqExp.testsNull() {
    PureExp l = getLeft();
    PureExp r = getRight();

    if (l instanceof NullExp) {
      PureExp e = l;
      l = r;
      r = e;
    }

    if (r instanceof NullExp && l instanceof VarOrFieldUse) {
      return ((VarOrFieldUse) l).getDecl();
    }
    return null;
  }

  /**
   * Whether this expr is `id != null` or `null != id`
   */
  syn VarOrFieldDecl PureExp.testsNotNull() = null;
  eq NotEqExp.testsNotNull() {
    PureExp l = getLeft();
    PureExp r = getRight();

    if (l instanceof NullExp) {
      PureExp e = l;
      l = r;
      r = e;
    }

    if (r instanceof NullExp && l instanceof VarOrFieldUse) {
      return ((VarOrFieldUse) l).getDecl();
    }
    return null;
  }

  /**
   * Whether the annotation is the NonNull annotation
   */
  syn boolean Annotation.nonNull() {
    PureExp e = getValue();
    if (e instanceof DataConstructorExp) {
      DataConstructorExp d = (DataConstructorExp) e;
      String name = d.getConstructor();
      if (name.equals("NonNull") && !d.hasParam()) {
        return true;
      }
    }
    return false;
  }

  // == Parameters ==
  /**
   * Whether the param is declared as NonNull
   */
  syn boolean ParamDecl.nonNull() {
    NullableType nt = getNullableType();
    if (nt == null) return false;
    return nt.isNonNull();
  }

  // == MethodSig ==
  /**
   * Whether the method return type is declared as NonNull
   */
  syn boolean MethodSig.nonNull() {
    NullableType nt = getNullableType();
    if (nt == null) return false;
    return nt.isNonNull();
  }

  // == Function ==
  /**
   * Whether the function is declared as NonNull
   */
  syn boolean FunctionDecl.nonNull() {
    NullableType nt = getNullableType();
    if (nt == null) return false;
    return nt.isNonNull();
  }

  // == Partial Function
  /**
   * Whether the function is declared as NonNull
   */
  syn boolean PartialFunctionDecl.nonNull() {
    NullableType nt = getNullableType();
    if (nt == null) return false;
    return nt.isNonNull();
  }

  // == VarOrFieldDecl
  /**
   * Whether the variable or field is declared as NonNull
   */
  syn boolean VarOrFieldDecl.nonNull() = false;

  eq TypedVarOrFieldDecl.nonNull() {
    NullableType nt = getNullableType();
    if (nt == null) return false;
    return nt.isNonNull();
  }
}
