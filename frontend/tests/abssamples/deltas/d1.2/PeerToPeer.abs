/****************************************************************
 * Variability in a Peer-To-Peer Node (D1.2)
 * uses full ABS
 */

module PeerToPeer;

//type synonyms
/*************************************************************************/

type Filename = String;
type Filenames = Set<Filename>;
type Server = String;
type Packet = String;
type File = List<Packet>;
type Catalog = List<Pair<Server,Filenames>>;

/*************************************************************************/

interface DB {
    File getFile(Filename fId);
    Int getLength(Filename fId);
    Unit storeFile(Filename fId, File file);
    Filenames listFiles();
}

/*************************************************************************/

class DataBase(Map<Filename,File> db) implements DB {
    File getFile(Filename fId) { return lookup(db, fId); }
    Int getLength(Filename fId){ return length(lookup(db, fId)); }
    Unit storeFile(Filename fId, File file) { db = insert(Pair(fId,file), db); }
    Filenames listFiles() { return keys(db); }
}

/*************************************************************************/

interface Client {
    List<Pair<Server,Filenames>> availFiles(List<Server> sList);
    Unit reqFile(Server sId, Filename fId);
}

interface Server {
    Filenames inquire();
    Int getLength(Filename fId);
    Packet getPack(Filename fId, Int pNbr);
}

interface Peer extends Client, Server {
    List<Server> getNeighbors();
}

/*************************************************************************/

class Node(DB db, Peer admin, Filename file) implements Peer {
    Catalog catalog;
    List<Server> myNeighbors;

    List<Server> getNeighbors() { return myNeighbors; }

    Server findServer(Filename fId, Catalog catalog) {
        if (isEmpty(catalog)) {
            return null;
        } else if (lookup(fId, snd(head(catalog)))) {
            return fst(head(catalog));
        } else {
            return findServer(fId, tail(catalog));
        }
    }

    Unit run() {
        Fut<Catalog> c;
        Fut<List<Server>> f;
        List<Server> newNeighbors;
        Server server;
        neighbors = Cons(admin, NilServer);
        f = admin!getNeighbors();           // Asynchronous call to admin
        await f?;
        newNeighbors = f.get;
        neighbors = concatenate(neighbors, newNeighbors);
        c = this!availFiles(neighbors);     // Asynchronous call
        await c?;                           // Allow other peers to call in the meantime
        catalog = c.get;                    // Build the catalog
        server = findServer(file,catalog);  // Find the server for the requested file
        reqFile(server,file) ;              // Download file
    }

    Filenames inquire() {
        Fut<Filenames> f;
        f = db!listfiles();
        await f?;
        return f.get;
    }

    Int getLength(Filename fId) {
        Fut<Int> length;
        length = db!getLength(fId);
        await length?;
        return length.get;
    }

    Packet getPack(Filename fId, Int pNbr) {
        File f;
        Fut<File> ff;
        ff = db!getFile(fId);
        await ff? ;
        f = ff.get;
        return nth(f, pNbr);
    }

    Catalog availFiles (List<Server> sList) {
        Catalog cat;
        Fut<Filenames> fNames;
        Fut<Catalog> catList;
        if (sList == NilServer) {
            cat = Nil;
        } else {
            fNames = head(sList)!inquire(); // Asynchronous call to the first server
            catList = this!availFiles(tail(sList)); // Asynchronous self-call with the tail of the list
            await fNames? & catList?; // Wait for both replies
            cat = appendright(catList, Pair(head(sList), fNames));
        }
        return cat;
    }

    Unit reqFile(Server sId, Filename fId) {
        File file;
        Packet pack;
        Int lth;
        Fut<Int> l1;
        Fut<Packet> l2;
        l1 = sId!getLength(fId);
        await l1?;
        lth = l1.get;
        while (lth > 0) {
            l2 = sId!getPack(fId, lth);
            await l2?;
            pack = l2.get;
            file = Cons(pack,file);
            lth = lth - 1;
        }
        db!storeFile(fId, file);
    }
}

/*************************************************************************/

delta DFileFilter() {
    modifies class Node {
        modifies Server findServer(Filename fId, Catalog catalog) {
            if (isValid(fId)) {
                // FIXME original call
                // original(fId, catalog);
            } else {
                return null;
            }
        }
        adds Bool isValid(Filename fId) {
            return True;
        }
    }
}

delta DParentalControl() {
    modifies class Node {
        modifies Bool isValid(Filename fId) {
            return (~isSubstring("xxx",fId));
        }
    }
}

/*************************************************************************/

productline Peer2Peer {
    features Basic, FileFilter, ParentalControl;
    delta DFileFilter when FileFilter;
    delta DParentalControl after DFileFilter when ParentalControl;
}

/*************************************************************************/

product P1 (Basic) {}
product P2 (FileFilter) {}
product P3 (ParentalControl) {}
product P4 (FileFilter, ParentalControl) {}

/*************************************************************************/


/*
{
  // Map<Filename, File>
  DataBase db0 = new cog DataBaseImpl(map[Pair("file0", list["file", "from", "db0"])]);
  DataBase db1 = new cog DataBaseImpl(map[Pair("file1", list["file", "from", "db1"])]);
  DataBase db2 = new cog DataBaseImpl(map[Pair("file2", list["file", "from", "db2"])]);
  Peer node0 = new cog Node(db0, "file2");
  Peer node1 = new cog Node(db1, "file2");
  Peer node2 = new cog Node(db2, "file1");
  Peer node3 = new cog Node(db2, "file0");
  Network admin = new cog OurTopology(node0, node1, node2, node3);
  node0!setAdmin(admin);
  node1!setAdmin(admin);
  node2!setAdmin(admin);
  node3!setAdmin(admin);
}
*/
