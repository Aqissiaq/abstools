module LeaderElection;

def Int numNodes() = 3;

interface Node {
	Unit setNextNode(Node n);
	Unit findLeader(Node currentLeader, Int leaderId);
}

class NodeImpl(Int id) implements Node {
    Node next;
    Bool electionRunning = True;
    Node leader;
    
    Unit setNextNode(Node n) {
       next = n;
       
       electionRunning = True;
       next!findLeader(this,id);
    }
    
    Unit findLeader(Node currentLeader, Int leaderId) {
       await next != null;
       if (id > leaderId) {
       	  leader = this;
       	  next!findLeader(this,id);
       } else if (id == leaderId) {
       	 electionRunning = False;
       } else {
       	 leader = currentLeader;
       	 next!findLeader(currentLeader, leaderId);
       }
    }
    
}

interface Start {
   Unit start();
}

class Start implements Start {
   Unit start() {
	List<Node> nodes = Nil;
	Int num = numNodes();

	Node prevNode;
	Node n;
	Node first;

	first = new cog NodeImpl(0);
	prevNode = first;

	Int id = 1;
	while (id < num) {
	   n = new cog NodeImpl(id);
	   n!setNextNode(prevNode);
	   prevNode = n;
	   nodes = Cons(n,nodes);
	   id = id +1;
	} 
	first!setNextNode(n);
   }
}

{
	Start m;
	m = new Start();
	m.start();
}