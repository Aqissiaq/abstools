//$Id$ 

//data type declarations 
data Void {} // builtin  
data String {} // builtin  
data Int {} // builtin
data Bool {} // builtin

data Set<A> { EmptySet; Insert(A, Set<A>); }
data List<A> { Nil; Cons(A, List<A>); }
data Pair<A, B> { Pair(A, B); }
data Map<A, B> { EmptyMap; InsertAssoc(Pair<A, B>, Map<A, B>); }


//function definitions 
//List functions 
def A head<A>(List<A> list) = 
  case list { Cons(p,l) => p ; } // the head of a non-empty list

def List<A> tail<A>(List<A> list) = 
  case list { Cons(p,l) => l ; } // the tail of a non-empty list
def Bool isEmpty<A>(List<A> list) = 
  list == Nil             // test for empty list

def Int length<A>(List<A> list) =     // the length of a list
  case list {
    Nil => 0 ;
    Cons(p, l) => 1 + length(l) ;
  } 

def A nth<A>(List<A> list, Int n) =
  case n {   
    0 => head(list) ;
    _ => nth(tail(list), n-1) ;
  }

def List<A> concatenate<A>(List<A> list1, List<A> list2) =
  case list1 {
    Nil => list2 ;
    Cons(head, tail) =>  Cons(head, concatenate(tail, list2)) ;
  }

def List<A> appendright<A>(List<A> list, A p) = 
  concatenate(list, Cons(p, Nil))

//Set functions 
def Bool contains<A>(A e, Set<A> set)=
  case set {
    EmptySet => False ;
    Insert(e, set2) => True;
    Insert(_, set2) => contains(e, set2) ;
  }

//Maps 
def B lookup<A, B>(A key, Map<A, B> map) = // retrieve from the map
  case map {
    InsertAssoc(Pair(key, elem), _) => elem ;
    InsertAssoc(_, tail) => lookup(key, tail) ;
  }
    
def Set<A> keys<A, B>(Map<A, B> map) =
  case map {
    EmptyMap => EmptySet ;
    InsertAssoc(Pair(a, _), tail) => Insert(a, keys(tail)) ;
  }

def A fst<A, B>(Pair<A, B> p) =
  case p { Pair(s, f) => s; }

def B snd<A, B>(Pair<A, B> p) =
  case p { Pair(s, f) => f; }


//type synonyms  

type Filename = String 
type Filenames = Set<String> 
type Packet = String 
type File = List<Packet>
type Catalog = List<Pair<IServer, Filenames> >



interface IServer {
  Filenames enquire();
  Int getLength(Filename fId);
  Packet getPack(Filename fId, Int pNbr);
}


interface IPeer extends IClient, IServer {
  List<IServer> getNeighbors();
}

interface IDB {
  File getFile(Filename fId);
  Int getLength(Filename fId);
  Void storeFile(Filename fId, File file);
  Filenames listFiles();
}

interface IClient {
  Pair<IServer, Filenames> availFiles(List<IServer> sList);
  Void reqFile(IServer sId, Filename fId);
}

class DataBase(Map<Filename, File> db) implements IDB {
  File getFile(Filename fId) {
    return lookup(db, fId);
  }

  Int getLength(Filename fId) {
    return length(lookup(db,fId));
  }

  Void storeFile(Filename fId, File file) {
    db = InsertAssoc(Pair(fId,file), db);
  } 

  Filenames listFiles() {
    return keys(db);
  }
}

class Node(IDB db, IPeer admin, Filename file) implements IPeer {
  Catalog catalog ;
  List<IServer> myNeighbors; 

  List<IServer> getNeighbors() {
    return myNeighbors;
  }

  IServer findServer(Filename fId, Catalog catalog) {
    if (isempty(catalog)) {
      return null;
    } else {
      if (contains(fId, snd(head(catalog)))) {
        return fst(head(catalog)) ;
      } else {
        return findServer(fId, tail(catalog)) ;
      }
    }
  }

  Void run() {
    Fut(Catalog) c ; 
    Fut(List<IServer>) f;
    List<IServer> newNeighbors;
    IServer server ; 

    neighbors = Cons(admin, Nil); 
    f = admin!getNeighbors();   // Asynchronous call to admin
    await f?;
    newNeighbors = f.get;
    neighbors = concatenate(neighbors, newNeighbors) ;
    c = this!availFiles(neighbors); // Asynchronous call
    await c?;               // Allow other peers to call in the meantime
    catalog = c.get;        // Build the catalog
    server = findServer(file,catalog); // Find the server for the requested file
    this.reqFile(server,file) ;        // Download file
  }
 
  Filenames enquire() { 
    Fut(Filenames) f ;  
    f = db!listfiles();
    await f?;
    return f.get; 
  }
        
  Int getLength(Filename fId) {
    Fut(Int) length ; 
    length = db!getLength(fId);
    await length?;
    return length.get;
  }

  Packet getPack(Filename fId, Int pNbr) {
    File f;
    Fut(File) ff;
    ff = db!getFile(fId);
    await ff?;
    f = ff.get;
    return nth(f, pNbr);
  }

  Catalog availFiles (List<IServer> sList) {
    Catalog cat;
    Filenames fNames; 
    Fut(Filenames) fN;
    Catalog catList; 
    Fut(Catalog) cL;

    if (sList == Nil) {
      cat = Nil;
    } else {
      fN = head(sList)!enquire();
      cL = this!availFiles(tail(sList));
      await fN? & cL?;
      catList = cL.get;
      fNames = fN.get;
      cat = appendright(catList, Cons(head(sList), fNames)); 
    }
    return cat; 
  }

  Void reqFile(IServer sId, Filename fId) {
    File file;
    Packet pack;
    Int lth;
    Fut(Int) l1;
    Fut(Packet) l2;

    l1 = sId!getLength(fId);
    await l1?;
    lth = l1.get; 
    while (lth > 0) {
      l2 = sId!getPack(fId, lth);
      await l2?;
      pack = l2.get ; 
      file = Cons(pack, file); 
      lth = lth - 1;
    } 
    db!storeFile(fId, file) ; 
  }
}

{ 
//Main 
}


