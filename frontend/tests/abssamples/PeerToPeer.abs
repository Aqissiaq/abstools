//$Id$ 

//data type declarations 
data Void // builtin  
data String // builtin  
data Int { builtin } 
data Package { ... } 
data SetOfString  {EmptyStringSet, InsertString(String, SetOfString)}
data ListOfPackage {NilPackage , ConsPackage(Package, ListOfPackage)} 
data ListOfServer {NilServer , ConsServer(Server, ListOfServer)} 
data ListOfPairOfServerFilenames {NilPairOfServerFilenames , ConsPairOfServerFilenames(PairOfServerFilenames, ListOfPairOfServerFilenames)} 

data PairOfServerFilenames { PairOfServerFilenames(Server,Filenames) }
data MapOfFilenameToFile { MapOfFilenameToFile(Filename,File) }


//function definitions 
def File getM(MapOfFileNameToFile map , Filename fId) = ... 

//type synonyms 
type Filename = String 
type Filenames = SetOfString 
type File =  ListOfPackage
type Catalog = ListOfPairOfServerFilenames


interface Peer extends Client, Server {}

interface DB {
  File getFile(Filename fId) 			 
  Int getLength(Filename fId)			 
  Void storeFile(Filename fId, File file)
  Filenames listFiles()                  
}

interface Client {
  PairOfServerFilenames availFiles(ListOfServer sList) 
  Void reqFile(Server sId, Filename fId)
}

interface Server {
  Filenames enquire()
  Int getLength(Filename fId)
  Package getPack(Filename fId, Int pNbr)
}

class DataBase(MapOfFilenameFile db) implements DB {

  File getFile(Filename fId) { return get(db, fId); }
  Int getLength(Filename fId){ return #(get(db,fId)); }
  Void storeFile(Filename fId, File file) { db = insert(db,fId,file); } 
  Filenames listFiles() { return keys(db); }

}

class Node(DB db, Peer admin, Filename file) implements Peer {

	Catalog catalog ; 

    Server findServer(Filename fId, Catalog catalog){
      if isempty(catalog) then 
        return null ;   
      else 
        if (fId in snd(head(catalog))) then 
		   return fst(head(catalog)) ;  
        else 
			return findServer(fId, tail(catalog)) ;  
	}


    Void run() {
	  fut(Catalog) c ; 
      ListOfServer neighbors ; 
      Server server ; 
      neighbors = admin.getNeighbors(); 
	  c = !availFiles(neighbors); 
	  await c?; 
	  catalog = c.get;
      server = findServer(file,catalog); 
	  reqFile(server,file) ; 
	}
  
    Filenames enquire() { 
      fut(Filenames) f ; 
      f = db!listfiles(); await f?; return f.get; 
    }
        
	Int getLength(Filename fId){
		fut(Int) lth ; 
		lth = db!getLength(fId); await lth?; return lth.get;
	}

    Package getPack(Filename fId, Int pNbr){
		File f; 
		fut(File) = ff ; 
		ff = db!getFile(fId) ; await ff? ; f = ff.get;
		await db.getFile(fId; f); 
		pack := nth(f, pNbr)

  with Client
    op availFiles (in  sList: List[Server]; out files: List[[Server, Set[String]]]) ==
      var l1: Label[Set[String]]; 
      var l2: Label[List[[Server, Set[String]]]] ;
      var fList: Set[String];
      if (sList = nil) then 
        files := nil
      else 
        l1!head(sList).enquire(); 
        l2!this.availFiles(tail(sList));
        await l1? && l2?; 
        l1?(fList); 
        l2?(files);
        files := files |- (head(sList), fList) 
      end

    op reqFile(in sId: Server, Filename fId) ==
      var file: List[Package] := nil; 
      var pack: Package; 
      var lth: Int;
      await sId.getLength(fId; lth);
      while (lth > 0) do 
        await sId.getPack(fId, lth; pack);
        file := pack -| file; 
        lth := lth - 1 
      end; 
      !db.storeFile(fId, file)
end 

