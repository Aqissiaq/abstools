//$Id$ 

//data type declarations 
data Unit = Unit; // builtin  
data String; // builtin  
data Int; // builtin
data Bool = True | False; // builtin
data Fut<A> ;

data Set<A> = EmptySet | Insert(A, Set<A>);
data List<A> = Nil | Cons(A, List<A>);
data Pair<A, B> = Pair(A, B);
data Map<A, B> = EmptyMap | InsertAssoc(Pair<A, B>, Map<A, B>); 


//function definitions 
//List functions 
def List<A> list<A>(List<A> l) = l; // constructor helper
def A head<A>(List<A> list) = 
  case list { Cons(p,l) => p ; }; // the head of a non-empty list

def List<A> tail<A>(List<A> list) = 
  case list { Cons(p,l) => l ; }; // the tail of a non-empty list
def Bool isEmpty<A>(List<A> list) = 
  list == Nil;             // test for empty list

def Int length<A>(List<A> list) =     // the length of a list
  case list {
    Nil => 0 ;
    Cons(p, l) => 1 + length(l) ;
  }; 

def A nth<A>(List<A> list, Int n) =
  case n {   
    0 => head(list) ;
    _ => nth(tail(list), n-1) ;
  };

def List<A> concatenate<A>(List<A> list1, List<A> list2) =
  case list1 {
    Nil => list2 ;
    Cons(head, tail) =>  Cons(head, concatenate(tail, list2)) ;
  };

def List<A> appendright<A>(List<A> list, A p) = 
  concatenate(list, Cons(p, Nil));

//Set functions 
def Bool contains<A>(Set<A> set, A e) =
  case set {
    EmptySet => False ;
    Insert(e, set2) => True;
    Insert(_, set2) => contains(set2, e);
  };

//Maps 
def Map<A, B> map<A, B>(List<Pair<A, B>> l) = // constructor helper
	case l {
		Nil => EmptyMap;
		Cons(hd, tl) => InsertAssoc(hd, map(tl));	
	};

def B lookup<A, B>(Map<A, B> map, A key) = // retrieve from the map
  case map {
    InsertAssoc(Pair(key, elem), _) => elem ;
    InsertAssoc(_, tail) => lookup(tail, key) ;
  };
    
def Set<A> keys<A, B>(Map<A, B> map) =
  case map {
    EmptyMap => EmptySet ;
    InsertAssoc(Pair(a, _), tail) => Insert(a, keys(tail)) ;
  };

def A fst<A, B>(Pair<A, B> p) =
  case p { Pair(s, f) => s; };

def B snd<A, B>(Pair<A, B> p) =
  case p { Pair(s, f) => f; };


//type synonyms  

type Filename = String ;
type Filenames = Set<String> ;
type Packet = String ;
type File = List<Packet> ;
type Catalog = List<Pair<Server, Filenames> > ;



// Application functions
def Server findServer(Filename file, Catalog catalog) =
  case catalog {
    Nil => null;
    Cons(Pair(server, files), rest) =>
      case contains(files, file) { True => server;
                                   False => findServer(file, rest); };
  };

interface Server {
  Filenames enquire();
  Int getLength(Filename fId);
  Packet getPack(Filename fId, Int pNbr);
}


interface Peer extends Client, Server { 
   Unit setAdmin(Network admin);
}

interface Network {
  List<Server> getNeighbors(Peer caller);
}

interface DataBase {
  File getFile(Filename fId);
  Int getLength(Filename fId);
  Unit storeFile(Filename fId, File file);
  Filenames listFiles();
}

interface Client {
  Unit reqFile(Server sId, Filename fId);
}

class DataBaseImpl(Map<Filename, File> db) implements DataBase {
  File getFile(Filename fId) {
    return lookup(db, fId);
  }

  Int getLength(Filename fId) {
    return length(lookup(db,fId));
  }

  Unit storeFile(Filename fId, File file) {
    db = InsertAssoc(Pair(fId,file), db);
  } 

  Filenames listFiles() {
    return keys(db);
  }
}

class Node(DataBase db, Filename file) implements Peer {
  Catalog catalog = Nil;
  List<Server> myNeighbors = Nil;
  Network admin = null;

  Unit run() {
    Fut<Catalog> c ; 
    Fut<List<Server>> f;
    Server server ; 

    await admin != null;
    f = admin!getNeighbors(this);   // Asynchronous call to admin
    await f?;
    myNeighbors = f.get;
    c = this!availFiles(myNeighbors); // Asynchronous call
    await c?;               // Allow other peers to call in the meantime
    catalog = c.get;        // Build the catalog
    server = findServer(file, catalog); // Find the server for the requested file
    if (server != null) {
      this.reqFile(server,file) ;        // Download file
    }
  }

  Unit setAdmin(Network admin) {
    this.admin = admin;
  }

  Filenames enquire() { 
    Fut<Filenames> f ;  
    f = db!listFiles();
    await f?;
    return f.get;
  }

  Int getLength(Filename fId) {
    Fut<Int> length ; 
    length = db!getLength(fId);
    await length?;
    return length.get;
  }

  Packet getPack(Filename fId, Int pNbr) {
    File f = Nil;
    Fut<File> ff;
    ff = db!getFile(fId);
    await ff?;
    f = ff.get;
    return nth(f, pNbr);
  }

  Catalog availFiles (List<Server> sList) {
    Catalog cat = Nil;
    Filenames fNames = EmptySet; 
    Fut<Filenames> fN;
    Catalog catList = Nil; 
    Fut<Catalog> cL;

    if (sList != Nil) {
      fN = head(sList)!enquire();
      cL = this!availFiles(tail(sList));
      await fN? & cL?;
      catList = cL.get;
      fNames = fN.get;
      cat = appendright(catList, Pair(head(sList), fNames)); 
    }
    return cat; 
  }

  Unit reqFile(Server sId, Filename fId) {
    File file = Nil;
    Packet pack = "";
    Int lth = 0;
    Fut<Int> l1;
    Fut<Packet> l2;

    l1 = sId!getLength(fId);
    await l1?;
    lth = l1.get; 
    while (lth > 0) {
      lth = lth - 1;            // indexing is zero-based
      l2 = sId!getPack(fId, lth);
      await l2?;
      pack = l2.get ;
      file = Cons(pack, file); 
    } 
    db!storeFile(fId, file);
  }
}

class OurTopology(Peer node0,   Peer node1,   Peer node2,   Peer node3)
implements Network
{
  List<Server> getNeighbors(Peer caller) {
    List<Server> res = Nil;
    if (caller == node0) { res = list[node1, node2]; }
    if (caller == node1) { res = list[node3]; }
    if (caller == node2) { res = list[node0, node1, node3]; }
    if (caller == node3) { res = list[node0, node2]; }
    return res;
  }
}

{ 
  Peer node0;
  Peer node1;
  Peer node2;
  Peer node3;
  DataBase db0;
  DataBase db1;
  DataBase db2;
  Network admin;
  // Map<Filename, File>
  db0 = new DataBaseImpl(map[Pair("file0", list["file", "from", "db0"])]);
  db1 = new DataBaseImpl(map[Pair("file1", list["file", "from", "db1"])]);
  db2 = new DataBaseImpl(map[Pair("file2", list["file", "from", "db2"])]);
  node0 = new Node(db0, "file2");
  node1 = new Node(db1, "file2");
  node2 = new Node(db2, "file1");
  node3 = new Node(db2, "file0");
  admin = new OurTopology(node0, node1, node2, node3);
  node0.setAdmin(admin);
  node1.setAdmin(admin);
  node2.setAdmin(admin);
  node3.setAdmin(admin);
}
