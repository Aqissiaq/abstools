// $Id$ 
// Grammar definition for the mTVL language 
// SO FAR ONLY SMALL EXAMPLE THAT COMPILES BUT DOES NOTHING


%class "MTVLParser" ;

%header {:
package mtvl.parser;

import mtvl.ast.*;
// import mtvl.frontend.exceptions.*;
import abs.frontend.parser.ParseException;
import abs.frontend.parser.ParserError;
import abs.frontend.parser.LexicalError;
import abs.frontend.parser.SyntaxError;
// import mtvl.frontend.exceptions.SyntaxError;
// import mtvl.frontend.exceptions.ParseException;
// import mtvl.frontend.exceptions.ParserError;
// import mtvl.frontend.exceptions.LexicalError;
import java.io.File;

:};


%embed {:
  private boolean verbose = false;
  
	ArrayList<ParserError> errors = new ArrayList<ParserError>();
    boolean raiseExceptions = true;
    File file;
    String sourceCode; // only set if not read from file

	public void setSourceCode(String sourceCode) {
	   this.sourceCode = sourceCode;
	}

	public void setFile(File file) {
	   this.file = file;
	}

  public void setVerbose(boolean v) {
    verbose = v;
  }

	class Events extends Parser.Events {
		public void syntaxError(Symbol token) {
			SyntaxError e = new SyntaxError("Syntactic error: unexpected token " + Terminals.NAMES[token.getId()], Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()),token);
			e.setFile(file);
			e.setSourceCode(sourceCode);
			errors.add(e);
			if (raiseExceptions) 
				throw new ParseException(e);
		}
		public void scannerError(Scanner.Exception e) {
			LexicalError err = new LexicalError("Lexical error: " + e.getMessage(), e.line, e.column);
			err.setFile(file);
			err.setSourceCode(sourceCode);
			errors.add(err);
			if (raiseExceptions) 
				throw new ParseException(err);
		}
	}

	{ report = new Events(); } // Use error handler in parser
  
	public void doRaiseExceptions(boolean raiseExceptions) {
		this.raiseExceptions = raiseExceptions;
	}

	public ArrayList<ParserError> getErrors() { return errors; }
	
	public String getFileName() {
		if (file != null)
		    return file.getAbsolutePath();
		return "<unknown>";
	}
:};


%terminals ROOT, EXTENSION, GROUP, OPT, ONEOF, ALLOF, INT, BOOL, IN, IFIN, IFOUT, EXCLUDE, REQUIRE, TRUE, FALSE, LPAREN, RPAREN, LBRACE, RBRACE, LBRACKET, RBRACKET, COMMA, SEMICOLON, COLON, UNTIL, DOT, AND, EQ, NOTEQ, PLUS, MINUS, MULT, DIV, MOD, OR, RARROW, LRARROW, NEGATION, LT, GT, LTEQ, GTEQ, AID, FID, INTLIT;


// % left RPAREN;
// % left MULT, DIV;
// % left PLUS, MINUS;

// % typeof model = "String";
// % typeof feature = "String";


%right NEGATION, MINUS;
%left MULT, DIV, MOD;
%left PLUS, MINUS;
%left EQ, NOTEQ, LT, GT, LTEQ, GTEQ;
%left AND;
%left OR;
%left RARROW,LRARROW;
%typeof compilation_unit = "CompilationUnit";
%typeof fextension_list = "List";
%typeof rootfeature_list = "List";
%typeof fextension = "FExt";
%typeof feature = "Feature";
%typeof group = "Group";
%typeof fnode_list = "List";
%typeof fnode = "FNode";
%typeof cardinality = "Cardinality";
%typeof attribute_list = "List";
%typeof attribute = "Attribute";
// %typeof type = "Type";
%typeof boundary_int = "BoundaryInt";
%typeof constraint_list = "List";
%typeof constraint = "Constr";
%typeof exp = "Exp";

%typeof featvar = "FeatVar";

%goal compilation_unit;

compilation_unit =
//    {: return new CompilationUnit(new Opt(), new List()); :} 
//    fextension_list.ext
//    {: return new CompilationUnit(new Opt(),ext); :}
    rootfeature_list.r fextension_list.ext
    {: return new CompilationUnit(r,ext); :};

fextension_list = 
    {: return new List(); :}
  | fextension_list.l fextension.ext {: return l.add(ext); :}
  ;

fextension = EXTENSION FID.f LBRACE attribute_list.as constraint_list.cl RBRACE
             {: return new FExt(f, as,cl); :} ;

rootfeature_list =
    {: return new List(); :}
  | rootfeature_list.l ROOT feature.f {: return l.add(f); :}
  ;

feature =
    FID.f {: return new Feature(f,new Opt(),new List(),new List()); :}
  | FID.f LBRACE group.g? attribute_list.as constraint_list.cl RBRACE
          {: if (g==null) return new Feature(f, new Opt(),as,cl);
             else         return new Feature(f, new Opt(g),as,cl); :}
  ;

group = GROUP cardinality.c LBRACE fnode_list.fs RBRACE
        {: return new Group (c,fs); :} ;

fnode_list = 
    fnode.f                    {: return new List().add(f); :}
  | fnode_list.l COMMA fnode.f {: return l.add(f); :}
  |                            {: return new List(); :}
  ;

fnode
  = feature.f     {: return new MandFeat(f); :} 
  | OPT feature.f {: return new OptFeat(f); :}
  ;
  
cardinality
  = ONEOF  {: return new CRange(1,1); :}
  | ALLOF  {: return new AllOf(); :}
  | LBRACKET INTLIT.i UNTIL MULT RBRACKET
           {: return new Minim(Integer.parseInt((String)i.value)); :}
  | LBRACKET INTLIT.i1 UNTIL INTLIT.i2 RBRACKET
           {: return new CRange(Integer.parseInt((String)i1.value)
                               ,Integer.parseInt((String)i2.value)); :}
  ;

attribute_list 
  =                                        {: return new List(); :}
  | attribute_list.l attribute.a SEMICOLON {: return l.add(a); :}
  ;

attribute 
  = INT AID.id IN LBRACKET boundary_int.b1 UNTIL boundary_int.b2 RBRACKET
      {: return new Attribute(id,new IntType(b1,b2)); :}
//  | type.t AID.id  {: return new Attribute(id,t); :}
  | INT AID.id 
      {: return new Attribute(id,new IntType(new Limit(), new Limit())); :}
  | INT LBRACKET boundary_int.b1 UNTIL boundary_int.b2 RBRACKET AID.id
      {: return new Attribute(id, new IntType(b1,b2)); :}
  | BOOL AID.id
      {: return new Attribute(id, new BoolType()); :}
;

//type = INT  {: return new IntType(new Limit(), new Limit()); :}
//     | INT LBRACKET boundary_int.b1 COMMA boundary_int.b2 RBRACKET
//            {: return new IntType(b1,b2); :}
//     | BOOL {: return new BoolType(); :}
//     ;

boundary_int
  = MULT      {: return new Limit(); :}
  | INTLIT.i  {: return new BoundaryVal(Integer.parseInt((String)i.value)); :}
  | MINUS INTLIT.i
              {: return new BoundaryVal((-1)*Integer.parseInt((String)i.value)); :}
  ;

constraint_list
  =                                        {: return new List(); :}
  | constraint_list.l constraint.e SEMICOLON {: return l.add(e); :}
  ;

constraint
  = exp.e               {: return e; :}
  | IFIN  COLON exp.e   {: return new IfIn(e); :}
  | IFOUT COLON exp.e   {: return new IfOut(e); :}
//  | EXCLUDE COLON FID.f {: return new Exclude(new FeatVar(f)); :}
//  | REQUIRE COLON FID.f {: return new Require(new FeatVar(f)); :}
  | EXCLUDE COLON featvar.f {: return new Exclude(f); :}
  | REQUIRE COLON featvar.f {: return new Require(f); :}
  ;

featvar = FID.f {: return new FeatVar(f); :} ;

exp =
    TRUE         {: return new BoolVal(true); :}
  | FALSE        {: return new BoolVal(false); :}
  | INTLIT.i     {: return new IntVal(Integer.parseInt((String)i.value)); :}
  | AID.id       {: return new AttVar(id); :}
  | FID.id       {: return new FeatVar(id); :}
  | FID.f DOT AID.a      {: return new FAVar(f,a); :}
  | MINUS exp.e          {: return new MinusExp(e); :}
  | NEGATION      exp.e  {: return new NegExp(e); :}
  | exp.e1 OR     exp.e2 {: return new OrBoolExp(e1,e2); :}
  | exp.e1 AND    exp.e2 {: return new AndBoolExp(e1,e2); :}
  | exp.e1 RARROW exp.e2 {: return new ImpliesExp(e1,e2); :}
  | exp.e1 LRARROW exp.e2{: return new EquivExp(e1,e2); :}
  | exp.e1 EQ     exp.e2 {: return new EqExp(e1,e2); :}
  | exp.e1 NOTEQ  exp.e2 {: return new NotEqExp(e1,e2); :}
  | exp.e1 LT     exp.e2 {: return new LTExp(e1,e2); :}
  | exp.e1 GT     exp.e2 {: return new GTExp(e1,e2); :}
  | exp.e1 LTEQ   exp.e2 {: return new LTEQExp(e1,e2); :}
  | exp.e1 GTEQ   exp.e2 {: return new GTEQExp(e1,e2); :}
  | exp.e1 PLUS   exp.e2 {: return new AddAddExp(e1,e2); :}
  | exp.e1 MINUS  exp.e2 {: return new SubAddExp(e1,e2); :}
  | exp.e1 MULT   exp.e2 {: return new MultMultExp(e1,e2); :}
  | exp.e1 DIV    exp.e2 {: return new DivMultExp(e1,e2); :}
  | exp.e1 MOD    exp.e2 {: return new ModMultExp(e1,e2); :}
  | LPAREN exp.e  RPAREN {: return e; :}
  ;
    
