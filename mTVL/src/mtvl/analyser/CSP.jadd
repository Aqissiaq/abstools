import java.util.Collection;
import java.util.ArrayList;
import mtvl.analyser.*;
import choco.Choco;
// import choco.Choco.MAX_UPPER_BOUND;
// import choco.Choco.MIN_LOWER_BOUND;
import choco.kernel.model.constraints.Constraint;
import choco.kernel.model.variables.integer.IntegerVariable;
import choco.kernel.model.variables.integer.IntegerExpressionVariable;

/**
Builds constraints and solve them.
Checks type errors, and if all variables are properly declared.
**/


aspect CSP {

  public ChocoSolver Model.getCSModel(boolean verbose) {
    ChocoSolver s = new ChocoSolver(verbose);

    // new int variable for all int variables
    for (String st : ints().keySet()) {
      BoundaryInt b1 = ints().get(st)[0];
      BoundaryInt b2 = ints().get(st)[1];
      s.addIntVar(st,getBoundary(b1,false),getBoundary(b2,true));
    }
    for (String st : bools())
      s.addBoolVar(st);
    for (String st : features())
      s.addBoolVar(st);

//     Constraint c = collectConstraints(s);
//     s.addConstraint(c);
    collectConstraints(s);
    return s;
  }
  
  private int Model.getBoundary(BoundaryInt b, Boolean positive) {
    if (b instanceof Limit) {
      if (positive) return Choco.MAX_UPPER_BOUND;
      else          return Choco.MIN_LOWER_BOUND;
    } else          return ((BoundaryVal) b).getValue();
  }
  
  // GENERAL NODE: propagate
  public Constraint ASTNode.collectConstraints(ChocoSolver s) {
		for(int i = 0; i < getNumChild(); i++)
			getChildNoTransform(i).collectConstraints(s);
	  return Choco.TRUE;
	}
	
	// ROOT: has to be present
//	public Constraint CompilationUnit.collectConstraints(ChocoSolver s) {
//	  if (hasFeature()) s.forceTrue(getFeature().getName());
//	  super.collectConstraints(s);
//	  return Choco.TRUE;
//	}
	public Constraint CompilationUnit.collectConstraints(ChocoSolver s) {
	  for (int i = 0; i < getNumFeature(); i++) {
	    s.forceTrue(getFeature(i).getName());
	  }
	  super.collectConstraints(s);
	  return Choco.TRUE;
	}


  // FEATURE -> collect constraints, check cardinality, and check children.
  public Constraint Feature.collectConstraints(ChocoSolver s) {
    for(int i = 0; i < getNumConstr(); i++)
      s.addConstraint(getConstr(i).collectConstraints(s));

    if (!hasGroup())
      return Choco.TRUE;
    
    Group g = getGroup();
    int nfeats = g.getNumFNode();
    String fname = "";
    IntegerVariable[] feats = new IntegerVariable[nfeats];
    for (int i = 0; i < nfeats; i++) {
      fname = g.getFNode(i).getFeat().getName();
      IntegerVariable v = null;
      // add intermediate variable $f if f is optional.
      if (g.getFNode(i) instanceof OptFeat) {
        v = Choco.makeBooleanVar("$"+fname);
        s.addConstraint(
          Choco.implies(s.getVar(fname),ChocoSolver.isTrue(v));
      } else {
        v = s.getVar(fname);
      }
      s.addConstraint(g.getFNode(i).collectConstraints(s));
      feats[i] = v;
      // f -> $f /\ [f]
    }
    // n1 <= $f1 + ... + $fn <= n2
    if      (g.getCard() instanceof AllOf)
      s.addConstraint(ChocoSolver.eqeq(Choco.sum(feats),nfeats));
    else if (g.getCard() instanceof Minim)
      s.addConstraint(
        Choco.geq(Choco.sum(feats),((Minim) g.getCard()).getCFrom()));
    else {
      s.addConstraint(
        Choco.geq(Choco.sum(feats),((CRange) g.getCard()).getCFrom()));
      s.addConstraint(
        Choco.leq(Choco.sum(feats),((CRange) g.getCard()).getCTo()));
    }
    return Choco.TRUE;
  }

  // FNODE
  public Constraint FNode.collectConstraints(ChocoSolver s) {
    return getFeat().collectConstraints(s);
  }
//   public Constraint OptFeat.collectConstraints(ChocoSolver s) {
//     return getFeat().collectConstraints(s);
//   }
//   public Constraint MandFeat.collectConstraints(ChocoSolver s) {
//     return Choco.and(ChocoSolver.isTrue(s.getVar(getFeat().getName()))
//                     ,getFeat().collectConstraints(s));
//   }
  
  // FExt
  public Constraint FExt.collectConstraints(ChocoSolver s) {
    for(int i = 0; i < getNumConstr(); i++)
      s.addConstraint(getConstr(i).collectConstraints(s));
    return Choco.TRUE;
  }
  
  // IFIN/IFOUT
  public Constraint IfIn.collectConstraints(ChocoSolver s) {
    Constraint c =
      Choco.implies(ChocoSolver.isTrue(s.getVar(pname())), getExpr().collectConstraints(s));
    //s.addConstraint(c);
    //return Choco.TRUE;
    return c;
  } 
  public Constraint IfOut.collectConstraints(ChocoSolver s) {
    Constraint c =
      Choco.implies(Choco.not(ChocoSolver.isTrue(s.getVar(pname()))), getExpr().collectConstraints(s));
    return c;
  } 
  
  // REQUIRE/EXCLUDE
  public Constraint Require.collectConstraints(ChocoSolver s) {
    Constraint c = 
      Choco.implies(ChocoSolver.isTrue(s.getVar(pname())), ChocoSolver.isTrue(s.getVar(getFeatVar().getFName())));
    return c;
  } 
  public Constraint Exclude.collectConstraints(ChocoSolver s) {
    Constraint c = 
      Choco.nand(s.getVar(pname()), s.getVar(getFeatVar().getFName()));
    return c;
  } 
  
  // EXPRESSIONS
  // EXP: GENERAL (always overwritten when the program type-checks)
  public Constraint Exp.collectConstraints(ChocoSolver s) {
    return null;
  }
  public IntegerExpressionVariable Exp.collectIntExpr(ChocoSolver s) {
    return null;
  }
  // EXP:VARS
  public Constraint Variable.collectConstraints(ChocoSolver s) {
    return ChocoSolver.isTrue(s.getVar(getFullName()));
  }
//   public Constraint Att.collectConstraints(ChocoSolver s) {
//     return Choco.and(getFullName());
//   }
  
  public IntegerExpressionVariable Variable.collectIntExpr(ChocoSolver s) {
    return s.getVar(getFullName());
  }
  
  //EXP:VALUES
  public Constraint BoolVal.collectConstraints(ChocoSolver s) {
    if (getValue()) return Choco.TRUE;
    else            return Choco.FALSE;
  }
  public IntegerExpressionVariable IntVal.collectIntExpr(ChocoSolver s) {
    return Choco.constant(getValue());
  }
  
  // EXP: AddExp
  public IntegerExpressionVariable AddAddExp.collectIntExpr(ChocoSolver s) {
    return Choco.plus(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }
  public IntegerExpressionVariable SubAddExp.collectIntExpr(ChocoSolver s) {
    return Choco.minus(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }
  
  // EXP: MultExp
  public IntegerExpressionVariable MultMultExp.collectIntExpr(ChocoSolver s) {
    return Choco.mult(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }
  public IntegerExpressionVariable DivMultExp.collectIntExpr(ChocoSolver s) {
    return Choco.div(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }
  public IntegerExpressionVariable ModMultExp.collectIntExpr(ChocoSolver s) {
    return Choco.mod(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }
  
  // EXP: Unary
  public IntegerExpressionVariable MinusExp.collectIntExpr(ChocoSolver s) {
    return Choco.neg(getOperand().collectIntExpr(s));
  }
  public Constraint NegExp.collectConstraints(ChocoSolver s) {
    return Choco.not(getOperand().collectConstraints(s));
  }
  
  // EXP: EqualityExpr
  public Constraint EqExp.collectConstraints(ChocoSolver s) {
    if (isInt)
      return ChocoSolver.eqeq(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
    else
      return Choco.ifOnlyIf(getLeft().collectConstraints(s),getRight().collectConstraints(s));
  }

  // EXP: RelationalExpr
  public Constraint GTEQExp.collectConstraints(ChocoSolver s) {
    return Choco.geq(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }
  public Constraint LTEQExp.collectConstraints(ChocoSolver s) {
    return Choco.leq(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }
  public Constraint GTExp.collectConstraints(ChocoSolver s) {
    return Choco.gt(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }
  public Constraint LTExp.collectConstraints(ChocoSolver s) {
    return Choco.lt(getLeft().collectIntExpr(s),getRight().collectIntExpr(s));
  }

  // EXP: BoolExp
  public Constraint EquivExp.collectConstraints(ChocoSolver s) {
    return Choco.ifOnlyIf(getLeft().collectConstraints(s),getRight().collectConstraints(s));
  }
  public Constraint ImpliesExp.collectConstraints(ChocoSolver s) {
    return Choco.implies(getLeft().collectConstraints(s),getRight().collectConstraints(s));
  }
  public Constraint OrBoolExp.collectConstraints(ChocoSolver s) {
    return Choco.or(getLeft().collectConstraints(s),getRight().collectConstraints(s));
  }
  public Constraint AndBoolExp.collectConstraints(ChocoSolver s) {
    return Choco.and(getLeft().collectConstraints(s),getRight().collectConstraints(s));
  }
}
