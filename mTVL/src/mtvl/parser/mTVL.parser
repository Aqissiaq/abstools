// Grammar definition for the ABS language
// $Id: ABS.parser 9859 2011-03-21 10:51:38Z ramus $


// %class "MTVLParser" ;

%header {:
package mtvl.parser;

import mtvl.ast.*;
// import mtvl.frontend.exceptions.*;
import abs.frontend.parser.ParseException;
import abs.frontend.parser.ParserError;
import abs.frontend.parser.LexicalError;
import abs.frontend.parser.SyntaxError;
// import mtvl.frontend.exceptions.SyntaxError;
// import mtvl.frontend.exceptions.ParseException;
// import mtvl.frontend.exceptions.ParserError;
// import mtvl.frontend.exceptions.LexicalError;
import java.io.File;

:};


%embed {:
  private boolean verbose = false;
  
	ArrayList<ParserError> errors = new ArrayList<ParserError>();
    boolean raiseExceptions = true;
    File file;
    String sourceCode; // only set if not read from file

	public void setSourceCode(String sourceCode) {
	   this.sourceCode = sourceCode;
	}

	public void setFile(File file) {
	   this.file = file;
	}

  public void setVerbose(boolean v) {
    verbose = v;
  }

	class Events extends Parser.Events {
		public void syntaxError(Symbol token) {
			SyntaxError e = new SyntaxError("Syntactic error: unexpected token " + Terminals.NAMES[token.getId()], Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()),token);
			e.setFile(file);
			e.setSourceCode(sourceCode);
			errors.add(e);
			if (raiseExceptions) 
				throw new ParseException(e);
		}
		public void scannerError(Scanner.Exception e) {
			LexicalError err = new LexicalError("Lexical error: " + e.getMessage(), e.line, e.column);
			err.setFile(file);
			err.setSourceCode(sourceCode);
			errors.add(err);
			if (raiseExceptions) 
				throw new ParseException(err);
		}
	}

	{ report = new Events(); } // Use error handler in parser
  
	public void doRaiseExceptions(boolean raiseExceptions) {
		this.raiseExceptions = raiseExceptions;
	}

	public ArrayList<ParserError> getErrors() { return errors; }
	
	public String getFileName() {
		if (file != null)
		    return file.getAbsolutePath();
		return "<unknown>";
	}
:};


//%right NEGATION, MINUS;
//%left MULT, DIV, MOD;
//%left PLUS, MINUS;
//%left EQ, NOTEQ, LT, GT, LTEQ, GTEQ;
//%left AND;
//%left OR;
//%left RARROW,LRARROW;

CompilationUnit compilation_unit =
    rootfeature_list.r fextension_list.ext
    {: return new CompilationUnit(r,ext); :};

List fextension_list =
    {: return new List(); :}
  | fextension_list.l fextension.ext {: return l.add(ext); :}
  ;

FExt fextension = EXTENSION FID.f LBRACE attribute_list.as constraint_list.cl RBRACE
             {: return new FExt(f, as,cl); :} ;

List rootfeature_list =
    {: return new List(); :}
  | rootfeature_list.l ROOT feature.f {: return l.add(f); :}
  ;

Feature feature =
    FID.f {: return new Feature(f,new Opt(),new List(),new List()); :}
  | FID.f LBRACE group.g? attribute_list.as constraint_list.cl RBRACE
          {: return new Feature(f, g,as,cl); :}
  ;

Group group = GROUP cardinality.c LBRACE fnode_list.fs RBRACE
        {: return new Group (c,fs); :} ;

List fnode_list =
    fnode.f                    {: return new List().add(f); :}
  | fnode_list.l COMMA fnode.f {: return l.add(f); :}
  |                            {: return new List(); :}
  ;

FNode fnode
  = feature.f     {: return new MandFeat(f); :} 
  | OPT feature.f {: return new OptFeat(f); :}
  ;
  
Cardinality cardinality
  = ONEOF  {: return new CRange(1,1); :}
  | ALLOF  {: return new AllOf(); :}
  | LBRACKET INTLIT.i UNTIL MULT RBRACKET
           {: return new Minim(Integer.parseInt(i)); :}
  | LBRACKET INTLIT.i1 UNTIL INTLIT.i2 RBRACKET
           {: return new CRange(Integer.parseInt(i1)
                               ,Integer.parseInt(i2)); :}
  ;

List attribute_list
  =                                        {: return new List(); :}
  | attribute_list.l attribute.a SEMICOLON {: return l.add(a); :}
  ;

Attribute attribute
  = INT AID.id IN LBRACKET boundary_int.b1 UNTIL boundary_int.b2 RBRACKET
      {: return new Attribute(id,new IntType(b1,b2)); :}
  | INT AID.id
      {: return new Attribute(id,new IntType(new Limit(), new Limit())); :}
  | INT LBRACKET boundary_int.b1 UNTIL boundary_int.b2 RBRACKET AID.id
      {: return new Attribute(id, new IntType(b1,b2)); :}
  | BOOL AID.id
      {: return new Attribute(id, new BoolType()); :}
;

BoundaryInt boundary_int
  = MULT      {: return new Limit(); :}
  | INTLIT.i  {: return new BoundaryVal(Integer.parseInt(i)); :}
  | MINUS INTLIT.i
              {: return new BoundaryVal((-1)*Integer.parseInt(i)); :}
  ;

List constraint_list
  =                                        {: return new List(); :}
  | constraint_list.l constraint.e SEMICOLON {: return l.add(e); :}
  ;

Constr constraint
  = exp.e               {: return new IfIn(e); :} // hack to make IfIn implicit!
  | IFIN  COLON exp.e   {: return new IfIn(e); :}
  | IFOUT COLON exp.e   {: return new IfOut(e); :}
  | EXCLUDE COLON featvar.f {: return new Exclude(f); :}
  | REQUIRE COLON featvar.f {: return new Require(f); :}
  ;

FeatVar featvar = FID.f {: return new FeatVar(f); :} ;

Exp exp
  = and_exp
  | exp.e1 OR     and_exp.e2 {: return new OrBoolExp(e1,e2); :};

Exp and_exp
  = impl_exp
  | and_exp.e1 AND    impl_exp.e2 {: return new AndBoolExp(e1,e2); :};

Exp impl_exp
  = eq_exp
  | impl_exp.e1 RARROW  eq_exp.e2{: return new ImpliesExp(e1,e2); :}
  | impl_exp.e1 LRARROW eq_exp.e2{: return new EquivExp(e1,e2); :};

Exp eq_exp
  = rel_exp
  | eq_exp.e1 EQ     rel_exp.e2 {: return new EqExp(e1,e2); :}
  | eq_exp.e1 NOTEQ  rel_exp.e2 {: return new NotEqExp(e1,e2); :};

Exp rel_exp
  = add_exp
  | rel_exp.e1 LT     add_exp.e2 {: return new LTExp(e1,e2); :}
  | rel_exp.e1 GT     add_exp.e2 {: return new GTExp(e1,e2); :}
  | rel_exp.e1 LTEQ   add_exp.e2 {: return new LTEQExp(e1,e2); :}
  | rel_exp.e1 GTEQ   add_exp.e2 {: return new GTEQExp(e1,e2); :};

Exp add_exp
  = mult_exp.e {: return e; :}
  | add_exp.e1 PLUS   mult_exp.e2 {: return new AddAddExp(e1,e2); :}
  | add_exp.e1 MINUS  mult_exp.e2 {: return new SubAddExp(e1,e2); :};

Exp mult_exp
  = factor_exp.e {: return e; :}
  | mult_exp.e1 MULT   factor_exp.e2 {: return new MultMultExp(e1,e2); :}
  | mult_exp.e1 DIV    factor_exp.e2 {: return new DivMultExp(e1,e2); :}
  | mult_exp.e1 MOD    factor_exp.e2 {: return new ModMultExp(e1,e2); :};

Exp factor_exp
  = lit_exp
  | NEGATION factor_exp.e  {: return new NegExp(e); :}
  | MINUS    factor_exp.e  {: return new MinusExp(e); :}
  | LPAREN exp.e  RPAREN   {: return e; :};

Exp lit_exp
  = TRUE         {: return new BoolVal(true); :}
  | FALSE        {: return new BoolVal(false); :}
  | INTLIT.i     {: return new IntVal(Integer.parseInt(i)); :}
  | AID.id       {: return new AttVar(id); :}
  | FID.id       {: return new FeatVar(id); :}
  | FID.f DOT AID.a      {: return new FAVar(f,a); :};
    
